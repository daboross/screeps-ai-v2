"use strict";
function activateCustomizations() {
    "use strict";
    // Created by @gdborton on GitHub, available at https://github.com/gdborton/screeps-perf/blob/master/screeps-perf.js
    Array.prototype.filter = function (callback, thisArg) {
        var results = [];
        var arr = this;
        for (var iterator = 0; iterator < arr.length; iterator++) {
            if (callback.call(thisArg, arr[iterator], iterator, arr)) {
                results.push(arr[iterator]);
            }
        }
        return results;
    };

    // Created by @gdborton on GitHub, available at https://github.com/gdborton/screeps-perf/blob/master/screeps-perf.js
    Array.prototype.forEach = function (callback, thisArg) {
        var arr = this;
        for (var iterator = 0; iterator < arr.length; iterator++) {
            callback.call(thisArg, arr[iterator], iterator, arr);
        }
    };

    // Created by @gdborton on GitHub, available at https://github.com/gdborton/screeps-perf/blob/master/screeps-perf.js
    Array.prototype.map = function (callback, thisArg) {
        var arr = this;
        var returnVal = [];
        for (var iterator = 0; iterator < arr.length; iterator++) {
            returnVal.push(callback.call(thisArg, arr[iterator], iterator, arr));
        }
        return returnVal;
    };

    // Default Creep.prototype.getActiveBodyparts:
    // function (type) {
    //     return _.filter(this.body, i => i.hits > 0 && i.type == type).length;
    // }
    Creep.prototype.getActiveBodyparts = function (type) {
        var total = 0;
        for (var i = this.body.length; i-- > 0;) {
            var x = this.body[i];
            if (x.hits <= 0) {
                break;
            }
            if (x.type == type) {
                total += 1;
            }
        }
        return total;
    };

    // Custom addition
    Creep.prototype.hasActiveBodyparts = function (type) {
        for (var i = this.body.length; i-- > 0;) {
            var x = this.body[i];
            if (x.hits <= 0) {
                break;
            }
            if (x.type == type) {
                return true;
            }
        }
        return false;
    };

    // Custom addition
    Creep.prototype.hasActiveBoostedBodyparts = function (type) {
        for (var i = this.body.length; i-- > 0;) {
            var x = this.body[i];
            if (x.hits <= 0) {
                break;
            }
            if (x.boost !== undefined && x.type == type) {
                return true;
            }
        }
        return false;
    };

    // Custom addition
    Creep.prototype.getBodyparts = function (type) {
        var total = 0;
        for (var i = this.body.length; i-- > 0;) {
            var x = this.body[i];
            if (x.type == type) {
                total += 1;
            }
        }
        return total;
    };

    // Custom addition
    Creep.prototype.hasBodyparts = function (type) {
        for (var i = this.body.length; i-- > 0;) {
            var x = this.body[i];
            if (x.type == type) {
                return true;
            }
        }
        return false;
    };

    // Custom addition
    Creep.prototype.getActiveBodypartsBoostEquivalent = function (type, action) {
        var total = 0;
        var typeBoosts, boostPowers, actionPower;

        typeBoosts = BOOSTS[type];
        for (var i = this.body.length; i-- > 0;) {
            var x = this.body[i];
            if (x.hits <= 0) {
                break;
            }
            if (x.type == type) {
                if (x.boost !== undefined && typeBoosts !== undefined) {
                    boostPowers = typeBoosts[x.boost]
                    if (boostPowers !== undefined) {
                        actionPower = boostPowers[action];
                        if (actionPower !== undefined) {
                            total += actionPower;
                        } else {
                            total += 1;
                        }
                    } else {
                        total += 1;
                    }
                } else {
                    total += 1;
                }
            }
        }
        return total;
    };

    // Custom additionF
    Creep.prototype.getBodypartsBoostEquivalent = function (type, action) {
        var total = 0;
        var typeBoosts, boostPowers, actionPower;

        typeBoosts = BOOSTS[type];
        for (var i = this.body.length; i-- > 0;) {
            var x = this.body[i];
            if (x.type == type) {
                if (x.boost !== undefined && typeBoosts !== undefined) {
                    boostPowers = typeBoosts[x.boost]
                    if (boostPowers !== undefined) {
                        actionPower = boostPowers[action];
                        if (actionPower !== undefined) {
                            total += actionPower;
                        } else {
                            total += 1;
                        }
                    } else {
                        total += 1;
                    }
                } else {
                    total += 1;
                }
            }
        }
        return total;
    };

    // Default RoomPosition.prototype.isNearTo:
    // function (firstArg, secondArg) {
    //     var _utils$fetchXYArgumen9 = utils.fetchXYArguments(firstArg, secondArg, globals);
    //
    //     var _utils$fetchXYArgumen10 = _slicedToArray(_utils$fetchXYArgumen9, 3);
    //
    //     var x = _utils$fetchXYArgumen10[0];
    //     var y = _utils$fetchXYArgumen10[1];
    //     var roomName = _utils$fetchXYArgumen10[2];
    //
    //     return abs(x - this.x) <= 1 && abs(y - this.y) <= 1 && (!roomName || roomName == this.roomName);
    // }
    RoomPosition.prototype.isNearTo = function (arg1, arg2) {
        if (arg2 == undefined) {
            if (arg1.pos) {
                arg1 = arg1.pos;
            }
            return Math.abs(arg1.x - this.x) <= 1 && Math.abs(arg1.y - this.y) <= 1 && arg1.roomName == this.roomName;
        } else {
            return Math.abs(arg1 - this.x) <= 1 && Math.abs(arg2 - this.y) <= 1;
        }
    };

    // Default RoomPosition.prototype.isEqualTo:
    // function (firstArg, secondArg) {
    //     var _utils$fetchXYArgumen15 = utils.fetchXYArguments(firstArg, secondArg, globals);
    //
    //     var _utils$fetchXYArgumen16 = _slicedToArray(_utils$fetchXYArgumen15, 3);
    //
    //     var x = _utils$fetchXYArgumen16[0];
    //     var y = _utils$fetchXYArgumen16[1];
    //     var roomName = _utils$fetchXYArgumen16[2];
    //
    //     return x == this.x && y == this.y && (!roomName || roomName == this.roomName);
    // }
    RoomPosition.prototype.isEqualTo = function (arg1, arg2) {
        if (arg2 == undefined) {
            if (arg1 == undefined) {
                return false;
            }
            if (arg1.pos) {
                arg1 = arg1.pos;
            }
            return arg1.x == this.x && arg1.y == this.y && arg1.roomName == this.roomName;
        } else {
            return arg1 == this.x && arg2 == this.y;
        }
    };


    // Default RoomPosition.prototype.inRangeTo:
    // function (firstArg, secondArg, thirdArg) {
    //     var x = firstArg,
    //         y = secondArg,
    //         range = thirdArg,
    //         roomName = this.roomName;
    //     if (_.isUndefined(thirdArg)) {
    //         var pos = firstArg;
    //         if (pos.pos) {
    //             pos = pos.pos;
    //         }
    //         x = pos.x;
    //         y = pos.y;
    //         roomName = pos.roomName;
    //         range = secondArg;
    //     }
    //
    //     return abs(x - this.x) <= range && abs(y - this.y) <= range && roomName == this.roomName;
    // }
    RoomPosition.prototype.inRangeTo = function (arg1, arg2, arg3) {
        if (arg3 === undefined) {
            if (arg1.pos) {
                arg1 = arg1.pos;
            }
            return Math.abs(arg1.x - this.x) <= arg2 && Math.abs(arg1.y - this.y) <= arg2 && arg1.roomName == this.roomName;
        } else {
            return Math.abs(arg1 - this.x) <= arg3 && Math.abs(arg2 - this.y) <= arg3;
        }
    };

    // Default RoomPosition.prototype.getRangeTo:
    // function (firstArg, secondArg) {
    //     var _utils$fetchXYArgumen17 = utils.fetchXYArguments(firstArg, secondArg, globals);
    //
    //     var _utils$fetchXYArgumen18 = _slicedToArray(_utils$fetchXYArgumen17, 3);
    //
    //     var x = _utils$fetchXYArgumen18[0];
    //     var y = _utils$fetchXYArgumen18[1];
    //     var roomName = _utils$fetchXYArgumen18[2];
    //
    //     if (roomName && roomName != this.roomName) {
    //         return Infinity;
    //     }
    //     return max(abs(this.x - x), abs(this.y - y));
    // }
    RoomPosition.prototype.getRangeTo = function (arg1, arg2) {
        if (arg2 === undefined) {
            if (arg1.pos) {
                arg1 = arg1.pos;
            }
            if (arg1.roomName && arg1.roomName != this.roomName) {
                return Infinity;
            }
            return Math.max(Math.abs(this.x - arg1.x), Math.abs(this.y - arg1.y));
        } else {
            return Math.max(Math.abs(this.x - arg1), Math.abs(this.y - arg2));
        }
    };

    // PathFinding functions:

    const directionToDxDy = function (dir) {
        switch (dir) {
            case TOP:
                return [0, -1];
            case TOP_RIGHT:
                return [1, -1];
            case RIGHT:
                return [1, 0];
            case BOTTOM_RIGHT:
                return [1, 1];
            case BOTTOM:
                return [0, 1];
            case BOTTOM_LEFT:
                return [-1, 1];
            case LEFT:
                return [-1, 0];
            case TOP_LEFT:
                return [-1, -1];
            default:
                return null;
        }
    };

    const dxDyToDirection = function (dx, dy) {
        if (dx < 0) {
            if (dy < 0) {
                return TOP_LEFT;
            } else if (dy > 0) {
                return BOTTOM_LEFT;
            } else {
                return LEFT;
            }
        } else if (dx > 0) {
            if (dy < 0) {
                return TOP_RIGHT;
            } else if (dy > 0) {
                return BOTTOM_RIGHT;
            } else {
                return RIGHT;
            }
        } else {
            if (dy < 0) {
                return TOP;
            } else if (dy > 0) {
                return BOTTOM;
            } else {
                // both dx and dy are 0!
                return null;
            }
        }
    };

    /**
     * Searches for a path using PathFinder and the given opts, turns the path into a Room.findPath-compatible
     * serialized result, and returns that result.
     *
     * Please ensure that all arguments have been validated when passing in, and that targetPos is a raw position
     * (not a RoomObject with a pos property).
     */
    const findPathPathFinder = function (originPos, targetPos, options) {
        const result = PathFinder.search(
            originPos,
            {
                pos: targetPos,
                range: 'range' in options ? options.range : 1,
            },
            options
        );

        const path = result.path;
        var resultStringArray = []; // it's faster to use [...].join('') than to continuously add to a string iirc.
        var roomToConvert = originPos.roomName;

        if (path.length < 1) {
            return '';
        }

        // The serialized format starts with the _second_ position's x and y values, then the direction from the
        // first pos to second, then direction from second to third, etc. originPos is the first pos, input[0] is
        // the second, input[1] is the third, etc.

        if (path[0].x > 9) {
            resultStringArray.push(path[0].x);
        } else {
            resultStringArray.push(0, path[0].x); // 0-pad
        }
        if (path[0].y > 9) {
            resultStringArray.push(path[0].y);
        } else {
            resultStringArray.push(0, path[0].y); // 0-pad
        }

        var last_x = originPos.x;
        var last_y = originPos.y;
        var pos, dx, dy, dir;
        for (var i = 0; i < path.length; i++) {
            pos = path[i];
            dx = pos.x - last_x;
            dy = pos.y - last_y;
            if (dx === -49) {
                dx = 1;
            } else if (dx === 49) {
                dx = -1;
            }
            if (dy === -49) {
                dy = 1;
            } else if (dy === 49) {
                dy = -1;
            }

            resultStringArray.push(dxDyToDirection(dx, dy));
            if (pos.roomName != roomToConvert) {
                break;
            }
            last_x = pos.x;
            last_y = pos.y;
        }
        return resultStringArray.join('');
    };

    // Default Creep.prototype.moveByPath:
    // function (path) {
    //     if (_.isArray(path) && path.length > 0 && path[0] instanceof globals.RoomPosition) {
    //         var idx = _.findIndex(path, i => i.isEqualTo(this.pos));
    //         if (idx === -1) {
    //             if (!path[0].isNearTo(this.pos)) {
    //                 return C.ERR_NOT_FOUND;
    //             }
    //         }
    //         idx++;
    //         if (idx >= path.length) {
    //             return C.ERR_NOT_FOUND;
    //         }
    //
    //         return this.move(this.pos.getDirectionTo(path[idx]));
    //     }
    //
    //     if (_.isString(path)) {
    //         path = utils.deserializePath(path);
    //     }
    //     if (!_.isArray(path)) {
    //         return C.ERR_INVALID_ARGS;
    //     }
    //     var cur = _.find(path, i => i.x - i.dx == this.pos.x && i.y - i.dy == this.pos.y);
    //     if (!cur) {
    //         return C.ERR_NOT_FOUND;
    //     }
    //
    //     return this.move(cur.direction);
    // }
    Creep.prototype.__moveByPath = Creep.prototype.moveByPath;
    Creep.prototype.moveByPath = function (path) {
        if (!_.isString(path)) {
            return this.__moveByPath(path);
        }
        var path_len = path.length;
        if (path_len < 5) {
            return ERR_NOT_FOUND;
        }
        var my_x = this.pos.x, my_y = this.pos.y;
        var x_to_check = +path.slice(0, 2);
        var y_to_check = +path.slice(2, 4);
        var dir, dxdy;
        // The path serialization format basically starts with the second position x, second position y, and then
        // follows with a list of directions *to get to each position*. To clarify, the first direction, at idx=4,
        // gives the direction *from the first position to the second position*. So, to find the first position,
        // we subtract that! I do think this is actually more performant than trying to do any more complicated
        // logic in the loop.
        dxdy = directionToDxDy(+path[4]);
        x_to_check -= dxdy[0];
        y_to_check -= dxdy[1];
        // Since we start at 4 again, we'll be re-adding what we just subtracted above - this lets us check both the
        // first and second positions correctly!
        for (var idx = 4; idx < path_len; idx++) {
            // Essentially at this point, *_to_check represent the point reached by the *last* movement (the pos
            // reached by the movement at (idx - 1) since idx just got incremented at the start of this loop)
            // Also, if this is the first iteration and x/y_to_check match the first pos, idx is at 4, the fifth
            // pos, directly after the initial x/y, and also the first direction to go!
            if (x_to_check === my_x && y_to_check == my_y) {
                // console.log(`[${this.memory.home}][${this.name}] Found my position (${my_x}, ${my_y})`);
                dir = +path[idx];
                return this.move(dir);
            } else {
                // console.log(`[${this.memory.home}][${this.name}] Not my position: (${x_to_check}, ${y_to_check})`);
            }
            dxdy = directionToDxDy(+path[idx]);
            if (dxdy === null) {
                console.log(`Unknown direction! couldn't figure out '${path[idx]}'`);
                return ERR_INVALID_ARGS;
            }
            x_to_check += dxdy[0];
            y_to_check += dxdy[1];
        }
        return ERR_NOT_FOUND;
    };

    // Default Creep.prototype.moveTo:
    // function (firstArg, secondArg, opts) {
    //
    //     if (!this.my) {
    //         return C.ERR_NOT_OWNER;
    //     }
    //     if (this.spawning) {
    //         return C.ERR_BUSY;
    //     }
    //     if (data(this.id).fatigue > 0) {
    //         return C.ERR_TIRED;
    //     }
    //     if (this.getActiveBodyparts(C.MOVE) == 0) {
    //         return C.ERR_NO_BODYPART;
    //     }
    //
    //     var _utils$fetchXYArgumen = utils.fetchXYArguments(firstArg, secondArg, globals);
    //
    //     var _utils$fetchXYArgumen2 = _slicedToArray(_utils$fetchXYArgumen, 3);
    //
    //     var x = _utils$fetchXYArgumen2[0];
    //     var y = _utils$fetchXYArgumen2[1];
    //     var roomName = _utils$fetchXYArgumen2[2];
    //
    //     roomName = roomName || this.pos.roomName;
    //     if (_.isUndefined(x) || _.isUndefined(y)) {
    //         register.assertTargetObject(firstArg);
    //         return C.ERR_INVALID_TARGET;
    //     }
    //
    //     var targetPos = new globals.RoomPosition(x, y, roomName);
    //
    //     if (_.isObject(firstArg)) {
    //         opts = _.clone(secondArg);
    //     }
    //     opts = opts || {};
    //
    //     if (_.isUndefined(opts.reusePath)) {
    //         opts.reusePath = 5;
    //     }
    //     if (_.isUndefined(opts.serializeMemory)) {
    //         opts.serializeMemory = true;
    //     }
    //
    //     if (x == this.pos.x && y == this.pos.y && roomName == this.pos.roomName) {
    //         return C.OK;
    //     }
    //
    //     if (opts.reusePath && this.memory && _.isObject(this.memory) && this.memory._move) {
    //
    //         var _move = this.memory._move;
    //
    //         if (runtimeData.time > _move.time + parseInt(opts.reusePath) || _move.room != this.pos.roomName) {
    //             delete this.memory._move;
    //         } else if (_move.dest.room == roomName && _move.dest.x == x && _move.dest.y == y) {
    //
    //             var path = _.isString(_move.path) ? utils.deserializePath(_move.path) : _move.path;
    //
    //             var idx = _.findIndex(path, { x: this.pos.x, y: this.pos.y });
    //             if (idx != -1) {
    //                 var oldMove = _.cloneDeep(_move);
    //                 path.splice(0, idx + 1);
    //                 try {
    //                     _move.path = opts.serializeMemory ? utils.serializePath(path) : path;
    //                 } catch (e) {
    //                     console.log('$ERR', this.pos, x, y, roomName, JSON.stringify(path), '-----', JSON.stringify(oldMove));
    //                     throw e;
    //                 }
    //             }
    //             if (path.length == 0) {
    //                 return this.pos.isNearTo(targetPos) ? C.OK : C.ERR_NO_PATH;
    //             }
    //             var result = this.moveByPath(path);
    //
    //             if (result == C.OK) {
    //                 return C.OK;
    //             }
    //         }
    //     }
    //
    //     if (opts.noPathFinding) {
    //         return C.ERR_NOT_FOUND;
    //     }
    //
    //     var path = this.pos.findPathTo(targetPos, opts);
    //
    //     if (opts.reusePath && this.memory && _.isObject(this.memory)) {
    //         this.memory._move = {
    //             dest: { x, y, room: roomName },
    //             time: runtimeData.time,
    //             path: opts.serializeMemory ? utils.serializePath(path) : _.clone(path),
    //             room: this.pos.roomName
    //         };
    //     }
    //
    //     if (path.length == 0) {
    //         return C.ERR_NO_PATH;
    //     }
    //     this.move(path[0].direction);
    //     return C.OK;
    // }
    Creep.prototype.__moveTo = Creep.prototype.moveTo;

    /**
     * Custom replacement of moveTo, which just calls moveTo unless a 'roomCallback' argument is passed in in the
     * options. The memory format this function uses is identical to the default moveTo's, so it is supported
     * alternate* calling this function with and without the 'roomCallback' option.
     *
     * When passed roomCallback, this function:
     * - assumes that Creep.prototype.moveByPath has already been optimized to deal with
     *   serialized paths, and will pass it purely serialized paths.
     * - does not accept the 'serializeMemory' option, and will always assume it is set to true
     * - does not accept any of the 'costCallback', 'ignoreCreeps', 'ignoreRoads' or 'ignoreDestructibleStructures'
     *   options. (note: roomCallback is used by PathFinder instead of the costCallback used by findPath)
     * - passes all arguments on to PathFinder.search as is.
     * - accepts one additional option, 'range', which is passed into PathFinder as part of the target object.
     */
    Creep.prototype.moveTo = function (arg1, arg2, arg3) {
        var targetPos, opts;
        if (arg3 === undefined) {
            if (arg1.pos) {
                arg1 = arg1.pos;
            }
            targetPos = arg1;
            opts = arg2 || {};
        } else {
            targetPos = new RoomPosition(arg1, arg2, this.pos.roomName);
            opts = arg3 || {};
        }

        if (!('roomCallback' in opts)) {
            return this.__moveTo(arg1, arg2, arg3); // Compatible memory format.
        }
        if (!_.isNumber(targetPos.x) || !_.isNumber(targetPos.y) || !_.isString(targetPos.roomName)) {
            return ERR_INVALID_TARGET;
        }
        if (!_.isObject(opts)) {
            return ERR_INVALID_ARGS;
        }
        if (!this.my) {
            return ERR_NOT_OWNER;
        }
        if (this.spawning) {
            return ERR_BUSY
        }
        if (this.fatigue > 0) {
            return ERR_TIRED
        }
        if (!this.hasActiveBodyparts(MOVE)) {
            return ERR_NO_BODYPART;
        }

        if (this.pos.isNearTo(targetPos)) {
            if (this.pos.isEqualTo(targetPos)) {
                return OK;
            } else {
                return this.move(this.pos.getDirectionTo(targetPos));
            }
        }

        const reusePath = _.isObject(this.memory) && ('reusePath' in opts ? opts.reusePath : 5);

        if (reusePath) {
            var _move = this.memory._move;

            if (_.isObject(_move)
                && Game.time <= _move.time + Number(reusePath)
                && _move.room == this.pos.roomName
                && _move.dest.room == targetPos.roomName
                && _move.dest.x == targetPos.x
                && _move.dest.y == targetPos.y) {

                // moveByPath is optimized to deal with serialized paths already, and it's more CPU to
                // re-serialize each tick with a smaller string than it is to store the larger string the
                // whole time.
                var byPathResult = this.moveByPath(_move.path);
                if (byPathResult !== ERR_NOT_FOUND && byPathResult !== ERR_INVALID_ARGS
                    && byPathResult !== ERR_NO_PATH) {
                    return byPathResult;
                }
            }
        }

        if (opts.noPathFinding) {
            return ERR_NOT_FOUND;
        }

        // This uses PathFinder, and returns the result as an already-serialized path.
        const path = findPathPathFinder(this.pos, targetPos, opts);

        if (reusePath) {
            this.memory._move = {
                dest: {
                    x: targetPos.x,
                    y: targetPos.y,
                    room: targetPos.roomName,
                },
                time: Game.time,
                path: path,
                room: this.pos.roomName,
            }
        }

        return this.moveByPath(path);
    };

    global.__customizations_active = true;
}

if (!global.__customizations_active) {
    activateCustomizations()
}
"use strict";
// Transcrypt'ed from Python, 2017-01-16 01:31:14
function main () {
   var __symbols__ = ['__py3.5__', '__esv5__'];
    var __all__ = {};
    var __world__ = __all__;

    // Nested object creator, part of the nesting may already exist and have attributes
    var __nest__ = function (headObject, tailNames, value) {
        // In some cases this will be a global object, e.g. 'window'
        var current = headObject;

        if (tailNames != '') {  // Split on empty string doesn't give empty list
            // Find the last already created object in tailNames
            var tailChain = tailNames.split ('.');
            var firstNewIndex = tailChain.length;
            for (var index = 0; index < tailChain.length; index++) {
                if (!current.hasOwnProperty (tailChain [index])) {
                    firstNewIndex = index;
                    break;
                }
                current = current [tailChain [index]];
            }

            // Create the rest of the objects, if any
            for (var index = firstNewIndex; index < tailChain.length; index++) {
                current [tailChain [index]] = {};
                current = current [tailChain [index]];
            }
        }

        // Insert it new attributes, it may have been created earlier and have other attributes
        for (var attrib in value) {
            current [attrib] = value [attrib];
        }
    };
    __all__.__nest__ = __nest__;

    // Initialize module if not yet done and return its globals
    var __init__ = function (module) {
        if (!module.__inited__) {
            module.__all__.__init__ (module.__all__);
            module.__inited__ = true;
        }
        return module.__all__;
    };
    __all__.__init__ = __init__;




    // Since we want to assign functions, a = b.f should make b.f produce a bound function
    // So __get__ should be called by a property rather then a function
    // Factory __get__ creates one of three curried functions for func
    // Which one is produced depends on what's to the left of the dot of the corresponding JavaScript property
    var __get__ = function (self, func, quotedFuncName) {
        if (self) {
            if (self.hasOwnProperty ('__class__') || typeof self == 'string' || self instanceof String) {           // Object before the dot
                if (quotedFuncName) {                                   // Memoize call since fcall is on, by installing bound function in instance
                    Object.defineProperty (self, quotedFuncName, {      // Will override the non-own property, next time it will be called directly
                        value: function () {                            // So next time just call curry function that calls function
                            var args = [] .slice.apply (arguments);
                            return func.apply (null, [self] .concat (args));
                        },
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                }
                return function () {                                    // Return bound function, code dupplication for efficiency if no memoizing
                    var args = [] .slice.apply (arguments);             // So multilayer search prototype, apply __get__, call curry func that calls func
                    return func.apply (null, [self] .concat (args));
                };
            }
            else {                                                      // Class before the dot
                return func;                                            // Return static method
            }
        }
        else {                                                          // Nothing before the dot
            return func;                                                // Return free function
        }
    }
    __all__.__get__ = __get__;

    // Mother of all metaclasses
    var py_metatype = {
        __name__: 'type',
        __bases__: [],

        // Overridable class creation worker
        __new__: function (meta, name, bases, attribs) {
            // Create the class cls, a functor, which the class creator function will return
            var cls = function () {                     // If cls is called with arg0, arg1, etc, it calls its __new__ method with [arg0, arg1, etc]
                var args = [] .slice.apply (arguments); // It has a __new__ method, not yet but at call time, since it is copied from the parent in the loop below
                return cls.__new__ (args);              // Each Python class directly or indirectly derives from object, which has the __new__ method
            };                                          // If there are no bases in the Python source, the compiler generates [object] for this parameter

            // Copy all methods, including __new__, properties and static attributes from base classes to new cls object
            // The new class object will simply be the prototype of its instances
            // JavaScript prototypical single inheritance will do here, since any object has only one class
            // This has nothing to do with Python multiple inheritance, that is implemented explictly in the copy loop below
            for (var index = bases.length - 1; index >= 0; index--) {   // Reversed order, since class vars of first base should win
                var base = bases [index];
                for (var attrib in base) {
                    var descrip = Object.getOwnPropertyDescriptor (base, attrib);
                    Object.defineProperty (cls, attrib, descrip);
                }
            }

            // Add class specific attributes to the created cls object
            cls.__metaclass__ = meta;
            cls.__name__ = name;
            cls.__bases__ = bases;

            // Add own methods, properties and own static attributes to the created cls object
            for (var attrib in attribs) {
                var descrip = Object.getOwnPropertyDescriptor (attribs, attrib);
                Object.defineProperty (cls, attrib, descrip);
            }
            // Return created cls object
            return cls;
        }
    };
    py_metatype.__metaclass__ = py_metatype;
    __all__.py_metatype = py_metatype;

    // Mother of all classes
    var object = {
        __init__: function (self) {},

        __metaclass__: py_metatype, // By default, all classes have metaclass type, since they derive from object
        __name__: 'object',
        __bases__: [],

        // Object creator function is inherited by all classes (so in principle it could be made global)
        __new__: function (args) {  // Args are just the constructor args
            // In JavaScript the Python class is the prototype of the Python object
            // In this way methods and static attributes will be available both with a class and an object before the dot
            // The descriptor produced by __get__ will return the right method flavor
            var instance = Object.create (this, {__class__: {value: this, enumerable: true}});


            // Call constructor
            this.__init__.apply (null, [instance] .concat (args));

            // Return constructed instance
            return instance;
        }
    };
    __all__.object = object;

    // Class creator facade function, calls class creation worker
    var __class__ = function (name, bases, attribs, meta) {         // Parameter meta is optional
        if (meta == undefined) {
            meta = bases [0] .__metaclass__;
        }

        return meta.__new__ (meta, name, bases, attribs);
    }
    __all__.__class__ = __class__;

    // Define __pragma__ to preserve '<all>' and '</all>', since it's never generated as a function, must be done early, so here
    var __pragma__ = function () {};
    __all__.__pragma__ = __pragma__;

        __nest__ (
        __all__,
        'org.transcrypt.__base__', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var __Envir__ = __class__ ('__Envir__', [object], {
                        get __init__ () {return __get__ (this, function (self) {
                            self.interpreter_name = 'python';
                            self.transpiler_name = 'transcrypt';
                            self.transpiler_version = '3.6.4';
                            self.target_subdir = '__javascript__';
                        });}
                    });
                    var __envir__ = __Envir__ ();
                    __pragma__ ('<all>')
                        __all__.__Envir__ = __Envir__;
                        __all__.__envir__ = __envir__;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'org.transcrypt.__standard__', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var Exception = __class__ ('Exception', [object], {
                        get __init__ () {return __get__ (this, function (self) {
                            var kwargs = {};
                            if (arguments.length) {
                                var __ilastarg0__ = arguments.length - 1;
                                if (arguments [__ilastarg0__] && arguments [__ilastarg0__].hasOwnProperty ("__kwargtrans__")) {
                                    var __allkwargs0__ = arguments [__ilastarg0__--];
                                    for (var __attrib0__ in __allkwargs0__) {
                                        switch (__attrib0__) {
                                            case 'self': var self = __allkwargs0__ [__attrib0__]; break;
                                            default: kwargs [__attrib0__] = __allkwargs0__ [__attrib0__];
                                        }
                                    }
                                    delete kwargs.__kwargtrans__;
                                }
                                var args = tuple ([].slice.apply (arguments).slice (1, __ilastarg0__ + 1));
                            }
                            else {
                                var args = tuple ();
                            }
                            self.__args__ = args;
                            if (kwargs.error != null) {
                                self.stack = kwargs.error.stack;
                            }
                            else {
                                self.stack = 'No stack trace available';
                            }
                        });},
                        get __repr__ () {return __get__ (this, function (self) {
                            if (len (self.__args__)) {
                                return '{}{}'.format (self.__class__.__name__, repr (tuple (self.__args__)));
                            }
                            else {
                                return '{}()'.format (self.__class__.__name__);
                            }
                        });},
                        get __str__ () {return __get__ (this, function (self) {
                            if (len (self.__args__) > 1) {
                                return str (tuple (self.__args__));
                            }
                            else if (len (self.__args__)) {
                                return str (self.__args__ [0]);
                            }
                            else {
                                return '';
                            }
                        });}
                    });
                    var IterableError = __class__ ('IterableError', [Exception], {
                        get __init__ () {return __get__ (this, function (self, error) {
                            Exception.__init__ (self, "Can't iterate over non-iterable", __kwargtrans__ ({error: error}));
                        });}
                    });
                    var StopIteration = __class__ ('StopIteration', [Exception], {
                        get __init__ () {return __get__ (this, function (self, error) {
                            Exception.__init__ (self, 'Iterator exhausted', __kwargtrans__ ({error: error}));
                        });}
                    });
                    var ValueError = __class__ ('ValueError', [Exception], {
                        get __init__ () {return __get__ (this, function (self, error) {
                            Exception.__init__ (self, 'Erroneous value', __kwargtrans__ ({error: error}));
                        });}
                    });
                    var KeyError = __class__ ('KeyError', [Exception], {
                        get __init__ () {return __get__ (this, function (self, error) {
                            Exception.__init__ (self, 'Invalid key', __kwargtrans__ ({error: error}));
                        });}
                    });
                    var AssertionError = __class__ ('AssertionError', [Exception], {
                        get __init__ () {return __get__ (this, function (self, message, error) {
                            if (message) {
                                Exception.__init__ (self, message, __kwargtrans__ ({error: error}));
                            }
                            else {
                                Exception.__init__ (self, __kwargtrans__ ({error: error}));
                            }
                        });}
                    });
                    var NotImplementedError = __class__ ('NotImplementedError', [Exception], {
                        get __init__ () {return __get__ (this, function (self, message, error) {
                            Exception.__init__ (self, message, __kwargtrans__ ({error: error}));
                        });}
                    });
                    var IndexError = __class__ ('IndexError', [Exception], {
                        get __init__ () {return __get__ (this, function (self, message, error) {
                            Exception.__init__ (self, message, __kwargtrans__ ({error: error}));
                        });}
                    });
                    var AttributeError = __class__ ('AttributeError', [Exception], {
                        get __init__ () {return __get__ (this, function (self, message, error) {
                            Exception.__init__ (self, message, __kwargtrans__ ({error: error}));
                        });}
                    });
                    var Warning = __class__ ('Warning', [Exception], {
                    });
                    var UserWarning = __class__ ('UserWarning', [Warning], {
                    });
                    var DeprecationWarning = __class__ ('DeprecationWarning', [Warning], {
                    });
                    var RuntimeWarning = __class__ ('RuntimeWarning', [Warning], {
                    });
                    var __sort__ = function (iterable, key, reverse) {
                        if (typeof key == 'undefined' || (key != null && key .hasOwnProperty ("__kwargtrans__"))) {;
                            var key = null;
                        };
                        if (typeof reverse == 'undefined' || (reverse != null && reverse .hasOwnProperty ("__kwargtrans__"))) {;
                            var reverse = false;
                        };
                        if (arguments.length) {
                            var __ilastarg0__ = arguments.length - 1;
                            if (arguments [__ilastarg0__] && arguments [__ilastarg0__].hasOwnProperty ("__kwargtrans__")) {
                                var __allkwargs0__ = arguments [__ilastarg0__--];
                                for (var __attrib0__ in __allkwargs0__) {
                                    switch (__attrib0__) {
                                        case 'iterable': var iterable = __allkwargs0__ [__attrib0__]; break;
                                        case 'key': var key = __allkwargs0__ [__attrib0__]; break;
                                        case 'reverse': var reverse = __allkwargs0__ [__attrib0__]; break;
                                    }
                                }
                            }
                        }
                        else {
                        }
                        if (key) {
                            iterable.sort ((function __lambda__ (a, b) {
                                if (arguments.length) {
                                    var __ilastarg0__ = arguments.length - 1;
                                    if (arguments [__ilastarg0__] && arguments [__ilastarg0__].hasOwnProperty ("__kwargtrans__")) {
                                        var __allkwargs0__ = arguments [__ilastarg0__--];
                                        for (var __attrib0__ in __allkwargs0__) {
                                            switch (__attrib0__) {
                                                case 'a': var a = __allkwargs0__ [__attrib0__]; break;
                                                case 'b': var b = __allkwargs0__ [__attrib0__]; break;
                                            }
                                        }
                                    }
                                }
                                else {
                                }
                                return (key (a) > key (b) ? 1 : -(1));
                            }));
                        }
                        else {
                            iterable.sort ();
                        }
                        if (reverse) {
                            iterable.reverse ();
                        }
                    };
                    var sorted = function (iterable, key, reverse) {
                        if (typeof key == 'undefined' || (key != null && key .hasOwnProperty ("__kwargtrans__"))) {;
                            var key = null;
                        };
                        if (typeof reverse == 'undefined' || (reverse != null && reverse .hasOwnProperty ("__kwargtrans__"))) {;
                            var reverse = false;
                        };
                        if (arguments.length) {
                            var __ilastarg0__ = arguments.length - 1;
                            if (arguments [__ilastarg0__] && arguments [__ilastarg0__].hasOwnProperty ("__kwargtrans__")) {
                                var __allkwargs0__ = arguments [__ilastarg0__--];
                                for (var __attrib0__ in __allkwargs0__) {
                                    switch (__attrib0__) {
                                        case 'iterable': var iterable = __allkwargs0__ [__attrib0__]; break;
                                        case 'key': var key = __allkwargs0__ [__attrib0__]; break;
                                        case 'reverse': var reverse = __allkwargs0__ [__attrib0__]; break;
                                    }
                                }
                            }
                        }
                        else {
                        }
                        if (py_typeof (iterable) == dict) {
                            var result = copy (iterable.py_keys ());
                        }
                        else {
                            var result = copy (iterable);
                        }
                        __sort__ (result, key, reverse);
                        return result;
                    };
                    var map = function (func, iterable) {
                        return function () {
                            var __accu0__ = [];
                            var __iterable0__ = iterable;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var item = __iterable0__ [__index0__];
                                __accu0__.append (func (item));
                            }
                            return __accu0__;
                        } ();
                    };
                    var filter = function (func, iterable) {
                        return function () {
                            var __accu0__ = [];
                            var __iterable0__ = iterable;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var item = __iterable0__ [__index0__];
                                if (func (item)) {
                                    __accu0__.append (item);
                                }
                            }
                            return __accu0__;
                        } ();
                    };
                    var __Terminal__ = __class__ ('__Terminal__', [object], {
                        get __init__ () {return __get__ (this, function (self) {
                            // pass;
                        });},
                        get print () {return __get__ (this, function (self) {
                            var sep = ' ';
                            var args = tuple ([].slice.apply (arguments).slice (1));
                            var length = len (args);
                            if (length < 1) {
                                console.log ();
                            }
                            else if (length == 1) {
                                console.log (args [0]);
                            }
                            else {
                                console.log (sep.join (function () {
                                    var __accu0__ = [];
                                    var __iterable0__ = args;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var arg = __iterable0__ [__index0__];
                                        __accu0__.append (str (arg));
                                    }
                                    return __accu0__;
                                } ()));
                            }
                        });}
                    });
                    var __terminal__ = __Terminal__ ();
                    __pragma__ ('<all>')
                        __all__.AssertionError = AssertionError;
                        __all__.AttributeError = AttributeError;
                        __all__.DeprecationWarning = DeprecationWarning;
                        __all__.Exception = Exception;
                        __all__.IndexError = IndexError;
                        __all__.IterableError = IterableError;
                        __all__.KeyError = KeyError;
                        __all__.NotImplementedError = NotImplementedError;
                        __all__.RuntimeWarning = RuntimeWarning;
                        __all__.StopIteration = StopIteration;
                        __all__.UserWarning = UserWarning;
                        __all__.ValueError = ValueError;
                        __all__.Warning = Warning;
                        __all__.__Terminal__ = __Terminal__;
                        __all__.__sort__ = __sort__;
                        __all__.__terminal__ = __terminal__;
                        __all__.filter = filter;
                        __all__.map = map;
                        __all__.sorted = sorted;
                    __pragma__ ('</all>')
                }
            }
        }
    );

    // Initialize non-nested modules __base__ and __standard__ and make its names available directly and via __all__
    // They can't do that itself, because they're regular Python modules
    // The compiler recognizes their names and generates them inline rather than nesting them
    // In this way it isn't needed to import them everywhere

    // __base__

    __nest__ (__all__, '', __init__ (__all__.org.transcrypt.__base__));
    var __envir__ = __all__.__envir__;

    // __standard__

    __nest__ (__all__, '', __init__ (__all__.org.transcrypt.__standard__));

    var Exception = __all__.Exception;
    var IterableError = __all__.IterableError;
    var StopIteration = __all__.StopIteration;
    var ValueError = __all__.ValueError;
    var KeyError = __all__.KeyError;
    var AssertionError = __all__.AssertionError;
    var NotImplementedError = __all__.NotImplementedError;
    var IndexError = __all__.IndexError;
    var AttributeError = __all__.AttributeError;

    // Warnings Exceptions
    var Warning = __all__.Warning;
    var UserWarning = __all__.UserWarning;
    var DeprecationWarning = __all__.DeprecationWarning;
    var RuntimeWarning = __all__.RuntimeWarning;

    var __sort__ = __all__.__sort__;
    var sorted = __all__.sorted;

    var map = __all__.map;
    var filter = __all__.filter;

    __all__.print = __all__.__terminal__.print;
    __all__.input = __all__.__terminal__.input;

    var __terminal__ = __all__.__terminal__;
    var print = __all__.print;
    var input = __all__.input;

    // Complete __envir__, that was created in __base__, for non-stub mode
    __envir__.executor_name = __envir__.transpiler_name;

    // Make make __main__ available in browser
    var __main__ = {__file__: ''};
    __all__.main = __main__;

    // Define current exception, there's at most one exception in the air at any time
    var __except__ = null;
    __all__.__except__ = __except__;

     // Creator of a marked dictionary, used to pass **kwargs parameter
    var __kwargtrans__ = function (anObject) {
        anObject.__kwargtrans__ = null; // Removable marker
        anObject.constructor = Object;
        return anObject;
    }
    __all__.__kwargtrans__ = __kwargtrans__;

    // 'Oneshot' dict promotor, used to enrich __all__ and help globals () return a true dict
    var __globals__ = function (anObject) {
        if (isinstance (anObject, dict)) {  // Don't attempt to promote (enrich) again, since it will make a copy
            return anObject;
        }
        else {
            return dict (anObject)
        }
    }
    __all__.__globals__ = __globals__

    // Python property installer function, no member since that would bloat classes
    var property = function (getter, setter) {  // Returns a property descriptor rather than a property
        if (!setter) {  // ??? Make setter optional instead of dummy?
            setter = function () {};
        }
        return {get: function () {return getter (this)}, set: function (value) {setter (this, value)}, enumerable: true};
    }
    __all__.property = property;

    // Conditional JavaScript property installer function, prevents redefinition of properties if multiple Transcrypt apps are on one page
    var __setProperty__ = function (anObject, name, descriptor) {
        if (!anObject.hasOwnProperty (name)) {
            Object.defineProperty (anObject, name, descriptor);
        }
    }
    __all__.__setProperty__ = __setProperty__

    // Assert function, call to it only generated when compiling with --dassert option
    function assert (condition, message) {  // Message may be undefined
        if (!condition) {
            throw AssertionError (message, new Error ());
        }
    }

    __all__.assert = assert;

    var __merge__ = function (object0, object1) {
        var result = {};
        for (var attrib in object0) {
            result [attrib] = object0 [attrib];
        }
        for (var attrib in object1) {
            result [attrib] = object1 [attrib];
        }
        return result;
    };
    __all__.__merge__ = __merge__;

    // Manipulating attributes by name

    var dir = function (obj) {
        var aList = [];
        for (var aKey in obj) {
            aList.push (aKey);
        }
        aList.sort ();
        return aList;
    };
    __all__.dir = dir;

    var setattr = function (obj, name, value) {
        obj [name] = value;
    };
    __all__.setattr = setattr;

    var getattr = function (obj, name) {
        return obj [name];
    };
    __all__.getattr= getattr;

    var hasattr = function (obj, name) {
        return name in obj;
    };
    __all__.hasattr = hasattr;

    var delattr = function (obj, name) {
        delete obj [name];
    };
    __all__.delattr = (delattr);

    // The __in__ function, used to mimic Python's 'in' operator
    // In addition to CPython's semantics, the 'in' operator is also allowed to work on objects, avoiding a counterintuitive separation between Python dicts and JavaScript objects
    // In general many Transcrypt compound types feature a deliberate blend of Python and JavaScript facilities, facilitating efficient integration with JavaScript libraries
    // If only Python objects and Python dicts are dealt with in a certain context, the more pythonic 'hasattr' is preferred for the objects as opposed to 'in' for the dicts
    var __in__ = function (element, container) {
        if (py_typeof (container) == dict) {        // Currently only implemented as an augmented JavaScript object
            return container.hasOwnProperty (element);
        }
        else {                                      // Parameter 'element' itself is an array, string or a plain, non-dict JavaScript object
            return (
                container.indexOf ?                 // If it has an indexOf
                container.indexOf (element) > -1 :  // it's an array or a string,
                container.hasOwnProperty (element)  // else it's a plain, non-dict JavaScript object
            );
        }
    };
    __all__.__in__ = __in__;

    // Find out if an attribute is special
    var __specialattrib__ = function (attrib) {
        return (attrib.startswith ('__') && attrib.endswith ('__')) || attrib == 'constructor' || attrib.startswith ('py_');
    };
    __all__.__specialattrib__ = __specialattrib__;

    // Len function for any object
    var len = function (anObject) {
        if (anObject) {
            var l = anObject.length;
            if (l == undefined) {
                var result = 0;
                for (var attrib in anObject) {
                    if (!__specialattrib__ (attrib)) {
                        result++;
                    }
                }
                return result;
            }
            else {
                return l;
            }
        }
        else {
            return 0;
        }
    };
    __all__.len = len;

    // General conversions

    function __i__ (any) {  //  Conversion to iterable
        return py_typeof (any) == dict ? any.py_keys () : any;
    }

    function __t__ (any) {  // Conversion to truthyness, __ ([1, 2, 3]) returns [1, 2, 3], needed for nonempty selection: l = list1 or list2]
        return (['boolean', 'number'] .indexOf (typeof any) >= 0 || any instanceof Function || len (any)) ? any : false;
        // JavaScript functions have a length attribute, denoting the number of parameters
        // Python objects are JavaScript functions, but their length doesn't matter, only their existence
        // By the term 'any instanceof Function' we make sure that Python objects aren't rejected when their length equals zero
    }
    __all__.__t__ = __t__;

    var bool = function (any) {     // Always truly returns a bool, rather than something truthy or falsy
        return !!__t__ (any);
    };
    bool.__name__ = 'bool';         // So it can be used as a type with a name
    __all__.bool = bool;

    var float = function (any) {
        if (any == 'inf') {
            return Infinity;
        }
        else if (any == '-inf') {
            return -Infinity;
        }
        else if (isNaN (any)) {
            throw ValueError (new Error ());
        }
        else {
            return +any;
        }
    };
    float.__name__ = 'float';
    __all__.float = float;

    var int = function (any, radix) {
        if (typeof any === 'number') {
            return Math.floor(any);
        }
        var number = parseInt(any, radix);
        if (isNaN (number)) {
            if (radix == undefined) {
                radix = 10;
            }
            throw ValueError('invalid literal for int() with base ' + radix + ': ' + any, new Error());
        }
        return number;
    };
    int.__name__ = 'int';
    __all__.int = int;

    var py_typeof = function (anObject) {
        var aType = typeof anObject;
        if (aType == 'object') {    // Directly trying '__class__ in anObject' turns out to wreck anObject in Chrome if its a primitive
            try {
                return anObject.__class__;
            }
            catch (exception) {
                return aType;
            }
        }
        else {
            return (    // Odly, the braces are required here
                aType == 'boolean' ? bool :
                aType == 'string' ? str :
                aType == 'number' ? (anObject % 1 == 0 ? int : float) :
                null
            );
        }
    };
    __all__.py_typeof = py_typeof;

    var isinstance = function (anObject, classinfo) {
        function isA (queryClass) {
            if (queryClass == classinfo) {
                return true;
            }
            for (var index = 0; index < queryClass.__bases__.length; index++) {
                if (isA (queryClass.__bases__ [index], classinfo)) {
                    return true;
                }
            }
            return false;
        }

        if (classinfo instanceof Array) {   // Assume in most cases it isn't, then making it recursive rather than two functions saves a call
            for (var index = 0; index < classinfo.length; index++) {
                var aClass = classinfo [index];
                if (isinstance (anObject, aClass)) {
                    return true;
                }
            }
            return false;
        }

        try {                   // Most frequent use case first
            return '__class__' in anObject ? isA (anObject.__class__) : anObject instanceof classinfo;
        }
        catch (exception) {     // Using isinstance on primitives assumed rare
            var aType = py_typeof (anObject);
            return aType == classinfo || (aType == bool && classinfo == int);
        }
    };
    __all__.isinstance = isinstance;

    var callable = function (anObject) {
        if ( typeof anObject == 'object' && '__call__' in anObject ) {
            return true;
        }
        else {
            return typeof anObject === 'function';
        }
    };
    __all__.callable = callable;

    // Repr function uses __repr__ method, then __str__, then toString
    var repr = function (anObject) {
        if (anObject.__repr__) {
            return anObject.__repr__ ();
        } else if (anObject.__str__) {
            return anObject.__str__ ();
        }
            else { // anObject has no __repr__ and no __str__
                try {
                    if (anObject == null) {
                        return 'None';
                    }
                    else if (anObject.constructor == Object) {
                        var result = '{';
                        var comma = false;
                        for (var attrib in anObject) {
                            if (!__specialattrib__ (attrib)) {
                                if (attrib.isnumeric ()) {
                                    var attribRepr = attrib;                // If key can be interpreted as numerical, we make it numerical
                                }                                           // So we accept that '1' is misrepresented as 1
                                else {
                                    var attribRepr = '\'' + attrib + '\'';  // Alpha key in dict
                                }

                                if (comma) {
                                    result += ', ';
                                }
                                else {
                                    comma = true;
                                }
                                result += attribRepr + ': ' + repr (anObject [attrib]);
                            }
                        }
                        result += '}';
                        return result;
                    }
                    else {
                        return typeof anObject == 'boolean' ? anObject.toString () .capitalize () : anObject.toString ();
                    }
                }
                catch (exception) {
                    console.log ('ERROR: Could not evaluate repr (<object of type ' + typeof anObject + '>)');
                    console.log (exception);
                    return '???';
                }
            }
    };
    __all__.repr = repr;

    // Char from Unicode or ASCII
    var chr = function (charCode) {
        return String.fromCharCode (charCode);
    };
    __all__.chr = chr;

    // Unicode or ASCII from char
    var ord = function (aChar) {
        return aChar.charCodeAt (0);
    };
    __all__.org = ord;

    // Maximum of n numbers
    var max = Math.max;
    __all__.max = max;

    // Minimum of n numbers
    var min = Math.min;
    __all__.min = min;

    // Absolute value
    var abs = Math.abs;
    __all__.abs = abs;

    // Bankers rounding
    var round = function (number, ndigits) {
        if (ndigits) {
            var scale = Math.pow (10, ndigits);
            number *= scale;
        }

        var rounded = Math.round (number);
        if (rounded - number == 0.5 && rounded % 2) {   // Has rounded up to odd, should have rounded down to even
            rounded -= 1;
        }

        if (ndigits) {
            rounded /= scale;
        }

        return rounded;
    };
    __all__.round = round;

    // BEGIN unified iterator model

    function __jsUsePyNext__ () {       // Add as 'next' method to make Python iterator JavaScript compatible
        try {
            var result = this.__next__ ();
            return {value: result, done: false};
        }
        catch (exception) {
            return {value: undefined, done: true};
        }
    }

    function __pyUseJsNext__ () {       // Add as '__next__' method to make JavaScript iterator Python compatible
        var result = this.next ();
        if (result.done) {
            throw StopIteration (new Error ());
        }
        else {
            return result.value;
        }
    }

    function py_iter (iterable) {                   // Alias for Python's iter function, produces a universal iterator / iterable, usable in Python and JavaScript
        if (typeof iterable == 'string' || '__iter__' in iterable) {    // JavaScript Array or string or Python iterable (string has no 'in')
            var result = iterable.__iter__ ();                          // Iterator has a __next__
            result.next = __jsUsePyNext__;                              // Give it a next
        }
        else if ('selector' in iterable) {                              // Assume it's a JQuery iterator
            var result = list (iterable) .__iter__ ();                  // Has a __next__
            result.next = __jsUsePyNext__;                              // Give it a next
        }
        else if ('next' in iterable) {                                  // It's a JavaScript iterator already,  maybe a generator, has a next and may have a __next__
            var result = iterable
            if (! ('__next__' in result)) {                             // If there's no danger of recursion
                result.__next__ = __pyUseJsNext__;                      // Give it a __next__
            }
        }
        else if (Symbol.iterator in iterable) {                         // It's a JavaScript iterable such as a typed array, but not an iterator
            var result = iterable [Symbol.iterator] ();                 // Has a next
            result.__next__ = __pyUseJsNext__;                          // Give it a __next__
        }
        else {
            throw IterableError (new Error ()); // No iterator at all
        }
        result [Symbol.iterator] = function () {return result;};
        return result;
    }

    function py_next (iterator) {               // Called only in a Python context, could receive Python or JavaScript iterator
        try {                                   // Primarily assume Python iterator, for max speed
            var result = iterator.__next__ ();
        }
        catch (exception) {                     // JavaScript iterators are the exception here
            var result = iterator.next ();
            if (result.done) {
                throw StopIteration (new Error ());
            }
            else {
                return result.value;
            }
        }
        if (result == undefined) {
            throw StopIteration (new Error ());
        }
        else {
            return result;
        }
    }

    function __PyIterator__ (iterable) {
        this.iterable = iterable;
        this.index = 0;
    }

    __PyIterator__.prototype.__next__ = function () {
        if (this.index < this.iterable.length) {
            return this.iterable [this.index++];
        }
        else {
            throw StopIteration (new Error ());
        }
    };

    function __JsIterator__ (iterable) {
        this.iterable = iterable;
        this.index = 0;
    }

    __JsIterator__.prototype.next = function () {
        if (this.index < this.iterable.py_keys.length) {
            return {value: this.index++, done: false};
        }
        else {
            return {value: undefined, done: true};
        }
    };

    // END unified iterator model

    // Reversed function for arrays
    var py_reversed = function (iterable) {
        iterable = iterable.slice ();
        iterable.reverse ();
        return iterable;
    };
    __all__.py_reversed = py_reversed;

    // Zip method for arrays
    var zip = function () {
        var args = [] .slice.call (arguments);
        var shortest = args.length == 0 ? [] : args.reduce (    // Find shortest array in arguments
            function (array0, array1) {
                return array0.length < array1.length ? array0 : array1;
            }
        );
        return shortest.map (                   // Map each element of shortest array
            function (current, index) {         // To the result of this function
                return args.map (               // Map each array in arguments
                    function (current) {        // To the result of this function
                        return current [index]; // Namely it's index't entry
                    }
                );
            }
        );
    };
    __all__.zip = zip;

    // Range method, returning an array
    function range (start, stop, step) {
        if (stop == undefined) {
            // one param defined
            stop = start;
            start = 0;
        }
        if (step == undefined) {
            step = 1;
        }
        if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {
            return [];
        }
        var result = [];
        for (var i = start; step > 0 ? i < stop : i > stop; i += step) {
            result.push(i);
        }
        return result;
    };
    __all__.range = range;

    // Any, all and sum

    function any (iterable) {
        for (var index = 0; index < iterable.length; index++) {
            if (bool (iterable [index])) {
                return true;
            }
        }
        return false;
    }
    function all (iterable) {
        for (var index = 0; index < iterable.length; index++) {
            if (! bool (iterable [index])) {
                return false;
            }
        }
        return true;
    }
    function sum (iterable) {
        var result = 0;
        for (var index = 0; index < iterable.length; index++) {
            result += iterable [index];
        }
        return result;
    }

    __all__.any = any;
    __all__.all = all;
    __all__.sum = sum;

    // Enumerate method, returning a zipped list
    function enumerate (iterable) {
        return zip (range (len (iterable)), iterable);
    }
    __all__.enumerate = enumerate;

    // Shallow and deepcopy

    function copy (anObject) {
        if (anObject == null || typeof anObject == "object") {
            return anObject;
        }
        else {
            var result = {};
            for (var attrib in obj) {
                if (anObject.hasOwnProperty (attrib)) {
                    result [attrib] = anObject [attrib];
                }
            }
            return result;
        }
    }
    __all__.copy = copy;

    function deepcopy (anObject) {
        if (anObject == null || typeof anObject == "object") {
            return anObject;
        }
        else {
            var result = {};
            for (var attrib in obj) {
                if (anObject.hasOwnProperty (attrib)) {
                    result [attrib] = deepcopy (anObject [attrib]);
                }
            }
            return result;
        }
    }
    __all__.deepcopy = deepcopy;

    // List extensions to Array

    function list (iterable) {                                      // All such creators should be callable without new
        var instance = iterable ? Array.from (iterable) : [];
        // Sort is the normal JavaScript sort, Python sort is a non-member function
        return instance;
    }
    __all__.list = list;
    Array.prototype.__class__ = list;   // All arrays are lists (not only if constructed by the list ctor), unless constructed otherwise
    list.__name__ = 'list';

    /*
    Array.from = function (iterator) { // !!! remove
        result = [];
        for (item of iterator) {
            result.push (item);
        }
        return result;
    }
    */

    Array.prototype.__iter__ = function () {return new __PyIterator__ (this);};

    Array.prototype.__getslice__ = function (start, stop, step) {
        if (start < 0) {
            start = this.length + start;
        }

        if (stop == null) {
            stop = this.length;
        }
        else if (stop < 0) {
            stop = this.length + stop;
        }
        else if (stop > this.length) {
            stop = this.length;
        }

        if (step == 1) {
            return Array.prototype.slice.apply(this, [start, stop])
        }

        var result = list ([]);
        for (var index = start; index < stop; index += step) {
            result.push (this [index]);
        }

        return result;
    };

    Array.prototype.__setslice__ = function (start, stop, step, source) {
        if (start < 0) {
            start = this.length + start;
        }

        if (stop == null) {
            stop = this.length;
        }
        else if (stop < 0) {
            stop = this.length + stop;
        }

        if (step == null) { // Assign to 'ordinary' slice, replace subsequence
            Array.prototype.splice.apply (this, [start, stop - start] .concat (source));
        }
        else {              // Assign to extended slice, replace designated items one by one
            var sourceIndex = 0;
            for (var targetIndex = start; targetIndex < stop; targetIndex += step) {
                this [targetIndex] = source [sourceIndex++];
            }
        }
    };

    Array.prototype.__repr__ = function () {
        if (this.__class__ == set && !this.length) {
            return 'set()';
        }

        var result = !this.__class__ || this.__class__ == list ? '[' : this.__class__ == tuple ? '(' : '{';

        for (var index = 0; index < this.length; index++) {
            if (index) {
                result += ', ';
            }
            result += repr (this [index]);
        }

        if (this.__class__ == tuple && this.length == 1) {
            result += ',';
        }

        result += !this.__class__ || this.__class__ == list ? ']' : this.__class__ == tuple ? ')' : '}';;
        return result;
    };

    Array.prototype.__str__ = Array.prototype.__repr__;

    Array.prototype.append = function (element) {
        this.push (element);
    };

    Array.prototype.clear = function () {
        this.length = 0;
    };

    Array.prototype.extend = function (aList) {
        this.push.apply (this, aList);
    };

    Array.prototype.insert = function (index, element) {
        this.splice (index, 0, element);
    };

    Array.prototype.remove = function (element) {
        var index = this.indexOf (element);
        if (index == -1) {
            throw KeyError (new Error ());
        }
        this.splice (index, 1);
    };

    Array.prototype.index = function (element) {
        return this.indexOf (element);
    };

    Array.prototype.py_pop = function (index) {
        if (index == undefined) {
            return this.pop ();  // Remove last element
        }
        else {
            return this.splice (index, 1) [0];
        }
    };

    Array.prototype.py_sort = function () {
        __sort__.apply  (null, [this].concat ([] .slice.apply (arguments)));    // Can't work directly with arguments
        // Python params: (iterable, key = None, reverse = False)
        // py_sort is called with the Transcrypt kwargs mechanism, and just passes the params on to __sort__
        // __sort__ is def'ed with the Transcrypt kwargs mechanism
    };

    Array.prototype.__add__ = function (aList) {
        return list (this.concat (aList));
    };

    Array.prototype.__mul__ = function (scalar) {
        var result = this;
        for (var i = 1; i < scalar; i++) {
            result = result.concat (this);
        }
        return result;
    };

    Array.prototype.__rmul__ = Array.prototype.__mul__;

    // Tuple extensions to Array

    function tuple (iterable) {
        var instance = iterable ? [] .slice.apply (iterable) : [];
        instance.__class__ = tuple; // Not all arrays are tuples
        return instance;
    }
    __all__.tuple = tuple;
    tuple.__name__ = 'tuple';

    // Set extensions to Array
    // N.B. Since sets are unordered, set operations will occasionally alter the 'this' array by sorting it

    function set (iterable) {
        var instance = [];
        if (iterable) {
            for (var index = 0; index < iterable.length; index++) {
                instance.add (iterable [index]);
            }


        }
        instance.__class__ = set;   // Not all arrays are sets
        return instance;
    }
    __all__.set = set;
    set.__name__ = 'set';

    Array.prototype.__bindexOf__ = function (element) { // Used to turn O (n^2) into O (n log n)
    // Since sorting is lex, compare has to be lex. This also allows for mixed lists

        element += '';

        var mindex = 0;
        var maxdex = this.length - 1;

        while (mindex <= maxdex) {
            var index = (mindex + maxdex) / 2 | 0;
            var middle = this [index] + '';

            if (middle < element) {
                mindex = index + 1;
            }
            else if (middle > element) {
                maxdex = index - 1;
            }
            else {
                return index;
            }
        }

        return -1;
    };

    Array.prototype.add = function (element) {
        if (this.indexOf (element) == -1) { // Avoid duplicates in set
            this.push (element);
        }
    };

    Array.prototype.discard = function (element) {
        var index = this.indexOf (element);
        if (index != -1) {
            this.splice (index, 1);
        }
    };

    Array.prototype.isdisjoint = function (other) {
        this.sort ();
        for (var i = 0; i < other.length; i++) {
            if (this.__bindexOf__ (other [i]) != -1) {
                return false;
            }
        }
        return true;
    };

    Array.prototype.issuperset = function (other) {
        this.sort ();
        for (var i = 0; i < other.length; i++) {
            if (this.__bindexOf__ (other [i]) == -1) {
                return false;
            }
        }
        return true;
    };

    Array.prototype.issubset = function (other) {
        return set (other.slice ()) .issuperset (this); // Sort copy of 'other', not 'other' itself, since it may be an ordered sequence
    };

    Array.prototype.union = function (other) {
        var result = set (this.slice () .sort ());
        for (var i = 0; i < other.length; i++) {
            if (result.__bindexOf__ (other [i]) == -1) {
                result.push (other [i]);
            }
        }
        return result;
    };

    Array.prototype.intersection = function (other) {
        this.sort ();
        var result = set ();
        for (var i = 0; i < other.length; i++) {
            if (this.__bindexOf__ (other [i]) != -1) {
                result.push (other [i]);
            }
        }
        return result;
    };

    Array.prototype.difference = function (other) {
        var sother = set (other.slice () .sort ());
        var result = set ();
        for (var i = 0; i < this.length; i++) {
            if (sother.__bindexOf__ (this [i]) == -1) {
                result.push (this [i]);
            }
        }
        return result;
    };

    Array.prototype.symmetric_difference = function (other) {
        return this.union (other) .difference (this.intersection (other));
    };

    Array.prototype.py_update = function () {   // O (n)
        var updated = [] .concat.apply (this.slice (), arguments) .sort ();
        this.clear ();
        for (var i = 0; i < updated.length; i++) {
            if (updated [i] != updated [i - 1]) {
                this.push (updated [i]);
            }
        }
    };

    Array.prototype.__eq__ = function (other) { // Also used for list
        if (this.length != other.length) {
            return false;
        }
        if (this.__class__ == set) {
            this.sort ();
            other.sort ();
        }
        for (var i = 0; i < this.length; i++) {
            if (this [i] != other [i]) {
                return false;
            }
        }
        return true;
    };

    Array.prototype.__ne__ = function (other) { // Also used for list
        return !this.__eq__ (other);
    };

    Array.prototype.__le__ = function (other) {
        return this.issubset (other);
    };

    Array.prototype.__ge__ = function (other) {
        return this.issuperset (other);
    };

    Array.prototype.__lt__ = function (other) {
        return this.issubset (other) && !this.issuperset (other);
    };

    Array.prototype.__gt__ = function (other) {
        return this.issuperset (other) && !this.issubset (other);
    };

    // String extensions

    function str (stringable) {
        try {
            return stringable.__str__ ();
        }
        catch (exception) {
            try {
                return repr (stringable);
            }
            catch (exception) {
                return String (stringable); // No new, so no permanent String object but a primitive in a temporary 'just in time' wrapper
            }
        }
    };
    __all__.str = str;

    String.prototype.__class__ = str;   // All strings are str
    str.__name__ = 'str';

    String.prototype.__iter__ = function () {new __PyIterator__ (this);};

    String.prototype.__repr__ = function () {
        return (this.indexOf ('\'') == -1 ? '\'' + this + '\'' : '"' + this + '"') .py_replace ('\t', '\\t') .py_replace ('\n', '\\n');
    };

    String.prototype.__str__ = function () {
        return this;
    };

    String.prototype.capitalize = function () {
        return this.charAt (0).toUpperCase () + this.slice (1);
    };

    String.prototype.endswith = function (suffix) {
        return suffix == '' || this.slice (-suffix.length) == suffix;
    };

    String.prototype.find  = function (sub, start) {
        return this.indexOf (sub, start);
    };

    String.prototype.__getslice__ = function (start, stop, step) {
        if (start < 0) {
            start = this.length + start;
        }

        if (stop == null) {
            stop = this.length;
        }
        else if (stop < 0) {
            stop = this.length + stop;
        }

        var result = '';
        if (step == 1) {
            result = this.substring (start, stop);
        }
        else {
            for (var index = start; index < stop; index += step) {
                result = result.concat (this.charAt(index));
            }
        }
        return result;
    }

    // Since it's worthwhile for the 'format' function to be able to deal with *args, it is defined as a property
    // __get__ will produce a bound function if there's something before the dot
    // Since a call using *args is compiled to e.g. <object>.<function>.apply (null, args), the function has to be bound already
    // Otherwise it will never be, because of the null argument
    // Using 'this' rather than 'null' contradicts the requirement to be able to pass bound functions around
    // The object 'before the dot' won't be available at call time in that case, unless implicitly via the function bound to it
    // While for Python methods this mechanism is generated by the compiler, for JavaScript methods it has to be provided manually
    // Call memoizing is unattractive here, since every string would then have to hold a reference to a bound format method
    __setProperty__ (String.prototype, 'format', {
        get: function () {return __get__ (this, function (self) {
            var args = tuple ([] .slice.apply (arguments).slice (1));
            var autoIndex = 0;
            return self.replace (/\{(\w*)\}/g, function (match, key) {
                if (key == '') {
                    key = autoIndex++;
                }
                if (key == +key) {  // So key is numerical
                    return args [key] == undefined ? match : str (args [key]);
                }
                else {              // Key is a string
                    for (var index = 0; index < args.length; index++) {
                        // Find first 'dict' that has that key and the right field
                        if (typeof args [index] == 'object' && args [index][key] != undefined) {
                            return str (args [index][key]); // Return that field field
                        }
                    }
                    return match;
                }
            });
        });},
        enumerable: true
    });

    String.prototype.isnumeric = function () {
        return !isNaN (parseFloat (this)) && isFinite (this);
    };

    String.prototype.join = function (strings) {
        return strings.join (this);
    };

    String.prototype.lower = function () {
        return this.toLowerCase ();
    };

    String.prototype.py_replace = function (old, aNew, maxreplace) {
        return this.split (old, maxreplace) .join (aNew);
    };

    String.prototype.lstrip = function () {
        return this.replace (/^\s*/g, '');
    };

    String.prototype.rfind = function (sub, start) {
        return this.lastIndexOf (sub, start);
    };

    String.prototype.rsplit = function (sep, maxsplit) {    // Combination of general whitespace sep and positive maxsplit neither supported nor checked, expensive and rare
        if (sep == undefined || sep == null) {
            sep = /\s+/;
            var stripped = this.strip ();
        }
        else {
            var stripped = this;
        }

        if (maxsplit == undefined || maxsplit == -1) {
            return stripped.split (sep);
        }
        else {
            var result = stripped.split (sep);
            if (maxsplit < result.length) {
                var maxrsplit = result.length - maxsplit;
                return [result.slice (0, maxrsplit) .join (sep)] .concat (result.slice (maxrsplit));
            }
            else {
                return result;
            }
        }
    };

    String.prototype.rstrip = function () {
        return this.replace (/\s*$/g, '');
    };

    String.prototype.py_split = function (sep, maxsplit) {  // Combination of general whitespace sep and positive maxsplit neither supported nor checked, expensive and rare
        if (sep == undefined || sep == null) {
            sep = /\s+/;
            var stripped = this.strip ();
        }
        else {
            var stripped = this;
        }

        if (maxsplit == undefined || maxsplit == -1) {
            return stripped.split (sep);
        }
        else {
            var result = stripped.split (sep);
            if (maxsplit < result.length) {
                return result.slice (0, maxsplit).concat ([result.slice (maxsplit).join (sep)]);
            }
            else {
                return result;
            }
        }
    };

    String.prototype.startswith = function (prefix) {
        return this.indexOf (prefix) == 0;
    };

    String.prototype.strip = function () {
        return this.trim ();
    };

    String.prototype.upper = function () {
        return this.toUpperCase ();
    };

    String.prototype.__mul__ = function (scalar) {
        var result = this;
        for (var i = 1; i < scalar; i++) {
            result = result + this;
        }
        return result;
    };

    String.prototype.__rmul__ = String.prototype.__mul__;

    // Dict extensions to object

    function __keys__ () {
        var keys = [];
        for (var attrib in this) {
            if (!__specialattrib__ (attrib)) {
                keys.push (attrib);
            }
        }
        return keys;
    }

    function __items__ () {
        var items = [];
        for (var attrib in this) {
            if (!__specialattrib__ (attrib)) {
                items.push ([attrib, this [attrib]]);
            }
        }
        return items;
    }

    function __del__ (key) {
        delete this [key];
    }

    function __clear__ () {
        for (var attrib in this) {
            delete this [attrib];
        }
    }

    function __getdefault__ (aKey, aDefault) {  // Each Python object already has a function called __get__, so we call this one __getdefault__
        var result = this [aKey];
        return result == undefined ? (aDefault == undefined ? null : aDefault) : result;
    }

    function __setdefault__ (aKey, aDefault) {
        var result = this [aKey];
        if (result != undefined) {
            return result;
        }
        var val = aDefault == undefined ? null : aDefault;
        this [aKey] = val;
        return val;
    }

    function __pop__ (aKey, aDefault) {
        var result = this [aKey];
        if (result != undefined) {
            delete this [aKey];
            return result;
        } else {
            // Identify check because user could pass None
            if ( aDefault === undefined ) {
                throw KeyError(aKey, new Error());
            }
        }
        return aDefault;
    }

    function __update__ (aDict) {
        for (var aKey in aDict) {
            this [aKey] = aDict [aKey];
        }
    }

    function dict (objectOrPairs) {
        var instance = {};
        if (!objectOrPairs || objectOrPairs instanceof Array) { // It's undefined or an array of pairs
            if (objectOrPairs) {
                for (var index = 0; index < objectOrPairs.length; index++) {
                    var pair = objectOrPairs [index];
                    if ( !(pair instanceof Array) || pair.length != 2) {
                        throw ValueError(
                            "dict update sequence element #" + index +
                            " has length " + pair.length +
                            "; 2 is required", new Error());
                    }
                    var key = pair [0];
                    var val = pair [1];
                    if (!(objectOrPairs instanceof Array) && objectOrPairs instanceof Object) {
                         // User can potentially pass in an object
                         // that has a hierarchy of objects. This
                         // checks to make sure that these objects
                         // get converted to dict objects instead of
                         // leaving them as js objects.

                         if (!isinstance (objectOrPairs, dict)) {
                             val = dict (val);
                         }
                    }
                    instance [key] = val;
                }
            }
        }
        else {
            if (isinstance (objectOrPairs, dict)) {
                // Passed object is a dict already so we need to be a little careful
                // N.B. - this is a shallow copy per python std - so
                // it is assumed that children have already become
                // python objects at some point.

                var aKeys = objectOrPairs.py_keys ();
                for (var index = 0; index < aKeys.length; index++ ) {
                    var key = aKeys [index];
                    instance [key] = objectOrPairs [key];
                }
            } else if (objectOrPairs instanceof Object) {
                // Passed object is a JavaScript object but not yet a dict, don't copy it
                instance = objectOrPairs;
            } else {
                // We have already covered Array so this indicates
                // that the passed object is not a js object - i.e.
                // it is an int or a string, which is invalid.

                throw ValueError ("Invalid type of object for dict creation", new Error ());
            }
        }

        // Trancrypt interprets e.g. {aKey: 'aValue'} as a Python dict literal rather than a JavaScript object literal
        // So dict literals rather than bare Object literals will be passed to JavaScript libraries
        // Some JavaScript libraries call all enumerable callable properties of an object that's passed to them
        // So the properties of a dict should be non-enumerable
        __setProperty__ (instance, '__class__', {value: dict, enumerable: false, writable: true});
        __setProperty__ (instance, 'py_keys', {value: __keys__, enumerable: false});
        __setProperty__ (instance, '__iter__', {value: function () {new __PyIterator__ (this.py_keys ());}, enumerable: false});
        __setProperty__ (instance, Symbol.iterator, {value: function () {new __JsIterator__ (this.py_keys ());}, enumerable: false});
        __setProperty__ (instance, 'py_items', {value: __items__, enumerable: false});
        __setProperty__ (instance, 'py_del', {value: __del__, enumerable: false});
        __setProperty__ (instance, 'py_clear', {value: __clear__, enumerable: false});
        __setProperty__ (instance, 'py_get', {value: __getdefault__, enumerable: false});
        __setProperty__ (instance, 'py_setdefault', {value: __setdefault__, enumerable: false});
        __setProperty__ (instance, 'py_pop', {value: __pop__, enumerable: false});
        __setProperty__ (instance, 'py_update', {value: __update__, enumerable: false});
        return instance;
    }

    __all__.dict = dict;
    dict.__name__ = 'dict';

    // Docstring setter

    function __setdoc__ (docString) {
        this.__doc__ = docString;
        return this;
    }

    // Python classes, methods and functions are all translated to JavaScript functions
    __setProperty__ (Function.prototype, '__setdoc__', {value: __setdoc__, enumerable: false});

    // General operator overloading, only the ones that make most sense in matrix and complex operations

    var __neg__ = function (a) {
        if (typeof a == 'object' && '__neg__' in a) {
            return a.__neg__ ();
        }
        else {
            return -a;
        }
    };
    __all__.__neg__ = __neg__;

    var __matmul__ = function (a, b) {
        return a.__matmul__ (b);
    };
    __all__.__matmul__ = __matmul__;

    var __pow__ = function (a, b) {
        if (typeof a == 'object' && '__pow__' in a) {
            return a.__pow__ (b);
        }
        else if (typeof b == 'object' && '__rpow__' in b) {
            return b.__rpow__ (a);
        }
        else {
            return Math.pow (a, b);
        }
    };
    __all__.pow = __pow__;

    var __jsmod__ = function (a, b) {
        if (typeof a == 'object' && '__mod__' in a) {
            return a.__mod__ (b);
        }
        else if (typeof b == 'object' && '__rpow__' in b) {
            return b.__rmod__ (a);
        }
        else {
            return a % b;
        }
    };

    var __mod__ = function (a, b) {
        if (typeof a == 'object' && '__mod__' in a) {
            return a.__mod__ (b);
        }
        else if (typeof b == 'object' && '__rpow__' in b) {
            return b.__rmod__ (a);
        }
        else {
            return ((a % b) + b) % b;
        }
    };
    __all__.pow = __pow__;

    // Overloaded binary arithmetic

    var __mul__ = function (a, b) {
        if (typeof a == 'object' && '__mul__' in a) {
            return a.__mul__ (b);
        }
        else if (typeof b == 'object' && '__rmul__' in b) {
            return b.__rmul__ (a);
        }
        else if (typeof a == 'string') {
            return a.__mul__ (b);
        }
        else if (typeof b == 'string') {
            return b.__rmul__ (a);
        }
        else {
            return a * b;
        }
    };
    __all__.__mul__ = __mul__;

    var __div__ = function (a, b) {
        if (typeof a == 'object' && '__div__' in a) {
            return a.__div__ (b);
        }
        else if (typeof b == 'object' && '__rdiv__' in b) {
            return b.__rdiv__ (a);
        }
        else {
            return a / b;
        }
    };
    __all__.__div__ = __div__;

    var __add__ = function (a, b) {
        if (typeof a == 'object' && '__add__' in a) {
            return a.__add__ (b);
        }
        else if (typeof b == 'object' && '__radd__' in b) {
            return b.__radd__ (a);
        }
        else {
            return a + b;
        }
    };
    __all__.__add__ = __add__;

    var __sub__ = function (a, b) {
        if (typeof a == 'object' && '__sub__' in a) {
            return a.__sub__ (b);
        }
        else if (typeof b == 'object' && '__rsub__' in b) {
            return b.__rsub__ (a);
        }
        else {
            return a - b;
        }
    };
    __all__.__sub__ = __sub__;

    // Overloaded binary bitwise

    var __lshift__ = function (a, b) {
        if (typeof a == 'object' && '__lshift__' in a) {
            return a.__lshift__ (b);
        }
        else if (typeof b == 'object' && '__rlshift__' in b) {
            return b.__rlshift__ (a);
        }
        else {
            return a << b;
        }
    };
    __all__.__lshift__ = __lshift__;

    var __rshift__ = function (a, b) {
        if (typeof a == 'object' && '__rshift__' in a) {
            return a.__rshift__ (b);
        }
        else if (typeof b == 'object' && '__rrshift__' in b) {
            return b.__rrshift__ (a);
        }
        else {
            return a >> b;
        }
    };
    __all__.__rshift__ = __rshift__;

    var __or__ = function (a, b) {
        if (typeof a == 'object' && '__or__' in a) {
            return a.__or__ (b);
        }
        else if (typeof b == 'object' && '__ror__' in b) {
            return b.__ror__ (a);
        }
        else {
            return a | b;
        }
    };
    __all__.__or__ = __or__;

    var __xor__ = function (a, b) {
        if (typeof a == 'object' && '__xor__' in a) {
            return a.__xor__ (b);
        }
        else if (typeof b == 'object' && '__rxor__' in b) {
            return b.__rxor__ (a);
        }
        else {
            return a ^ b;
        }
    };
    __all__.__xor__ = __xor__;

    var __and__ = function (a, b) {
        if (typeof a == 'object' && '__and__' in a) {
            return a.__and__ (b);
        }
        else if (typeof b == 'object' && '__rand__' in b) {
            return b.__rand__ (a);
        }
        else {
            return a & b;
        }
    };
    __all__.__and__ = __and__;

    // Overloaded binary compare

    var __eq__ = function (a, b) {
        if (typeof a == 'object' && '__eq__' in a) {
            return a.__eq__ (b);
        }
        else {
            return a == b;
        }
    };
    __all__.__eq__ = __eq__;

    var __ne__ = function (a, b) {
        if (typeof a == 'object' && '__ne__' in a) {
            return a.__ne__ (b);
        }
        else {
            return a != b
        }
    };
    __all__.__ne__ = __ne__;

    var __lt__ = function (a, b) {
        if (typeof a == 'object' && '__lt__' in a) {
            return a.__lt__ (b);
        }
        else {
            return a < b;
        }
    };
    __all__.__lt__ = __lt__;

    var __le__ = function (a, b) {
        if (typeof a == 'object' && '__le__' in a) {
            return a.__le__ (b);
        }
        else {
            return a <= b;
        }
    };
    __all__.__le__ = __le__;

    var __gt__ = function (a, b) {
        if (typeof a == 'object' && '__gt__' in a) {
            return a.__gt__ (b);
        }
        else {
            return a > b;
        }
    };
    __all__.__gt__ = __gt__;

    var __ge__ = function (a, b) {
        if (typeof a == 'object' && '__ge__' in a) {
            return a.__ge__ (b);
        }
        else {
            return a >= b;
        }
    };
    __all__.__ge__ = __ge__;

    var __getitem__ = function (container, key) {                           // Slice c.q. index, direct generated call to runtime switch
        if (typeof container == 'object' && '__getitem__' in container) {
            return container.__getitem__ (key);                             // Overloaded on container
        }
        else {
            return container [key];                                         // Container must support bare JavaScript brackets
        }
    };
    __all__.__getitem__ = __getitem__;

    var __setitem__ = function (container, key, value) {                    // Slice c.q. index, direct generated call to runtime switch
        if (typeof container == 'object' && '__setitem__' in container) {
            container.__setitem__ (key, value);                             // Overloaded on container
        }
        else {
            container [key] = value;                                        // Container must support bare JavaScript brackets
        }
    };
    __all__.__setitem__ = __setitem__;

    var __getslice__ = function (container, lower, upper, step) {           // Slice only, no index, direct generated call to runtime switch
        if (typeof container == 'object' && '__getitem__' in container) {
            return container.__getitem__ ([lower, upper, step]);            // Container supports overloaded slicing c.q. indexing
        }
        else {
            return container.__getslice__ (lower, upper, step);             // Container only supports slicing injected natively in prototype
        }
    };
    __all__.__getslice__ = __getslice__;

    var __setslice__ = function (container, lower, upper, step, value) {    // Slice, no index, direct generated call to runtime switch
        if (typeof container == 'object' && '__setitem__' in container) {
            container.__setitem__ ([lower, upper, step], value);            // Container supports overloaded slicing c.q. indexing
        }
        else {
            container.__setslice__ (lower, upper, step, value);             // Container only supports slicing injected natively in prototype
        }
    };
    __all__.__setslice__ = __setslice__;

    var __call__ = function (/* <callee>, <this>, <params>* */) {
        var args = [] .slice.apply (arguments);
        if (typeof args [0] == 'object' && '__call__' in args [0]) {        // Overloaded
            return args [0] .__call__ .apply (args [1], args.slice (2));
        }
        else {                                                              // Native
            return args [0] .apply (args [1], args.slice (2));
        }
    };
    __all__.__call__ = __call__;
    __nest__ (
        __all__,
        'cache.consistency', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var global_cache = __init__ (__world__.cache.global_cache);
                    var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
                    var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
                    var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
                    var PYFIND_BUILDABLE_ROADS = __init__ (__world__.constants).PYFIND_BUILDABLE_ROADS;
                    var PYFIND_HURT_CREEPS = __init__ (__world__.constants).PYFIND_HURT_CREEPS;
                    var PYFIND_REPAIRABLE_ROADS = __init__ (__world__.constants).PYFIND_REPAIRABLE_ROADS;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var REROUTE = __init__ (__world__.constants).REROUTE;
                    var REROUTE_DESTINATION = __init__ (__world__.constants).REROUTE_DESTINATION;
                    var RESERVE_NOW = __init__ (__world__.constants).RESERVE_NOW;
                    var SCOUT = __init__ (__world__.constants).SCOUT;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var SK_USERNAME = __init__ (__world__.constants).SK_USERNAME;
                    var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
                    var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
                    var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
                    var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
                    var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var creep_base_1500miner = __init__ (__world__.constants).creep_base_1500miner;
                    var creep_base_3000miner = __init__ (__world__.constants).creep_base_3000miner;
                    var creep_base_3h = __init__ (__world__.constants).creep_base_3h;
                    var creep_base_4000miner = __init__ (__world__.constants).creep_base_4000miner;
                    var creep_base_carry3000miner = __init__ (__world__.constants).creep_base_carry3000miner;
                    var creep_base_claim_attack = __init__ (__world__.constants).creep_base_claim_attack;
                    var creep_base_claiming = __init__ (__world__.constants).creep_base_claiming;
                    var creep_base_defender = __init__ (__world__.constants).creep_base_defender;
                    var creep_base_dismantler = __init__ (__world__.constants).creep_base_dismantler;
                    var creep_base_full_move_dismantler = __init__ (__world__.constants).creep_base_full_move_dismantler;
                    var creep_base_full_move_goader = __init__ (__world__.constants).creep_base_full_move_goader;
                    var creep_base_full_move_healer = __init__ (__world__.constants).creep_base_full_move_healer;
                    var creep_base_full_move_power_attack = __init__ (__world__.constants).creep_base_full_move_power_attack;
                    var creep_base_full_upgrader = __init__ (__world__.constants).creep_base_full_upgrader;
                    var creep_base_goader = __init__ (__world__.constants).creep_base_goader;
                    var creep_base_half_move_hauler = __init__ (__world__.constants).creep_base_half_move_hauler;
                    var creep_base_half_move_healer = __init__ (__world__.constants).creep_base_half_move_healer;
                    var creep_base_hauler = __init__ (__world__.constants).creep_base_hauler;
                    var creep_base_mammoth_miner = __init__ (__world__.constants).creep_base_mammoth_miner;
                    var creep_base_power_attack = __init__ (__world__.constants).creep_base_power_attack;
                    var creep_base_rampart_defense = __init__ (__world__.constants).creep_base_rampart_defense;
                    var creep_base_ranged_offense = __init__ (__world__.constants).creep_base_ranged_offense;
                    var creep_base_reserving = __init__ (__world__.constants).creep_base_reserving;
                    var creep_base_scout = __init__ (__world__.constants).creep_base_scout;
                    var creep_base_work_full_move_hauler = __init__ (__world__.constants).creep_base_work_full_move_hauler;
                    var creep_base_work_half_move_hauler = __init__ (__world__.constants).creep_base_work_half_move_hauler;
                    var creep_base_worker = __init__ (__world__.constants).creep_base_worker;
                    var default_roles = __init__ (__world__.constants).default_roles;
                    var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
                    var gmem_key_last_room_state_refresh = __init__ (__world__.constants).gmem_key_last_room_state_refresh;
                    var gmem_key_room_mining_paths = __init__ (__world__.constants).gmem_key_room_mining_paths;
                    var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
                    var max_repave_mine_roads_every = __init__ (__world__.constants).max_repave_mine_roads_every;
                    var min_repath_mine_roads_every = __init__ (__world__.constants).min_repath_mine_roads_every;
                    var min_repave_mine_roads_every = __init__ (__world__.constants).min_repave_mine_roads_every;
                    var old_role_names = __init__ (__world__.constants).old_role_names;
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var request_priority_economy = __init__ (__world__.constants).request_priority_economy;
                    var request_priority_helping_party = __init__ (__world__.constants).request_priority_helping_party;
                    var request_priority_imminent_threat_defense = __init__ (__world__.constants).request_priority_imminent_threat_defense;
                    var request_priority_low = __init__ (__world__.constants).request_priority_low;
                    var rmem_key_building_paused = __init__ (__world__.constants).rmem_key_building_paused;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
                    var rmem_key_cache = __init__ (__world__.constants).rmem_key_cache;
                    var rmem_key_carry_parts_by_role = __init__ (__world__.constants).rmem_key_carry_parts_by_role;
                    var rmem_key_creeps_by_role = __init__ (__world__.constants).rmem_key_creeps_by_role;
                    var rmem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants).rmem_key_creeps_by_role_and_replacement_time;
                    var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
                    var rmem_key_defense_mind_storage = __init__ (__world__.constants).rmem_key_defense_mind_storage;
                    var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants).rmem_key_empty_all_resources_into_room;
                    var rmem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants).rmem_key_flag_for_testing_spawning_in_simulation;
                    var rmem_key_focusing_home = __init__ (__world__.constants).rmem_key_focusing_home;
                    var rmem_key_linking_mind_storage = __init__ (__world__.constants).rmem_key_linking_mind_storage;
                    var rmem_key_metadata = __init__ (__world__.constants).rmem_key_metadata;
                    var rmem_key_mineral_mind_storage = __init__ (__world__.constants).rmem_key_mineral_mind_storage;
                    var rmem_key_now_supporting = __init__ (__world__.constants).rmem_key_now_supporting;
                    var rmem_key_pause_all_room_operations = __init__ (__world__.constants).rmem_key_pause_all_room_operations;
                    var rmem_key_planned_role_to_spawn = __init__ (__world__.constants).rmem_key_planned_role_to_spawn;
                    var rmem_key_prepping_defenses = __init__ (__world__.constants).rmem_key_prepping_defenses;
                    var rmem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants).rmem_key_remotes_explicitly_marked_under_attack;
                    var rmem_key_remotes_safe_when_under_siege = __init__ (__world__.constants).rmem_key_remotes_safe_when_under_siege;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
                    var rmem_key_spawn_requests = __init__ (__world__.constants).rmem_key_spawn_requests;
                    var rmem_key_sponsor = __init__ (__world__.constants).rmem_key_sponsor;
                    var rmem_key_storage_use_enabled = __init__ (__world__.constants).rmem_key_storage_use_enabled;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
                    var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants).rmem_key_there_might_be_energy_lying_around;
                    var rmem_key_total_open_source_spaces = __init__ (__world__.constants).rmem_key_total_open_source_spaces;
                    var rmem_key_upgrading_paused = __init__ (__world__.constants).rmem_key_upgrading_paused;
                    var rmem_key_work_parts_by_role = __init__ (__world__.constants).rmem_key_work_parts_by_role;
                    var role_bases = __init__ (__world__.constants).role_bases;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_cleanup = __init__ (__world__.constants).role_cleanup;
                    var role_colonist = __init__ (__world__.constants).role_colonist;
                    var role_defender = __init__ (__world__.constants).role_defender;
                    var role_energy_grab = __init__ (__world__.constants).role_energy_grab;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_link_manager = __init__ (__world__.constants).role_link_manager;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
                    var role_mineral_miner = __init__ (__world__.constants).role_mineral_miner;
                    var role_mineral_steal = __init__ (__world__.constants).role_mineral_steal;
                    var role_power_attack = __init__ (__world__.constants).role_power_attack;
                    var role_power_cleanup = __init__ (__world__.constants).role_power_cleanup;
                    var role_ranged_offense = __init__ (__world__.constants).role_ranged_offense;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_remote_mining_reserve = __init__ (__world__.constants).role_remote_mining_reserve;
                    var role_room_reserve = __init__ (__world__.constants).role_room_reserve;
                    var role_scout = __init__ (__world__.constants).role_scout;
                    var role_simple_claim = __init__ (__world__.constants).role_simple_claim;
                    var role_simple_dismantle = __init__ (__world__.constants).role_simple_dismantle;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_spawn_fill_backup = __init__ (__world__.constants).role_spawn_fill_backup;
                    var role_td_goad = __init__ (__world__.constants).role_td_goad;
                    var role_td_healer = __init__ (__world__.constants).role_td_healer;
                    var role_temporary_replacing = __init__ (__world__.constants).role_temporary_replacing;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var role_tower_fill_once = __init__ (__world__.constants).role_tower_fill_once;
                    var role_upgrade_fill = __init__ (__world__.constants).role_upgrade_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var role_wall_defender = __init__ (__world__.constants).role_wall_defender;
                    var target_big_big_repair = __init__ (__world__.constants).target_big_big_repair;
                    var target_big_repair = __init__ (__world__.constants).target_big_repair;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var target_construction = __init__ (__world__.constants).target_construction;
                    var target_destruction_site = __init__ (__world__.constants).target_destruction_site;
                    var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
                    var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
                    var target_home_flag = __init__ (__world__.constants).target_home_flag;
                    var target_rampart_defense = __init__ (__world__.constants).target_rampart_defense;
                    var target_refill = __init__ (__world__.constants).target_refill;
                    var target_repair = __init__ (__world__.constants).target_repair;
                    var target_reserve_now = __init__ (__world__.constants).target_reserve_now;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var target_single_flag2 = __init__ (__world__.constants).target_single_flag2;
                    var target_source = __init__ (__world__.constants).target_source;
                    var target_spawn_deposit = __init__ (__world__.constants).target_spawn_deposit;
                    var target_tower_fill = __init__ (__world__.constants).target_tower_fill;
                    var spawning = __init__ (__world__.creep_management.spawning);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var reassign_room_roles = function (room) {
                        if (room.spawn && !(room.role_count (role_spawn_fill)) && !(room.role_count (role_spawn_fill_backup)) && !(room.role_count (role_tower_fill)) && len (room.creeps)) {
                            var __iterable0__ = room.creeps;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var creep = __iterable0__ [__index0__];
                                var memory = creep.memory;
                                var base = spawning.find_base_type (creep);
                                if (base == creep_base_worker) {
                                    memory.role = role_spawn_fill_backup;
                                    break;
                                }
                                else if (base == creep_base_hauler) {
                                    memory.role = role_spawn_fill;
                                    break;
                                }
                            }
                            room.recalculate_roles_alive ();
                        }
                        if (!(room.under_siege ()) && room.spawn && !(room.role_count (role_miner)) && !(room.work_mass_of (role_spawn_fill)) && !(room.work_mass_of (role_spawn_fill_backup)) && !(room.work_mass_of (role_tower_fill)) && len (room.creeps) && (!(room.role_count (role_spawn_fill)) && !(room.role_count (role_tower_fill)) || room.room.storage && !(room.room.storage.storeCapacity))) {
                            var __iterable0__ = room.creeps;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var creep = __iterable0__ [__index0__];
                                var memory = creep.memory;
                                var base = spawning.find_base_type (creep);
                                if (base == creep_base_worker) {
                                    memory.role = role_spawn_fill_backup;
                                }
                            }
                        }
                    };
                    var clear_memory = function (room) {
                        var smallest_ticks_to_live = 500;
                        var closest_replacement_time = Game.time + 100;
                        var targets = room.hive.targets;
                        var __iterable0__ = _.pairs (Memory.creeps);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var __left0__ = __iterable0__ [__index0__];
                            var name = __left0__ [0];
                            var memory = __left0__ [1];
                            var home = memory.home;
                            if (home != room.name && home) {
                                continue;
                            }
                            var creep = Game.creeps [name];
                            if (!(creep)) {
                                targets.untarget_all ({'name': name});
                                delete Memory.creeps [name];
                            }
                            else {
                                if (creep.ticksToLive < smallest_ticks_to_live) {
                                    var smallest_ticks_to_live = creep.ticksToLive;
                                }
                                var replacement_time = room.replacement_time_of (creep);
                                if ((Game.time < replacement_time && replacement_time < closest_replacement_time)) {
                                    var closest_replacement_time = replacement_time;
                                }
                            }
                        }
                        var dead_next = Game.time + smallest_ticks_to_live;
                        room.mem [rmem_key_metadata].clear_next = dead_next + 1;
                        room.mem [rmem_key_metadata].reset_spawn_on = closest_replacement_time + 1;
                    };
                    var get_next_replacement_time = function (room) {
                        var closest_replacement_time = Game.time + 100;
                        var __iterable0__ = room.creeps;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var creep = __iterable0__ [__index0__];
                            var replacement_time = room.replacement_time_of (creep);
                            if ((Game.time < replacement_time && replacement_time < closest_replacement_time)) {
                                var closest_replacement_time = replacement_time;
                            }
                        }
                        return closest_replacement_time;
                    };
                    var clear_cache = function () {
                        var __iterable0__ = _.pairs (Memory.rooms);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var __left0__ = __iterable0__ [__index0__];
                            var name = __left0__ [0];
                            var mem = __left0__ [1];
                            if ((rmem_key_cache in mem)) {
                                var __iterable1__ = Object.keys (mem.cache);
                                for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                    var key = __iterable1__ [__index1__];
                                    var cache = mem.cache [key];
                                    if (Game.time > cache.dead_at || cache.ttl_after_use && Game.time > cache.last_used + cache.ttl_after_use) {
                                        delete mem.cache [key];
                                    }
                                }
                                if (len (Object.keys (mem.cache)) <= 0) {
                                    delete mem.cache;
                                }
                            }
                            if ((rmem_key_room_reserved_up_until_tick in mem) && mem.rea <= Game.time) {
                                delete mem.rea;
                            }
                            if (_.isEmpty (mem)) {
                                delete Memory.rooms [name];
                            }
                        }
                        var __iterable0__ = _.pairs (Memory.flags);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var __left0__ = __iterable0__ [__index0__];
                            var name = __left0__ [0];
                            var mem = __left0__ [1];
                            if (_.isEmpty (mem)) {
                                delete Memory.flags [name];
                            }
                            else if (!(name in Game.flags) && (!(name.includes ('_')) && name.includes ('Flag') || name.includes ('local_mine'))) {
                                delete Memory.flags [name];
                                print ("[consistency] Clearing flag {}'s memory: {}".format (name, JSON.stringify (mem)));
                            }
                        }
                        global_cache.cleanup ();
                    };
                    var complete_refresh = function (hive) {
                        var __iterable0__ = hive.my_rooms;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var room = __iterable0__ [__index0__];
                            clear_memory (room);
                            room.recalculate_roles_alive ();
                            room.reset_planned_role ();
                        }
                        var __iterable0__ = Object.keys (Memory.creeps);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var name = __iterable0__ [__index0__];
                            if (!(name in Game.creeps)) {
                                var mem = Memory.creeps [name];
                                print ('[consistency] Clearing rouge creep: {} ({})'.format (name, mem.home));
                                delete Memory.creeps [name];
                            }
                        }
                        var target_mem = _.get (Memory, 'targets.targeters_using');
                        var __iterable0__ = Object.keys (target_mem);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var name = __iterable0__ [__index0__];
                            if (!(name in Game.creeps)) {
                                var targets = target_mem [name];
                                print ('[consistency] Clearing rouge targets for creep: {} ({})'.format (name, Object.keys (targets)));
                                hive.targets.untarget_all ({'name': name});
                            }
                        }
                        var __iterable0__ = ['cpu_usage', 'profiler', '_debug', 'x'];
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var key = __iterable0__ [__index0__];
                            if ((key in Memory)) {
                                print ('[consistency] Removing deprecated memory path: {}'.format (key));
                                delete Memory [key];
                            }
                        }
                        var __iterable0__ = Object.keys (Memory.rooms);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var name = __iterable0__ [__index0__];
                            var mem = Memory.rooms [name];
                            if (('_ly' in mem)) {
                                delete mem ['_ly'];
                            }
                            if (('attack_until' in mem)) {
                                delete mem ['attack_until'];
                            }
                            if (('alert' in mem)) {
                                delete mem ['alert'];
                            }
                            if (!(len (mem))) {
                                delete Memory.rooms [name];
                            }
                        }
                        var __iterable0__ = Object.keys (Memory.flags);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var name = __iterable0__ [__index0__];
                            var mem = Memory.flags [name];
                            if (('remote_miner_targeting' in mem)) {
                                delete mem ['remote_miner_targeting'];
                            }
                            if (!(len (mem))) {
                                delete Memory.flags [name];
                            }
                        }
                    };
                    __pragma__ ('<use>' +
                        'cache.global_cache' +
                        'constants' +
                        'creep_management.spawning' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.DEPOT = DEPOT;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.PYFIND_BUILDABLE_ROADS = PYFIND_BUILDABLE_ROADS;
                        __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
                        __all__.PYFIND_REPAIRABLE_ROADS = PYFIND_REPAIRABLE_ROADS;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.REROUTE = REROUTE;
                        __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
                        __all__.RESERVE_NOW = RESERVE_NOW;
                        __all__.SCOUT = SCOUT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SK_USERNAME = SK_USERNAME;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__.clear_cache = clear_cache;
                        __all__.clear_memory = clear_memory;
                        __all__.complete_refresh = complete_refresh;
                        __all__.creep_base_1500miner = creep_base_1500miner;
                        __all__.creep_base_3000miner = creep_base_3000miner;
                        __all__.creep_base_3h = creep_base_3h;
                        __all__.creep_base_4000miner = creep_base_4000miner;
                        __all__.creep_base_carry3000miner = creep_base_carry3000miner;
                        __all__.creep_base_claim_attack = creep_base_claim_attack;
                        __all__.creep_base_claiming = creep_base_claiming;
                        __all__.creep_base_defender = creep_base_defender;
                        __all__.creep_base_dismantler = creep_base_dismantler;
                        __all__.creep_base_full_move_dismantler = creep_base_full_move_dismantler;
                        __all__.creep_base_full_move_goader = creep_base_full_move_goader;
                        __all__.creep_base_full_move_healer = creep_base_full_move_healer;
                        __all__.creep_base_full_move_power_attack = creep_base_full_move_power_attack;
                        __all__.creep_base_full_upgrader = creep_base_full_upgrader;
                        __all__.creep_base_goader = creep_base_goader;
                        __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
                        __all__.creep_base_half_move_healer = creep_base_half_move_healer;
                        __all__.creep_base_hauler = creep_base_hauler;
                        __all__.creep_base_mammoth_miner = creep_base_mammoth_miner;
                        __all__.creep_base_power_attack = creep_base_power_attack;
                        __all__.creep_base_rampart_defense = creep_base_rampart_defense;
                        __all__.creep_base_ranged_offense = creep_base_ranged_offense;
                        __all__.creep_base_reserving = creep_base_reserving;
                        __all__.creep_base_scout = creep_base_scout;
                        __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
                        __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
                        __all__.creep_base_worker = creep_base_worker;
                        __all__.default_roles = default_roles;
                        __all__.get_next_replacement_time = get_next_replacement_time;
                        __all__.global_cache = global_cache;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.gmem_key_last_room_state_refresh = gmem_key_last_room_state_refresh;
                        __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
                        __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
                        __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.old_role_names = old_role_names;
                        __all__.reassign_room_roles = reassign_room_roles;
                        __all__.recycle_time = recycle_time;
                        __all__.request_priority_economy = request_priority_economy;
                        __all__.request_priority_helping_party = request_priority_helping_party;
                        __all__.request_priority_imminent_threat_defense = request_priority_imminent_threat_defense;
                        __all__.request_priority_low = request_priority_low;
                        __all__.rmem_key_building_paused = rmem_key_building_paused;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.rmem_key_cache = rmem_key_cache;
                        __all__.rmem_key_carry_parts_by_role = rmem_key_carry_parts_by_role;
                        __all__.rmem_key_creeps_by_role = rmem_key_creeps_by_role;
                        __all__.rmem_key_creeps_by_role_and_replacement_time = rmem_key_creeps_by_role_and_replacement_time;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                        __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
                        __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
                        __all__.rmem_key_flag_for_testing_spawning_in_simulation = rmem_key_flag_for_testing_spawning_in_simulation;
                        __all__.rmem_key_focusing_home = rmem_key_focusing_home;
                        __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
                        __all__.rmem_key_metadata = rmem_key_metadata;
                        __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
                        __all__.rmem_key_now_supporting = rmem_key_now_supporting;
                        __all__.rmem_key_pause_all_room_operations = rmem_key_pause_all_room_operations;
                        __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
                        __all__.rmem_key_prepping_defenses = rmem_key_prepping_defenses;
                        __all__.rmem_key_remotes_explicitly_marked_under_attack = rmem_key_remotes_explicitly_marked_under_attack;
                        __all__.rmem_key_remotes_safe_when_under_siege = rmem_key_remotes_safe_when_under_siege;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.rmem_key_spawn_requests = rmem_key_spawn_requests;
                        __all__.rmem_key_sponsor = rmem_key_sponsor;
                        __all__.rmem_key_storage_use_enabled = rmem_key_storage_use_enabled;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
                        __all__.rmem_key_total_open_source_spaces = rmem_key_total_open_source_spaces;
                        __all__.rmem_key_upgrading_paused = rmem_key_upgrading_paused;
                        __all__.rmem_key_work_parts_by_role = rmem_key_work_parts_by_role;
                        __all__.role_bases = role_bases;
                        __all__.role_builder = role_builder;
                        __all__.role_cleanup = role_cleanup;
                        __all__.role_colonist = role_colonist;
                        __all__.role_defender = role_defender;
                        __all__.role_energy_grab = role_energy_grab;
                        __all__.role_hauler = role_hauler;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_miner = role_miner;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.role_mineral_miner = role_mineral_miner;
                        __all__.role_mineral_steal = role_mineral_steal;
                        __all__.role_power_attack = role_power_attack;
                        __all__.role_power_cleanup = role_power_cleanup;
                        __all__.role_ranged_offense = role_ranged_offense;
                        __all__.role_recycling = role_recycling;
                        __all__.role_remote_mining_reserve = role_remote_mining_reserve;
                        __all__.role_room_reserve = role_room_reserve;
                        __all__.role_scout = role_scout;
                        __all__.role_simple_claim = role_simple_claim;
                        __all__.role_simple_dismantle = role_simple_dismantle;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_spawn_fill_backup = role_spawn_fill_backup;
                        __all__.role_td_goad = role_td_goad;
                        __all__.role_td_healer = role_td_healer;
                        __all__.role_temporary_replacing = role_temporary_replacing;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.role_tower_fill_once = role_tower_fill_once;
                        __all__.role_upgrade_fill = role_upgrade_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.role_wall_defender = role_wall_defender;
                        __all__.spawning = spawning;
                        __all__.target_big_big_repair = target_big_big_repair;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_construction = target_construction;
                        __all__.target_destruction_site = target_destruction_site;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                        __all__.target_home_flag = target_home_flag;
                        __all__.target_rampart_defense = target_rampart_defense;
                        __all__.target_refill = target_refill;
                        __all__.target_repair = target_repair;
                        __all__.target_reserve_now = target_reserve_now;
                        __all__.target_single_flag = target_single_flag;
                        __all__.target_single_flag2 = target_single_flag2;
                        __all__.target_source = target_source;
                        __all__.target_spawn_deposit = target_spawn_deposit;
                        __all__.target_tower_fill = target_tower_fill;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'cache.context', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var _hive = null;
                    var hive = function () {
                        return _hive;
                    };
                    var set_hive = function (new_hive) {
                        _hive = new_hive;
                    };
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__._hive = _hive;
                        __all__.hive = hive;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.set_hive = set_hive;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'cache.global_cache', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
                    var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var root = function () {
                        if (!(Memory.cache)) {
                            Memory.cache = {};
                        }
                        return Memory.cache;
                    };
                    var get = function (key) {
                        var r = root ();
                        if ((key in r) && r [key].d > Game.time) {
                            r [key].l = Game.time;
                            return r [key].v;
                        }
                        else {
                            return null;
                        }
                    };
                    var has = function (key) {
                        var r = root ();
                        return (key in r);
                    };
                    var set = function (key, value, ttl) {
                        var r = root ();
                        r [key] = {'v': value, 'd': Game.time + ttl, 'l': Game.time};
                    };
                    var rem = function (key) {
                        var r = root ();
                        delete r [key];
                    };
                    var cleanup = function () {
                        var r = root ();
                        var __iterable0__ = Object.keys (r);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var key = __iterable0__ [__index0__];
                            if (r [key].d <= Game.time) {
                                delete r [key];
                            }
                            else {
                                if (key.includes ('cost_matrix')) {
                                    var min_last_use = Game.time - max_repath_mine_roads_every * 1.2;
                                }
                                else if (key.endswith (global_cache_mining_roads_suffix)) {
                                    var min_last_use = Game.time - max_repath_mine_roads_every;
                                }
                                else {
                                    var min_last_use = Game.time - CREEP_LIFE_TIME;
                                }
                                if (r [key].l < min_last_use) {
                                    delete r [key];
                                }
                            }
                        }
                    };
                    var clear_values_matching = function (name) {
                        if (!(name)) {
                            return ;
                        }
                        var __iterable0__ = Object.keys (Memory.cache);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var key = __iterable0__ [__index0__];
                            if (key.includes (name)) {
                                delete Memory.cache [key];
                                print ('[clear_global_cache] Cleared {}.'.format (key));
                            }
                        }
                    };
                    __pragma__ ('<use>' +
                        'constants' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.cleanup = cleanup;
                        __all__.clear_values_matching = clear_values_matching;
                        __all__.get = get;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.has = has;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.rem = rem;
                        __all__.root = root;
                        __all__.set = set;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'cache.volatile_cache', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var _volatile_memory = null;
                    var _tick_stored_for = 0;
                    var volatile = function () {
                        if (_volatile_memory === null || _tick_stored_for < Game.time) {
                            _tick_stored_for = Game.time;
                            _volatile_memory = new_map ();
                        }
                        return _volatile_memory;
                    };
                    var mem = function (key) {
                        var v = volatile ();
                        if (!(v.has (key))) {
                            v.set (key, new_map ());
                        }
                        return v.get (key);
                    };
                    var setmem = function (key) {
                        var v = volatile ();
                        if (!(v.has (key))) {
                            v.set (key, new_set ());
                        }
                        return v.get (key);
                    };
                    var submem = function (key1, key2) {
                        var v = volatile ();
                        if (!(v.has (key1))) {
                            v.set (key1, new_map ([[key2, new_map ()]]));
                        }
                        else if (!(v.get (key1).has (key2))) {
                            v.get (key1).set (key2, new_map ());
                        }
                        return v.get (key1).get (key2);
                    };
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__._tick_stored_for = _tick_stored_for;
                        __all__._volatile_memory = _volatile_memory;
                        __all__.mem = mem;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.setmem = setmem;
                        __all__.submem = submem;
                        __all__.volatile = volatile;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'constants', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var creep_base_1500miner = 'fast_small_miner';
                    var creep_base_3000miner = 'fast_big_miner';
                    var creep_base_3h = 'ranged_3h';
                    var creep_base_4000miner = 'faster_bigger_miner';
                    var creep_base_carry3000miner = 'fast_miner_with_carry';
                    var creep_base_claim_attack = 'claim_attack';
                    var creep_base_claiming = 'strong_claim';
                    var creep_base_defender = 'simple_defender';
                    var creep_base_dismantler = 'med_dismantle';
                    var creep_base_full_move_dismantler = 'fm_dismantle';
                    var creep_base_full_move_goader = 'fm_goader';
                    var creep_base_full_move_healer = 'fm_healer';
                    var creep_base_full_move_power_attack = 'fm_power_attack';
                    var creep_base_full_upgrader = 'min_carry_worker';
                    var creep_base_goader = 'med_goader';
                    var creep_base_half_move_hauler = 'hm_hauler';
                    var creep_base_half_move_healer = 'hm_healer';
                    var creep_base_hauler = 'med_hauler';
                    var creep_base_mammoth_miner = 'mammoth_miner';
                    var creep_base_power_attack = 'power_attack';
                    var creep_base_rampart_defense = 'rampart_defender';
                    var creep_base_ranged_offense = 'ranged_offensive';
                    var creep_base_reserving = 'remote_reserve';
                    var creep_base_scout = 'scout';
                    var creep_base_work_full_move_hauler = 'fw_fm_hauler';
                    var creep_base_work_half_move_hauler = 'fw_hm_hauler';
                    var creep_base_worker = 'worker';
                    var target_source = 0;
                    var target_closest_energy_site = 1;
                    var target_single_flag = 2;
                    var target_single_flag2 = 3;
                    var target_home_flag = 4;
                    var target_refill = 5;
                    var target_construction = 10;
                    var target_repair = 11;
                    var target_big_repair = 12;
                    var target_big_big_repair = 13;
                    var target_destruction_site = 14;
                    var target_spawn_deposit = 20;
                    var target_tower_fill = 21;
                    var target_energy_miner_mine = 30;
                    var target_energy_hauler_mine = 31;
                    var target_reserve_now = 32;
                    var target_rampart_defense = 40;
                    var role_upgrader = 'upgrader';
                    var role_spawn_fill_backup = 'spawn_fill_backup';
                    var role_spawn_fill = 'spawn_fill';
                    var role_upgrade_fill = 'ufiller';
                    var role_builder = 'builder';
                    var role_tower_fill = 'tower_fill';
                    var role_tower_fill_once = 'tfo';
                    var role_miner = 'miner';
                    var role_hauler = 'hauler';
                    var role_remote_mining_reserve = 'remote_reserve_controller';
                    var role_link_manager = 'link_manager';
                    var role_defender = 'simple_defender';
                    var role_wall_defender = 'melee_wall_defender';
                    var role_ranged_offense = 'kiting_offense';
                    var role_colonist = 'colonist';
                    var role_simple_claim = 'simple_claim';
                    var role_room_reserve = 'top_priority_reserve';
                    var role_cleanup = 'simple_cleanup';
                    var role_temporary_replacing = 'currently_replacing';
                    var role_recycling = 'recycling';
                    var role_mineral_steal = 'steal_minerals';
                    var role_mineral_miner = 'local_mineral_miner';
                    var role_mineral_hauler = 'local_mineral_hauler';
                    var role_td_healer = 'tower_drain_healer';
                    var role_td_goad = 'tower_drain_goader';
                    var role_simple_dismantle = 'simple_dismantler';
                    var role_energy_grab = 'egrab';
                    var role_power_attack = 'attack_power';
                    var role_power_cleanup = 'power_cleanup';
                    var role_scout = 'scout';
                    var old_role_names = {'ufiller': 'upgrade_fill', 'remote_miner': 'miner', 'remote_hauler': 'hauler', 'basic_colonist': 'colonist'};
                    var role_bases = {[role_spawn_fill_backup]: creep_base_worker, [role_spawn_fill]: creep_base_hauler, [role_upgrade_fill]: creep_base_hauler, [role_builder]: creep_base_worker, [role_tower_fill]: creep_base_hauler, [role_remote_mining_reserve]: creep_base_reserving, [role_link_manager]: creep_base_half_move_hauler, [role_defender]: creep_base_defender, [role_wall_defender]: creep_base_rampart_defense, [role_cleanup]: creep_base_hauler, [role_colonist]: creep_base_worker, [role_simple_claim]: creep_base_claiming, [role_room_reserve]: creep_base_reserving, [role_mineral_miner]: creep_base_mammoth_miner, [role_mineral_hauler]: creep_base_hauler, [role_simple_dismantle]: creep_base_dismantler, [role_scout]: creep_base_scout, [role_mineral_steal]: creep_base_half_move_hauler};
                    var default_roles = {[creep_base_worker]: role_spawn_fill_backup, [creep_base_1500miner]: role_miner, [creep_base_3000miner]: role_miner, [creep_base_4000miner]: role_miner, [creep_base_carry3000miner]: role_miner, [creep_base_hauler]: role_hauler, [creep_base_work_full_move_hauler]: role_hauler, [creep_base_work_half_move_hauler]: role_hauler, [creep_base_reserving]: role_remote_mining_reserve, [creep_base_defender]: role_defender, [creep_base_mammoth_miner]: role_mineral_miner, [creep_base_goader]: role_td_goad, [creep_base_full_move_goader]: role_td_goad, [creep_base_half_move_healer]: role_td_healer, [creep_base_full_move_healer]: role_td_healer, [creep_base_dismantler]: role_simple_dismantle, [creep_base_full_move_dismantler]: role_simple_dismantle, [creep_base_full_upgrader]: role_upgrader, [creep_base_scout]: role_scout, [creep_base_power_attack]: role_power_attack, [creep_base_full_move_power_attack]: role_power_attack, [creep_base_rampart_defense]: role_wall_defender, [creep_base_claim_attack]: role_simple_claim};
                    var DEPOT = 0;
                    var UPGRADER_SPOT = 1;
                    var SPAWN_FILL_WAIT = 2;
                    var REROUTE = 10;
                    var REROUTE_DESTINATION = 11;
                    var SLIGHTLY_AVOID = 12;
                    var SK_LAIR_SOURCE_NOTED = 13;
                    var REMOTE_MINE = 20;
                    var LOCAL_MINE = 21;
                    var RESERVE_NOW = 22;
                    var CLAIM_LATER = 23;
                    var SCOUT = 50;
                    var RANGED_DEFENSE = 51;
                    var ATTACK_DISMANTLE = 52;
                    var ENERGY_GRAB = 53;
                    var RAMPART_DEFENSE = 54;
                    var RAID_OVER = 59;
                    var TD_H_H_STOP = 60;
                    var TD_H_D_STOP = 61;
                    var TD_D_GOAD = 62;
                    var ATTACK_POWER_BANK = 65;
                    var REAP_POWER_BANK = 66;
                    var PYFIND_REPAIRABLE_ROADS = 1001;
                    var PYFIND_BUILDABLE_ROADS = 1002;
                    var PYFIND_HURT_CREEPS = 1003;
                    var INVADER_USERNAME = 'Invader';
                    var SK_USERNAME = 'Source Keeper';
                    var recycle_time = 50;
                    var request_priority_imminent_threat_defense = 1;
                    var request_priority_economy = 5;
                    var request_priority_helping_party = 9;
                    var request_priority_low = 20;
                    var min_repath_mine_roads_every = 200 * 1000;
                    var max_repath_mine_roads_every = 250 * 1000;
                    var min_repave_mine_roads_every = 20 * 1000;
                    var max_repave_mine_roads_every = 25 * 1000;
                    var global_cache_mining_roads_suffix = '_mrd';
                    var gmem_key_room_mining_paths = __init__ (__world__.constants.memkeys).global_mem_key_room_mining_paths;
                    var gmem_key_last_room_state_refresh = __init__ (__world__.constants.memkeys).global_mem_key_last_room_state_refresh;
                    var rmem_key_building_paused = __init__ (__world__.constants.memkeys.room).mem_key_building_paused;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants.memkeys.room).mem_key_building_priority_spawn;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants.memkeys.room).mem_key_building_priority_walls;
                    var rmem_key_cache = __init__ (__world__.constants.memkeys.room).mem_key_cache;
                    var rmem_key_carry_parts_by_role = __init__ (__world__.constants.memkeys.room).mem_key_carry_parts_by_role;
                    var rmem_key_creeps_by_role = __init__ (__world__.constants.memkeys.room).mem_key_creeps_by_role;
                    var rmem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants.memkeys.room).mem_key_creeps_by_role_and_replacement_time;
                    var rmem_key_currently_under_siege = __init__ (__world__.constants.memkeys.room).mem_key_currently_under_siege;
                    var rmem_key_defense_mind_storage = __init__ (__world__.constants.memkeys.room).mem_key_defense_mind_storage;
                    var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants.memkeys.room).mem_key_empty_all_resources_into_room;
                    var rmem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants.memkeys.room).mem_key_flag_for_testing_spawning_in_simulation;
                    var rmem_key_focusing_home = __init__ (__world__.constants.memkeys.room).mem_key_focusing_home;
                    var rmem_key_linking_mind_storage = __init__ (__world__.constants.memkeys.room).mem_key_linking_mind_storage;
                    var rmem_key_metadata = __init__ (__world__.constants.memkeys.room).mem_key_metadata;
                    var rmem_key_mineral_mind_storage = __init__ (__world__.constants.memkeys.room).mem_key_mineral_mind_storage;
                    var rmem_key_pause_all_room_operations = __init__ (__world__.constants.memkeys.room).mem_key_pause_all_room_operations;
                    var rmem_key_planned_role_to_spawn = __init__ (__world__.constants.memkeys.room).mem_key_planned_role_to_spawn;
                    var rmem_key_prepping_defenses = __init__ (__world__.constants.memkeys.room).mem_key_prepping_defenses;
                    var rmem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants.memkeys.room).mem_key_remotes_explicitly_marked_under_attack;
                    var rmem_key_remotes_safe_when_under_siege = __init__ (__world__.constants.memkeys.room).mem_key_remotes_safe_when_under_siege;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants.memkeys.room).mem_key_room_reserved_up_until_tick;
                    var rmem_key_spawn_requests = __init__ (__world__.constants.memkeys.room).mem_key_spawn_requests;
                    var rmem_key_sponsor = __init__ (__world__.constants.memkeys.room).mem_key_sponsor;
                    var rmem_key_storage_use_enabled = __init__ (__world__.constants.memkeys.room).mem_key_storage_use_enabled;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants.memkeys.room).mem_key_stored_hostiles;
                    var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants.memkeys.room).mem_key_there_might_be_energy_lying_around;
                    var rmem_key_total_open_source_spaces = __init__ (__world__.constants.memkeys.room).mem_key_total_open_source_spaces;
                    var rmem_key_upgrading_paused = __init__ (__world__.constants.memkeys.room).mem_key_upgrading_paused;
                    var rmem_key_work_parts_by_role = __init__ (__world__.constants.memkeys.room).mem_key_work_parts_by_role;
                    var rmem_key_now_supporting = __init__ (__world__.constants.memkeys.room).mem_key_now_supporting;
                    __pragma__ ('<use>' +
                        'constants.memkeys' +
                        'constants.memkeys.room' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.DEPOT = DEPOT;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.PYFIND_BUILDABLE_ROADS = PYFIND_BUILDABLE_ROADS;
                        __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
                        __all__.PYFIND_REPAIRABLE_ROADS = PYFIND_REPAIRABLE_ROADS;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.REROUTE = REROUTE;
                        __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
                        __all__.RESERVE_NOW = RESERVE_NOW;
                        __all__.SCOUT = SCOUT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SK_USERNAME = SK_USERNAME;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__.creep_base_1500miner = creep_base_1500miner;
                        __all__.creep_base_3000miner = creep_base_3000miner;
                        __all__.creep_base_3h = creep_base_3h;
                        __all__.creep_base_4000miner = creep_base_4000miner;
                        __all__.creep_base_carry3000miner = creep_base_carry3000miner;
                        __all__.creep_base_claim_attack = creep_base_claim_attack;
                        __all__.creep_base_claiming = creep_base_claiming;
                        __all__.creep_base_defender = creep_base_defender;
                        __all__.creep_base_dismantler = creep_base_dismantler;
                        __all__.creep_base_full_move_dismantler = creep_base_full_move_dismantler;
                        __all__.creep_base_full_move_goader = creep_base_full_move_goader;
                        __all__.creep_base_full_move_healer = creep_base_full_move_healer;
                        __all__.creep_base_full_move_power_attack = creep_base_full_move_power_attack;
                        __all__.creep_base_full_upgrader = creep_base_full_upgrader;
                        __all__.creep_base_goader = creep_base_goader;
                        __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
                        __all__.creep_base_half_move_healer = creep_base_half_move_healer;
                        __all__.creep_base_hauler = creep_base_hauler;
                        __all__.creep_base_mammoth_miner = creep_base_mammoth_miner;
                        __all__.creep_base_power_attack = creep_base_power_attack;
                        __all__.creep_base_rampart_defense = creep_base_rampart_defense;
                        __all__.creep_base_ranged_offense = creep_base_ranged_offense;
                        __all__.creep_base_reserving = creep_base_reserving;
                        __all__.creep_base_scout = creep_base_scout;
                        __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
                        __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
                        __all__.creep_base_worker = creep_base_worker;
                        __all__.default_roles = default_roles;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.gmem_key_last_room_state_refresh = gmem_key_last_room_state_refresh;
                        __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
                        __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
                        __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
                        __all__.old_role_names = old_role_names;
                        __all__.recycle_time = recycle_time;
                        __all__.request_priority_economy = request_priority_economy;
                        __all__.request_priority_helping_party = request_priority_helping_party;
                        __all__.request_priority_imminent_threat_defense = request_priority_imminent_threat_defense;
                        __all__.request_priority_low = request_priority_low;
                        __all__.rmem_key_building_paused = rmem_key_building_paused;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.rmem_key_cache = rmem_key_cache;
                        __all__.rmem_key_carry_parts_by_role = rmem_key_carry_parts_by_role;
                        __all__.rmem_key_creeps_by_role = rmem_key_creeps_by_role;
                        __all__.rmem_key_creeps_by_role_and_replacement_time = rmem_key_creeps_by_role_and_replacement_time;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                        __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
                        __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
                        __all__.rmem_key_flag_for_testing_spawning_in_simulation = rmem_key_flag_for_testing_spawning_in_simulation;
                        __all__.rmem_key_focusing_home = rmem_key_focusing_home;
                        __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
                        __all__.rmem_key_metadata = rmem_key_metadata;
                        __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
                        __all__.rmem_key_now_supporting = rmem_key_now_supporting;
                        __all__.rmem_key_pause_all_room_operations = rmem_key_pause_all_room_operations;
                        __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
                        __all__.rmem_key_prepping_defenses = rmem_key_prepping_defenses;
                        __all__.rmem_key_remotes_explicitly_marked_under_attack = rmem_key_remotes_explicitly_marked_under_attack;
                        __all__.rmem_key_remotes_safe_when_under_siege = rmem_key_remotes_safe_when_under_siege;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.rmem_key_spawn_requests = rmem_key_spawn_requests;
                        __all__.rmem_key_sponsor = rmem_key_sponsor;
                        __all__.rmem_key_storage_use_enabled = rmem_key_storage_use_enabled;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
                        __all__.rmem_key_total_open_source_spaces = rmem_key_total_open_source_spaces;
                        __all__.rmem_key_upgrading_paused = rmem_key_upgrading_paused;
                        __all__.rmem_key_work_parts_by_role = rmem_key_work_parts_by_role;
                        __all__.role_bases = role_bases;
                        __all__.role_builder = role_builder;
                        __all__.role_cleanup = role_cleanup;
                        __all__.role_colonist = role_colonist;
                        __all__.role_defender = role_defender;
                        __all__.role_energy_grab = role_energy_grab;
                        __all__.role_hauler = role_hauler;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_miner = role_miner;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.role_mineral_miner = role_mineral_miner;
                        __all__.role_mineral_steal = role_mineral_steal;
                        __all__.role_power_attack = role_power_attack;
                        __all__.role_power_cleanup = role_power_cleanup;
                        __all__.role_ranged_offense = role_ranged_offense;
                        __all__.role_recycling = role_recycling;
                        __all__.role_remote_mining_reserve = role_remote_mining_reserve;
                        __all__.role_room_reserve = role_room_reserve;
                        __all__.role_scout = role_scout;
                        __all__.role_simple_claim = role_simple_claim;
                        __all__.role_simple_dismantle = role_simple_dismantle;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_spawn_fill_backup = role_spawn_fill_backup;
                        __all__.role_td_goad = role_td_goad;
                        __all__.role_td_healer = role_td_healer;
                        __all__.role_temporary_replacing = role_temporary_replacing;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.role_tower_fill_once = role_tower_fill_once;
                        __all__.role_upgrade_fill = role_upgrade_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.role_wall_defender = role_wall_defender;
                        __all__.target_big_big_repair = target_big_big_repair;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_construction = target_construction;
                        __all__.target_destruction_site = target_destruction_site;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                        __all__.target_home_flag = target_home_flag;
                        __all__.target_rampart_defense = target_rampart_defense;
                        __all__.target_refill = target_refill;
                        __all__.target_repair = target_repair;
                        __all__.target_reserve_now = target_reserve_now;
                        __all__.target_single_flag = target_single_flag;
                        __all__.target_single_flag2 = target_single_flag2;
                        __all__.target_source = target_source;
                        __all__.target_spawn_deposit = target_spawn_deposit;
                        __all__.target_tower_fill = target_tower_fill;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'constants.memkeys', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var global_mem_key_last_room_state_refresh = 'sr';
                    var global_mem_key_room_mining_paths = 'mp';
                    __pragma__ ('<all>')
                        __all__.global_mem_key_last_room_state_refresh = global_mem_key_last_room_state_refresh;
                        __all__.global_mem_key_room_mining_paths = global_mem_key_room_mining_paths;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'constants.memkeys.room', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var mem_key_cache = 'cache';
                    var mem_key_metadata = 'meta';
                    var mem_key_sponsor = 'sponsor';
                    var mem_key_total_open_source_spaces = 'oss';
                    var mem_key_creeps_by_role = 'roles_alive';
                    var mem_key_work_parts_by_role = 'roles_work';
                    var mem_key_carry_parts_by_role = 'roles_carry';
                    var mem_key_creeps_by_role_and_replacement_time = 'rt_map';
                    var mem_key_prepping_defenses = 'prepping_defenses';
                    var mem_key_storage_use_enabled = 'full_storage_use';
                    var mem_key_focusing_home = 'focusing_home';
                    var mem_key_upgrading_paused = 'upgrading_paused';
                    var mem_key_building_paused = 'building_paused';
                    var mem_key_spawn_requests = '_requests';
                    var mem_key_planned_role_to_spawn = 'next_role';
                    var mem_key_flag_for_testing_spawning_in_simulation = 'completely_sim_testing';
                    var mem_key_pause_all_room_operations = 'pause';
                    var mem_key_empty_all_resources_into_room = 'empty_to';
                    var mem_key_room_reserved_up_until_tick = 'rea';
                    var mem_key_currently_under_siege = 'attack';
                    var mem_key_remotes_safe_when_under_siege = 'remotes_safe';
                    var mem_key_remotes_explicitly_marked_under_attack = 'remotes_attack';
                    var mem_key_stored_hostiles = 'danger';
                    var mem_key_defense_mind_storage = 'defense';
                    var mem_key_linking_mind_storage = 'links';
                    var mem_key_mineral_mind_storage = 'market';
                    var mem_key_building_priority_walls = 'prio_walls';
                    var mem_key_building_priority_spawn = 'prio_spawn';
                    var mem_key_there_might_be_energy_lying_around = 'tons';
                    var mem_key_now_supporting = 's';
                    var cache_key_spending_now = 'ss';
                    __pragma__ ('<all>')
                        __all__.cache_key_spending_now = cache_key_spending_now;
                        __all__.mem_key_building_paused = mem_key_building_paused;
                        __all__.mem_key_building_priority_spawn = mem_key_building_priority_spawn;
                        __all__.mem_key_building_priority_walls = mem_key_building_priority_walls;
                        __all__.mem_key_cache = mem_key_cache;
                        __all__.mem_key_carry_parts_by_role = mem_key_carry_parts_by_role;
                        __all__.mem_key_creeps_by_role = mem_key_creeps_by_role;
                        __all__.mem_key_creeps_by_role_and_replacement_time = mem_key_creeps_by_role_and_replacement_time;
                        __all__.mem_key_currently_under_siege = mem_key_currently_under_siege;
                        __all__.mem_key_defense_mind_storage = mem_key_defense_mind_storage;
                        __all__.mem_key_empty_all_resources_into_room = mem_key_empty_all_resources_into_room;
                        __all__.mem_key_flag_for_testing_spawning_in_simulation = mem_key_flag_for_testing_spawning_in_simulation;
                        __all__.mem_key_focusing_home = mem_key_focusing_home;
                        __all__.mem_key_linking_mind_storage = mem_key_linking_mind_storage;
                        __all__.mem_key_metadata = mem_key_metadata;
                        __all__.mem_key_mineral_mind_storage = mem_key_mineral_mind_storage;
                        __all__.mem_key_now_supporting = mem_key_now_supporting;
                        __all__.mem_key_pause_all_room_operations = mem_key_pause_all_room_operations;
                        __all__.mem_key_planned_role_to_spawn = mem_key_planned_role_to_spawn;
                        __all__.mem_key_prepping_defenses = mem_key_prepping_defenses;
                        __all__.mem_key_remotes_explicitly_marked_under_attack = mem_key_remotes_explicitly_marked_under_attack;
                        __all__.mem_key_remotes_safe_when_under_siege = mem_key_remotes_safe_when_under_siege;
                        __all__.mem_key_room_reserved_up_until_tick = mem_key_room_reserved_up_until_tick;
                        __all__.mem_key_spawn_requests = mem_key_spawn_requests;
                        __all__.mem_key_sponsor = mem_key_sponsor;
                        __all__.mem_key_storage_use_enabled = mem_key_storage_use_enabled;
                        __all__.mem_key_stored_hostiles = mem_key_stored_hostiles;
                        __all__.mem_key_there_might_be_energy_lying_around = mem_key_there_might_be_energy_lying_around;
                        __all__.mem_key_total_open_source_spaces = mem_key_total_open_source_spaces;
                        __all__.mem_key_upgrading_paused = mem_key_upgrading_paused;
                        __all__.mem_key_work_parts_by_role = mem_key_work_parts_by_role;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creep_management.autoactions', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var random = {};
                    __nest__ (random, '', __init__ (__world__.random));
                    var context = __init__ (__world__.cache.context);
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_simple_dismantle = __init__ (__world__.constants).role_simple_dismantle;
                    var walkby_move = __init__ (__world__.creep_management.walkby_move);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var defense = __init__ (__world__.rooms.defense);
                    var hostile_utils = __init__ (__world__.utilities.hostile_utils);
                    var movement = __init__ (__world__.utilities.movement);
                    var is_room_mostly_safe = function (room_name) {
                        var room = context.hive ().get_room (room_name);
                        if (!(room) || !(room.my)) {
                            return false;
                        }
                        if (room.defense.broken_walls || room.being_bootstrapped ()) {
                            return false;
                        }
                        return true;
                    };
                    var pathfinder_enemy_array_for_room = function (room_name) {
                        var cache = volatile_cache.mem ('enemy_lists');
                        if (cache.has (room_name)) {
                            return cache.get (room_name);
                        }
                        var my = is_room_mostly_safe (room_name);
                        var enemy_positions = [];
                        var __iterable0__ = defense.stored_hostiles_near (room_name);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var h = __iterable0__ [__index0__];
                            if (!(is_room_mostly_safe (room_name))) {
                                if (h.user == INVADER_USERNAME) {
                                    if (my) {
                                        var enemy_range = 2;
                                    }
                                    else {
                                        var enemy_range = 5;
                                    }
                                }
                                else if (h.ranged || h.attack) {
                                    var enemy_range = 10;
                                }
                                else {
                                    continue;
                                }
                            }
                            else if (h.user == INVADER_USERNAME) {
                                var enemy_range = 5;
                            }
                            else if (h.ranged) {
                                var enemy_range = 7;
                            }
                            else if (h.attack) {
                                var enemy_range = 5;
                            }
                            else {
                                continue;
                            }
                            var pos = new RoomPosition (h.pos & 63, h.pos >> 6 & 63, h.room);
                            enemy_positions.append ({'pos': pos, 'range': enemy_range * 4});
                        }
                        cache.set (room_name, enemy_positions);
                        return enemy_positions;
                    };
                    var room_hostile = function (room_name) {
                        var cache = volatile_cache.mem ('rua');
                        if (cache.has (room_name)) {
                            return cache.get (room_name);
                        }
                        var room_under_attack = len (defense.stored_hostiles_in (room_name));
                        cache.set (room_name, room_under_attack);
                        return room_under_attack;
                    };
                    var enemy_purposes_cost_matrix = function (room_name) {
                        var cache = volatile_cache.mem ('super_simple_cost_matrix');
                        if (cache.has (room_name)) {
                            return cache.get (room_name);
                        }
                        var room = context.hive ().get_room (room_name);
                        if (!(room)) {
                            return new PathFinder.CostMatrix ();
                        }
                        var cost_matrix = new PathFinder.CostMatrix ();
                        var __iterable0__ = room.find (FIND_STRUCTURES);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var struct = __iterable0__ [__index0__];
                            if (struct.structureType != STRUCTURE_ROAD && struct.structureType != STRUCTURE_CONTAINER && (struct.structureType != STRUCTURE_RAMPART || struct.my)) {
                                cost_matrix.set (struct.pos.x, struct.pos.y, 255);
                            }
                        }
                        cache.set (room_name, cost_matrix);
                        return cost_matrix;
                    };
                    var simple_cost_matrix = function (room_name) {
                        var cache = volatile_cache.mem ('enemy_cost_matrix');
                        var room = context.hive ().get_room (room_name);
                        if (!(room)) {
                            if (room_hostile (room_name) || hostile_utils.enemy_room (room_name)) {
                                return false;
                            }
                            else {
                                return new PathFinder.CostMatrix ();
                            }
                        }
                        var cost_matrix = walkby_move.get_basic_cost_matrix (room_name, false);
                        var wall_at = function (x, y) {
                            return Game.map.getTerrainAt (x, y, room_name) == 'wall';
                        };
                        var set_in_range = function (pos, drange, value, increase_by_center) {
                            for (var x = pos.x - drange; x < (pos.x + drange) + 1; x++) {
                                for (var y = pos.y - drange; y < (pos.y + drange) + 1; y++) {
                                    if (!(wall_at (x, y)) && cost_matrix.get (x, y) < value) {
                                        cost_matrix.set (x, y, value);
                                    }
                                }
                            }
                            if (increase_by_center > 0 && drange > 0) {
                                set_in_range (pos, drange - 1, value + increase_by_center, increase_by_center);
                            }
                        };
                        var __iterable0__ = room.find (FIND_CREEPS);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var creep = __iterable0__ [__index0__];
                            set_in_range (creep.pos, 1, 5, 0);
                            cost_matrix.set (creep.pos.x, creep.pos.y, 255);
                        }
                        var __iterable0__ = room.find (FIND_HOSTILE_CREEPS);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var creep = __iterable0__ [__index0__];
                            set_in_range (creep.pos, 7, 2, 7);
                            cost_matrix.set (creep.pos.x, creep.pos.y, 255);
                        }
                        cache.set (room_name, cost_matrix);
                        return cost_matrix;
                    };
                    var get_path_away = function (origin, targets) {
                        var result = PathFinder.search (origin, targets, {'roomCallback': simple_cost_matrix, 'flee': true, 'maxRooms': 8});
                        var path = [];
                        var __left0__ = [origin.x, origin.y];
                        var last_x = __left0__ [0];
                        var last_y = __left0__ [1];
                        var __iterable0__ = result.path;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var pos = __iterable0__ [__index0__];
                            var dx = pos.x - last_x;
                            var dy = pos.y - last_y;
                            var last_x = pos.x;
                            var last_y = pos.y;
                            var direction = movement.dxdy_to_direction (dx, dy);
                            if (direction === null) {
                                print ('[autoactions][get_path_away] Unknown direction for pos: {},{}, last: {},{}'.format (pos.x, pos.y, last_x, last_y));
                                return null;
                            }
                            path.append ({'x': pos.x, 'y': pos.y, 'dx': dx, 'dy': dy, 'direction': direction});
                        }
                        return path;
                    };
                    var get_cached_away_path = function (creep, targets) {
                        if (('_away_path' in creep.memory) && creep.memory._away_path.reset > Game.time) {
                            return Room.deserializePath (creep.memory._away_path.path);
                        }
                        else {
                            var path = get_path_away (creep.pos, targets);
                            creep.memory._away_path = {'reset': Game.time + 10, 'path': Room.serializePath (path)};
                            return path;
                        }
                    };
                    var instinct_do_heal = function (creep) {
                        if (!(creep.creep.hasActiveBodyparts (HEAL))) {
                            return ;
                        }
                        var damaged = null;
                        var most_damage = 0;
                        var __iterable0__ = creep.room.look_for_in_area_around (LOOK_CREEPS, creep.pos, 1);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var ally_obj = __iterable0__ [__index0__];
                            var ally = ally_obj.creep;
                            if (!(ally.my) && !(Memory.meta.friends.includes (ally.owner.username))) {
                                continue;
                            }
                            var damage = ally.hitsMax - ally.hits;
                            if (damage > most_damage) {
                                var most_damage = damage;
                                var damaged = ally;
                            }
                        }
                        if (damaged) {
                            var result = creep.creep.heal (damaged);
                            if (result != OK) {
                                creep.log ('Unknown heal result! {}'.format (result));
                            }
                        }
                    };
                    var instinct_do_attack = function (creep) {
                        if (!(creep.creep.hasActiveBodyparts (ATTACK))) {
                            return ;
                        }
                        var best = null;
                        var best_priority = -(Infinity);
                        var __iterable0__ = creep.room.find_in_range (FIND_HOSTILE_CREEPS, 1, creep.pos);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var enemy = __iterable0__ [__index0__];
                            var priority = enemy.hitsMax - enemy.hits;
                            if (enemy.hasActiveBodyparts (RANGED_ATTACK)) {
                                priority += 3000;
                            }
                            else if (enemy.hasActiveBodyparts (ATTACK)) {
                                priority += 2000;
                            }
                            else if (enemy.hasActiveBodyparts (WORK)) {
                                priority += 1000;
                            }
                            if (priority > best_priority) {
                                var best_priority = priority;
                                var best = enemy;
                            }
                        }
                        if (best) {
                            creep.creep.attack (best);
                        }
                    };
                    var run_away_check = function (creep, hostile_path_targets) {
                        var check_path = is_room_mostly_safe (creep.pos.roomName);
                        if (check_path && !(creep.memory._safe) || !(creep.memory._safe_from) || movement.chebyshev_distance_room_pos (creep.memory._safe_from, creep.pos) > 2) {
                            creep.memory._safe = [];
                            creep.memory._safe_from = creep.pos;
                        }
                        var any_unsafe = false;
                        var __break0__ = false;
                        var __iterable0__ = hostile_path_targets;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var obj = __iterable0__ [__index0__];
                            var target = obj.pos;
                            var target_range = obj.range;
                            var distance = movement.chebyshev_distance_room_pos (target, creep.pos);
                            if (distance > target_range * 0.25 + 1) {
                                continue;
                            }
                            if (check_path) {
                                var safe = false;
                                var __iterable1__ = creep.memory._safe;
                                for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                    var safe_pos = __iterable1__ [__index1__];
                                    if (movement.chebyshev_distance_room_pos (safe_pos, target) < 2) {
                                        var safe = true;
                                        break;
                                    }
                                }
                                if (safe) {
                                    continue;
                                }
                                var enemy_path = PathFinder.search (target, {'pos': creep.pos, 'range': 1}, {'roomCallback': enemy_purposes_cost_matrix, 'maxRooms': 5, 'plainCost': 1, 'swampCost': 1, 'maxCost': 10});
                                if (enemy_path.incomplete) {
                                    creep.memory._safe.push (target);
                                    continue;
                                }
                            }
                            var distance = movement.chebyshev_distance_room_pos (target, creep.pos);
                            if (distance <= target_range * 0.25) {
                                __break0__ = true;
                                break;
                            }
                            else {
                                var any_unsafe = true;
                            }
                        }
                        if (!__break0__) {
                            return any_unsafe && random.randint (0, 3) < 3;
                        }
                        var path = get_cached_away_path (creep, hostile_path_targets);
                        if (len (path)) {
                            delete creep.last_checkpoint;
                            delete creep.last_target;
                            delete creep.memory.was_on_the_path;
                            var result = creep.moveByPath (path);
                            if (result == ERR_NO_PATH || result == ERR_NOT_FOUND) {
                                return true;
                            }
                            if (result != OK) {
                                print ('[{}][{}] Unknown result from moving when running away: {}'.format (creep.memory.home, creep.name, result));
                            }
                            return true;
                        }
                        else {
                            return false;
                        }
                    };
                    var running_check_room = function (room) {
                        if (room.my && room.room.controller.safeMode) {
                            return ;
                        }
                        var my_creeps = room.find (FIND_MY_CREEPS);
                        if (!(len (my_creeps))) {
                            return ;
                        }
                        if (!(len (room.defense.dangerous_hostiles ()))) {
                            return ;
                        }
                        var hostile_path_targets = pathfinder_enemy_array_for_room (room.name);
                        var __iterable0__ = my_creeps;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var creep = __iterable0__ [__index0__];
                            if (creep.fatigue > 0 || len (creep.body) <= 1 || _.find (creep.body, (function __lambda__ (p) {
                                return p.type == ATTACK || p.type == RANGED_ATTACK || p.type == HEAL;
                            })) || creep.memory.role == role_simple_dismantle && (creep.memory.home in Game.rooms) && room.hive.get_room (creep.memory.home).conducting_siege () || !(creep.hasActiveBodyparts (MOVE)) || creep.memory.role == role_miner && _.find (creep.pos.lookFor (LOOK_STRUCTURES), {'structureType': STRUCTURE_RAMPART})) {
                                continue;
                            }
                            var overridden = run_away_check (creep, hostile_path_targets);
                            if (overridden) {
                                creep.defense_override = true;
                            }
                        }
                    };
                    var cleanup_running_memory = function () {
                        var __iterable0__ = _.values (Game.creeps);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var creep = __iterable0__ [__index0__];
                            if (!(creep.defense_override) && ('_away_path' in creep.memory) || ('_safe' in creep.memory)) {
                                delete creep.memory._away_path;
                                delete creep.memory._safe;
                                delete creep.memory._safe_from;
                            }
                        }
                    };
                    var pickup_check_room = function (room) {
                        var energy = room.find (FIND_DROPPED_ENERGY);
                        if (!(len (energy))) {
                            return ;
                        }
                        var creeps = room.find (FIND_MY_CREEPS);
                        if (!(len (creeps))) {
                            return ;
                        }
                        var __iterable0__ = energy;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var pile = __iterable0__ [__index0__];
                            if (('picked_up' in pile)) {
                                continue;
                            }
                            var left = pile.amount;
                            var __iterable1__ = creeps;
                            for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                var creep = __iterable1__ [__index1__];
                                if (creep.carryCapacity != 0 && creep.pos.isNearTo (pile.pos) && ('wrapped' in creep) && creep.wrapped.should_pickup (pile.resourceType)) {
                                    if (!('picked_up' in creep)) {
                                        var empty = creep.carryCapacity - _.sum (creep.carry);
                                        var result = creep.pickup (pile);
                                        if (result == OK) {
                                            creep.cancelOrder ('withdraw');
                                            creep.picked_up = true;
                                            left -= empty;
                                            if (left <= 0) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                    __pragma__ ('<use>' +
                        'cache.context' +
                        'cache.volatile_cache' +
                        'constants' +
                        'creep_management.walkby_move' +
                        'jstools.screeps_constants' +
                        'random' +
                        'rooms.defense' +
                        'utilities.hostile_utils' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.cleanup_running_memory = cleanup_running_memory;
                        __all__.context = context;
                        __all__.defense = defense;
                        __all__.enemy_purposes_cost_matrix = enemy_purposes_cost_matrix;
                        __all__.get_cached_away_path = get_cached_away_path;
                        __all__.get_path_away = get_path_away;
                        __all__.hostile_utils = hostile_utils;
                        __all__.instinct_do_attack = instinct_do_attack;
                        __all__.instinct_do_heal = instinct_do_heal;
                        __all__.is_room_mostly_safe = is_room_mostly_safe;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.pathfinder_enemy_array_for_room = pathfinder_enemy_array_for_room;
                        __all__.pickup_check_room = pickup_check_room;
                        __all__.role_miner = role_miner;
                        __all__.role_simple_dismantle = role_simple_dismantle;
                        __all__.room_hostile = room_hostile;
                        __all__.run_away_check = run_away_check;
                        __all__.running_check_room = running_check_room;
                        __all__.simple_cost_matrix = simple_cost_matrix;
                        __all__.volatile_cache = volatile_cache;
                        __all__.walkby_move = walkby_move;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creep_management.creep_wrappers', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
                    var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
                    var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
                    var PYFIND_BUILDABLE_ROADS = __init__ (__world__.constants).PYFIND_BUILDABLE_ROADS;
                    var PYFIND_HURT_CREEPS = __init__ (__world__.constants).PYFIND_HURT_CREEPS;
                    var PYFIND_REPAIRABLE_ROADS = __init__ (__world__.constants).PYFIND_REPAIRABLE_ROADS;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var REROUTE = __init__ (__world__.constants).REROUTE;
                    var REROUTE_DESTINATION = __init__ (__world__.constants).REROUTE_DESTINATION;
                    var RESERVE_NOW = __init__ (__world__.constants).RESERVE_NOW;
                    var SCOUT = __init__ (__world__.constants).SCOUT;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var SK_USERNAME = __init__ (__world__.constants).SK_USERNAME;
                    var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
                    var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
                    var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
                    var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
                    var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var creep_base_1500miner = __init__ (__world__.constants).creep_base_1500miner;
                    var creep_base_3000miner = __init__ (__world__.constants).creep_base_3000miner;
                    var creep_base_3h = __init__ (__world__.constants).creep_base_3h;
                    var creep_base_4000miner = __init__ (__world__.constants).creep_base_4000miner;
                    var creep_base_carry3000miner = __init__ (__world__.constants).creep_base_carry3000miner;
                    var creep_base_claim_attack = __init__ (__world__.constants).creep_base_claim_attack;
                    var creep_base_claiming = __init__ (__world__.constants).creep_base_claiming;
                    var creep_base_defender = __init__ (__world__.constants).creep_base_defender;
                    var creep_base_dismantler = __init__ (__world__.constants).creep_base_dismantler;
                    var creep_base_full_move_dismantler = __init__ (__world__.constants).creep_base_full_move_dismantler;
                    var creep_base_full_move_goader = __init__ (__world__.constants).creep_base_full_move_goader;
                    var creep_base_full_move_healer = __init__ (__world__.constants).creep_base_full_move_healer;
                    var creep_base_full_move_power_attack = __init__ (__world__.constants).creep_base_full_move_power_attack;
                    var creep_base_full_upgrader = __init__ (__world__.constants).creep_base_full_upgrader;
                    var creep_base_goader = __init__ (__world__.constants).creep_base_goader;
                    var creep_base_half_move_hauler = __init__ (__world__.constants).creep_base_half_move_hauler;
                    var creep_base_half_move_healer = __init__ (__world__.constants).creep_base_half_move_healer;
                    var creep_base_hauler = __init__ (__world__.constants).creep_base_hauler;
                    var creep_base_mammoth_miner = __init__ (__world__.constants).creep_base_mammoth_miner;
                    var creep_base_power_attack = __init__ (__world__.constants).creep_base_power_attack;
                    var creep_base_rampart_defense = __init__ (__world__.constants).creep_base_rampart_defense;
                    var creep_base_ranged_offense = __init__ (__world__.constants).creep_base_ranged_offense;
                    var creep_base_reserving = __init__ (__world__.constants).creep_base_reserving;
                    var creep_base_scout = __init__ (__world__.constants).creep_base_scout;
                    var creep_base_work_full_move_hauler = __init__ (__world__.constants).creep_base_work_full_move_hauler;
                    var creep_base_work_half_move_hauler = __init__ (__world__.constants).creep_base_work_half_move_hauler;
                    var creep_base_worker = __init__ (__world__.constants).creep_base_worker;
                    var default_roles = __init__ (__world__.constants).default_roles;
                    var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
                    var gmem_key_last_room_state_refresh = __init__ (__world__.constants).gmem_key_last_room_state_refresh;
                    var gmem_key_room_mining_paths = __init__ (__world__.constants).gmem_key_room_mining_paths;
                    var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
                    var max_repave_mine_roads_every = __init__ (__world__.constants).max_repave_mine_roads_every;
                    var min_repath_mine_roads_every = __init__ (__world__.constants).min_repath_mine_roads_every;
                    var min_repave_mine_roads_every = __init__ (__world__.constants).min_repave_mine_roads_every;
                    var old_role_names = __init__ (__world__.constants).old_role_names;
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var request_priority_economy = __init__ (__world__.constants).request_priority_economy;
                    var request_priority_helping_party = __init__ (__world__.constants).request_priority_helping_party;
                    var request_priority_imminent_threat_defense = __init__ (__world__.constants).request_priority_imminent_threat_defense;
                    var request_priority_low = __init__ (__world__.constants).request_priority_low;
                    var rmem_key_building_paused = __init__ (__world__.constants).rmem_key_building_paused;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
                    var rmem_key_cache = __init__ (__world__.constants).rmem_key_cache;
                    var rmem_key_carry_parts_by_role = __init__ (__world__.constants).rmem_key_carry_parts_by_role;
                    var rmem_key_creeps_by_role = __init__ (__world__.constants).rmem_key_creeps_by_role;
                    var rmem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants).rmem_key_creeps_by_role_and_replacement_time;
                    var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
                    var rmem_key_defense_mind_storage = __init__ (__world__.constants).rmem_key_defense_mind_storage;
                    var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants).rmem_key_empty_all_resources_into_room;
                    var rmem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants).rmem_key_flag_for_testing_spawning_in_simulation;
                    var rmem_key_focusing_home = __init__ (__world__.constants).rmem_key_focusing_home;
                    var rmem_key_linking_mind_storage = __init__ (__world__.constants).rmem_key_linking_mind_storage;
                    var rmem_key_metadata = __init__ (__world__.constants).rmem_key_metadata;
                    var rmem_key_mineral_mind_storage = __init__ (__world__.constants).rmem_key_mineral_mind_storage;
                    var rmem_key_now_supporting = __init__ (__world__.constants).rmem_key_now_supporting;
                    var rmem_key_pause_all_room_operations = __init__ (__world__.constants).rmem_key_pause_all_room_operations;
                    var rmem_key_planned_role_to_spawn = __init__ (__world__.constants).rmem_key_planned_role_to_spawn;
                    var rmem_key_prepping_defenses = __init__ (__world__.constants).rmem_key_prepping_defenses;
                    var rmem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants).rmem_key_remotes_explicitly_marked_under_attack;
                    var rmem_key_remotes_safe_when_under_siege = __init__ (__world__.constants).rmem_key_remotes_safe_when_under_siege;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
                    var rmem_key_spawn_requests = __init__ (__world__.constants).rmem_key_spawn_requests;
                    var rmem_key_sponsor = __init__ (__world__.constants).rmem_key_sponsor;
                    var rmem_key_storage_use_enabled = __init__ (__world__.constants).rmem_key_storage_use_enabled;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
                    var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants).rmem_key_there_might_be_energy_lying_around;
                    var rmem_key_total_open_source_spaces = __init__ (__world__.constants).rmem_key_total_open_source_spaces;
                    var rmem_key_upgrading_paused = __init__ (__world__.constants).rmem_key_upgrading_paused;
                    var rmem_key_work_parts_by_role = __init__ (__world__.constants).rmem_key_work_parts_by_role;
                    var role_bases = __init__ (__world__.constants).role_bases;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_cleanup = __init__ (__world__.constants).role_cleanup;
                    var role_colonist = __init__ (__world__.constants).role_colonist;
                    var role_defender = __init__ (__world__.constants).role_defender;
                    var role_energy_grab = __init__ (__world__.constants).role_energy_grab;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_link_manager = __init__ (__world__.constants).role_link_manager;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
                    var role_mineral_miner = __init__ (__world__.constants).role_mineral_miner;
                    var role_mineral_steal = __init__ (__world__.constants).role_mineral_steal;
                    var role_power_attack = __init__ (__world__.constants).role_power_attack;
                    var role_power_cleanup = __init__ (__world__.constants).role_power_cleanup;
                    var role_ranged_offense = __init__ (__world__.constants).role_ranged_offense;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_remote_mining_reserve = __init__ (__world__.constants).role_remote_mining_reserve;
                    var role_room_reserve = __init__ (__world__.constants).role_room_reserve;
                    var role_scout = __init__ (__world__.constants).role_scout;
                    var role_simple_claim = __init__ (__world__.constants).role_simple_claim;
                    var role_simple_dismantle = __init__ (__world__.constants).role_simple_dismantle;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_spawn_fill_backup = __init__ (__world__.constants).role_spawn_fill_backup;
                    var role_td_goad = __init__ (__world__.constants).role_td_goad;
                    var role_td_healer = __init__ (__world__.constants).role_td_healer;
                    var role_temporary_replacing = __init__ (__world__.constants).role_temporary_replacing;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var role_tower_fill_once = __init__ (__world__.constants).role_tower_fill_once;
                    var role_upgrade_fill = __init__ (__world__.constants).role_upgrade_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var role_wall_defender = __init__ (__world__.constants).role_wall_defender;
                    var target_big_big_repair = __init__ (__world__.constants).target_big_big_repair;
                    var target_big_repair = __init__ (__world__.constants).target_big_repair;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var target_construction = __init__ (__world__.constants).target_construction;
                    var target_destruction_site = __init__ (__world__.constants).target_destruction_site;
                    var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
                    var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
                    var target_home_flag = __init__ (__world__.constants).target_home_flag;
                    var target_rampart_defense = __init__ (__world__.constants).target_rampart_defense;
                    var target_refill = __init__ (__world__.constants).target_refill;
                    var target_repair = __init__ (__world__.constants).target_repair;
                    var target_reserve_now = __init__ (__world__.constants).target_reserve_now;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var target_single_flag2 = __init__ (__world__.constants).target_single_flag2;
                    var target_source = __init__ (__world__.constants).target_source;
                    var target_spawn_deposit = __init__ (__world__.constants).target_spawn_deposit;
                    var target_tower_fill = __init__ (__world__.constants).target_tower_fill;
                    var building = __init__ (__world__.creeps.roles.building);
                    var colonizing = __init__ (__world__.creeps.roles.colonizing);
                    var defensive = __init__ (__world__.creeps.roles.defensive);
                    var exploring = __init__ (__world__.creeps.roles.exploring);
                    var generic = __init__ (__world__.creeps.roles.generic);
                    var minerals = __init__ (__world__.creeps.roles.minerals);
                    var mining = __init__ (__world__.creeps.roles.mining);
                    var offensive = __init__ (__world__.creeps.roles.offensive);
                    var smart_offensive = __init__ (__world__.creeps.roles.smart_offensive);
                    var spawn_fill = __init__ (__world__.creeps.roles.spawn_fill);
                    var tower_fill = __init__ (__world__.creeps.roles.tower_fill);
                    var upgrading = __init__ (__world__.creeps.roles.upgrading);
                    var utility = __init__ (__world__.creeps.roles.utility);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var role_classes = {[role_upgrader]: upgrading.Upgrader, [role_spawn_fill]: spawn_fill.SpawnFill, [role_spawn_fill_backup]: spawn_fill.SpawnFill, [role_upgrade_fill]: upgrading.DedicatedUpgradeFiller, [role_link_manager]: utility.LinkManager, [role_builder]: building.Builder, [role_tower_fill]: tower_fill.TowerFill, [role_miner]: mining.EnergyMiner, [role_hauler]: mining.EnergyHauler, [role_remote_mining_reserve]: mining.RemoteReserve, [role_defender]: defensive.RoleDefender, [role_wall_defender]: defensive.WallDefender, [role_ranged_offense]: smart_offensive.KitingOffense, [role_cleanup]: utility.Cleanup, [role_temporary_replacing]: generic.ReplacingExpendedCreep, [role_colonist]: colonizing.Colonist, [role_simple_claim]: colonizing.Claim, [role_room_reserve]: colonizing.ReserveNow, [role_mineral_steal]: colonizing.MineralSteal, [role_recycling]: generic.Recycling, [role_mineral_miner]: minerals.MineralMiner, [role_mineral_hauler]: minerals.MineralHauler, [role_td_healer]: offensive.TowerDrainHealer, [role_td_goad]: offensive.TowerDrainer, [role_simple_dismantle]: offensive.Dismantler, [role_scout]: exploring.Scout, [role_power_attack]: offensive.PowerAttack, [role_power_cleanup]: offensive.PowerCleanup, [role_energy_grab]: offensive.EnergyGrab};
                    var wrap_creep = function (hive, targets, home, creep) {
                        var role = creep.memory.role;
                        if ((role in role_classes)) {
                            return role_classes [role] (hive, targets, home, creep);
                        }
                        else if ((role in old_role_names)) {
                            var __left0__ = old_role_names [role];
                            creep.memory.role = __left0__;
                            var role = __left0__;
                            return role_classes [role] (hive, targets, home, creep);
                        }
                        else {
                            return null;
                        }
                    };
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.roles.building' +
                        'creeps.roles.colonizing' +
                        'creeps.roles.defensive' +
                        'creeps.roles.exploring' +
                        'creeps.roles.generic' +
                        'creeps.roles.minerals' +
                        'creeps.roles.mining' +
                        'creeps.roles.offensive' +
                        'creeps.roles.smart_offensive' +
                        'creeps.roles.spawn_fill' +
                        'creeps.roles.tower_fill' +
                        'creeps.roles.upgrading' +
                        'creeps.roles.utility' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.DEPOT = DEPOT;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.PYFIND_BUILDABLE_ROADS = PYFIND_BUILDABLE_ROADS;
                        __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
                        __all__.PYFIND_REPAIRABLE_ROADS = PYFIND_REPAIRABLE_ROADS;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.REROUTE = REROUTE;
                        __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
                        __all__.RESERVE_NOW = RESERVE_NOW;
                        __all__.SCOUT = SCOUT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SK_USERNAME = SK_USERNAME;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__.building = building;
                        __all__.colonizing = colonizing;
                        __all__.creep_base_1500miner = creep_base_1500miner;
                        __all__.creep_base_3000miner = creep_base_3000miner;
                        __all__.creep_base_3h = creep_base_3h;
                        __all__.creep_base_4000miner = creep_base_4000miner;
                        __all__.creep_base_carry3000miner = creep_base_carry3000miner;
                        __all__.creep_base_claim_attack = creep_base_claim_attack;
                        __all__.creep_base_claiming = creep_base_claiming;
                        __all__.creep_base_defender = creep_base_defender;
                        __all__.creep_base_dismantler = creep_base_dismantler;
                        __all__.creep_base_full_move_dismantler = creep_base_full_move_dismantler;
                        __all__.creep_base_full_move_goader = creep_base_full_move_goader;
                        __all__.creep_base_full_move_healer = creep_base_full_move_healer;
                        __all__.creep_base_full_move_power_attack = creep_base_full_move_power_attack;
                        __all__.creep_base_full_upgrader = creep_base_full_upgrader;
                        __all__.creep_base_goader = creep_base_goader;
                        __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
                        __all__.creep_base_half_move_healer = creep_base_half_move_healer;
                        __all__.creep_base_hauler = creep_base_hauler;
                        __all__.creep_base_mammoth_miner = creep_base_mammoth_miner;
                        __all__.creep_base_power_attack = creep_base_power_attack;
                        __all__.creep_base_rampart_defense = creep_base_rampart_defense;
                        __all__.creep_base_ranged_offense = creep_base_ranged_offense;
                        __all__.creep_base_reserving = creep_base_reserving;
                        __all__.creep_base_scout = creep_base_scout;
                        __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
                        __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
                        __all__.creep_base_worker = creep_base_worker;
                        __all__.default_roles = default_roles;
                        __all__.defensive = defensive;
                        __all__.exploring = exploring;
                        __all__.generic = generic;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.gmem_key_last_room_state_refresh = gmem_key_last_room_state_refresh;
                        __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
                        __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
                        __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
                        __all__.minerals = minerals;
                        __all__.mining = mining;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.offensive = offensive;
                        __all__.old_role_names = old_role_names;
                        __all__.recycle_time = recycle_time;
                        __all__.request_priority_economy = request_priority_economy;
                        __all__.request_priority_helping_party = request_priority_helping_party;
                        __all__.request_priority_imminent_threat_defense = request_priority_imminent_threat_defense;
                        __all__.request_priority_low = request_priority_low;
                        __all__.rmem_key_building_paused = rmem_key_building_paused;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.rmem_key_cache = rmem_key_cache;
                        __all__.rmem_key_carry_parts_by_role = rmem_key_carry_parts_by_role;
                        __all__.rmem_key_creeps_by_role = rmem_key_creeps_by_role;
                        __all__.rmem_key_creeps_by_role_and_replacement_time = rmem_key_creeps_by_role_and_replacement_time;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                        __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
                        __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
                        __all__.rmem_key_flag_for_testing_spawning_in_simulation = rmem_key_flag_for_testing_spawning_in_simulation;
                        __all__.rmem_key_focusing_home = rmem_key_focusing_home;
                        __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
                        __all__.rmem_key_metadata = rmem_key_metadata;
                        __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
                        __all__.rmem_key_now_supporting = rmem_key_now_supporting;
                        __all__.rmem_key_pause_all_room_operations = rmem_key_pause_all_room_operations;
                        __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
                        __all__.rmem_key_prepping_defenses = rmem_key_prepping_defenses;
                        __all__.rmem_key_remotes_explicitly_marked_under_attack = rmem_key_remotes_explicitly_marked_under_attack;
                        __all__.rmem_key_remotes_safe_when_under_siege = rmem_key_remotes_safe_when_under_siege;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.rmem_key_spawn_requests = rmem_key_spawn_requests;
                        __all__.rmem_key_sponsor = rmem_key_sponsor;
                        __all__.rmem_key_storage_use_enabled = rmem_key_storage_use_enabled;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
                        __all__.rmem_key_total_open_source_spaces = rmem_key_total_open_source_spaces;
                        __all__.rmem_key_upgrading_paused = rmem_key_upgrading_paused;
                        __all__.rmem_key_work_parts_by_role = rmem_key_work_parts_by_role;
                        __all__.role_bases = role_bases;
                        __all__.role_builder = role_builder;
                        __all__.role_classes = role_classes;
                        __all__.role_cleanup = role_cleanup;
                        __all__.role_colonist = role_colonist;
                        __all__.role_defender = role_defender;
                        __all__.role_energy_grab = role_energy_grab;
                        __all__.role_hauler = role_hauler;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_miner = role_miner;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.role_mineral_miner = role_mineral_miner;
                        __all__.role_mineral_steal = role_mineral_steal;
                        __all__.role_power_attack = role_power_attack;
                        __all__.role_power_cleanup = role_power_cleanup;
                        __all__.role_ranged_offense = role_ranged_offense;
                        __all__.role_recycling = role_recycling;
                        __all__.role_remote_mining_reserve = role_remote_mining_reserve;
                        __all__.role_room_reserve = role_room_reserve;
                        __all__.role_scout = role_scout;
                        __all__.role_simple_claim = role_simple_claim;
                        __all__.role_simple_dismantle = role_simple_dismantle;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_spawn_fill_backup = role_spawn_fill_backup;
                        __all__.role_td_goad = role_td_goad;
                        __all__.role_td_healer = role_td_healer;
                        __all__.role_temporary_replacing = role_temporary_replacing;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.role_tower_fill_once = role_tower_fill_once;
                        __all__.role_upgrade_fill = role_upgrade_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.role_wall_defender = role_wall_defender;
                        __all__.smart_offensive = smart_offensive;
                        __all__.spawn_fill = spawn_fill;
                        __all__.target_big_big_repair = target_big_big_repair;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_construction = target_construction;
                        __all__.target_destruction_site = target_destruction_site;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                        __all__.target_home_flag = target_home_flag;
                        __all__.target_rampart_defense = target_rampart_defense;
                        __all__.target_refill = target_refill;
                        __all__.target_repair = target_repair;
                        __all__.target_reserve_now = target_reserve_now;
                        __all__.target_single_flag = target_single_flag;
                        __all__.target_single_flag2 = target_single_flag2;
                        __all__.target_source = target_source;
                        __all__.target_spawn_deposit = target_spawn_deposit;
                        __all__.target_tower_fill = target_tower_fill;
                        __all__.tower_fill = tower_fill;
                        __all__.upgrading = upgrading;
                        __all__.utility = utility;
                        __all__.wrap_creep = wrap_creep;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creep_management.deathwatch', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var movement = __init__ (__world__.utilities.movement);
                    var start_of_tick_check = function () {
                        if (Memory.deathwatch) {
                            var __iterable0__ = Memory.deathwatch;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var name = __left0__ [0];
                                var room_name = __left0__ [1];
                                var threats = __left0__ [2];
                                if (!(name in Game.creeps)) {
                                    if (!(_.every (threats, (function __lambda__ (t) {
                                        return t == INVADER_USERNAME || t == 'unknown';
                                    })))) {
                                        var threats = function () {
                                            var __accu0__ = [];
                                            var __iterable1__ = threats;
                                            for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                                var t = __iterable1__ [__index1__];
                                                __accu0__.append ((t == INVADER_USERNAME ? 'an invader' : t));
                                            }
                                            return __accu0__;
                                        } ();
                                        var msg = '[death] {}, a {} of {}, died, likely at the hands of {}.'.format (name, _.get (Memory, ['creeps', name, 'role'], 'creep'), room_name, (len (threats) > 1 ? '{} or {}'.format (', '.join (threats.__getslice__ (0, len (threats) - 1, 1)), threats [len (threats) - 1]) : threats [0]));
                                        print (msg);
                                        Game.notify (msg);
                                    }
                                    var meta = _.get (Memory, ['rooms', room_name, 'meta']);
                                    if (meta) {
                                        meta.clear_next = 0;
                                    }
                                }
                            }
                        }
                        Memory.deathwatch = [];
                    };
                    var mark_creeps = function (room) {
                        var hostiles = room.defense.dangerous_hostiles ();
                        var count = len (hostiles);
                        if (count > 3) {
                            var __iterable0__ = room.find (FIND_MY_CREEPS);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var creep = __iterable0__ [__index0__];
                                Memory.deathwatch.append ([creep.name, creep.memory.home, _ (hostiles).map ((function __lambda__ (h) {
                                    return _.get (h, ['owner', 'username'], 'unknown');
                                })).uniq ().value ()]);
                            }
                        }
                        else {
                            var __iterable0__ = room.find (FIND_MY_CREEPS);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var creep = __iterable0__ [__index0__];
                                if (_.some (hostiles, (function __lambda__ (h) {
                                    return movement.chebyshev_distance_room_pos (h, creep) < 4;
                                }))) {
                                    Memory.deathwatch.append ([creep.name, creep.memory.home, _ (hostiles).filter ((function __lambda__ (h) {
                                        return movement.chebyshev_distance_room_pos (h, creep) < 4;
                                    })).map ((function __lambda__ (h) {
                                        return _.get (h, ['owner, username'], 'unknown');
                                    })).uniq ().value ()]);
                                }
                            }
                        }
                    };
                    __pragma__ ('<use>' +
                        'constants' +
                        'jstools.screeps_constants' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.mark_creeps = mark_creeps;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.start_of_tick_check = start_of_tick_check;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creep_management.mining_paths', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var gmem_key_room_mining_paths = __init__ (__world__.constants).gmem_key_room_mining_paths;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var no_spawn_name_name = 'none';
                    var _get_mem = function () {
                        if ((gmem_key_room_mining_paths in Memory)) {
                            return Memory [gmem_key_room_mining_paths];
                        }
                        else {
                            var __left0__ = {};
                            var mem = __left0__;
                            Memory [gmem_key_room_mining_paths] = __left0__;
                            return mem;
                        }
                    };
                    var _parse_mine_data = function (mine_data) {
                        if (_.isArray (mine_data)) {
                            if (len (mine_data) > 2 || len (mine_data) < 1 || !(mine_data [0].name) || mine_data [1] && !(mine_data [1].id)) {
                                var msg = '[mining_paths] WARNING: Unknown kind of mine data: {} ({}, {})'.format (JSON.stringify (mine_data), mine_data [0], mine_data [1]);
                                print (msg);
                                Game.notify (msg);
                                return [null, null];
                            }
                            var mine_name = mine_data [0].name;
                            var spawn_id = (mine_data [1] ? mine_data [1].id : no_spawn_name_name);
                        }
                        else {
                            if (!(mine_data.name)) {
                                var msg = '[mining_paths] WARNING: Unknown kind of mine data: {} ({})'.format (JSON.stringify (mine_data), mine_data);
                                print (msg);
                                Game.notify (msg);
                                return [null, null];
                            }
                            var mine_name = mine_data.name;
                            var spawn_id = no_spawn_name_name;
                        }
                        return [mine_name, spawn_id];
                    };
                    var register_new_mining_path = function (mine_data, raw_path) {
                        var __left0__ = _parse_mine_data (mine_data);
                        var mine_name = __left0__ [0];
                        var spawn_id = __left0__ [1];
                        if (mine_name === null || spawn_id === null) {
                            var __except0__ = ValueError ('Invalid mine data ({}): no name/id'.format (mine_data));
                            __except0__.__cause__ = null;
                            throw __except0__;
                        }
                        var serialized_string = [];
                        if (len (raw_path)) {
                            var last_room = raw_path [0].roomName;
                            var room_pos_points = {[last_room]: serialized_string};
                            var __iterable0__ = raw_path;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var pos = __iterable0__ [__index0__];
                                if (pos.roomName != last_room) {
                                    if ((pos.roomName in room_pos_points)) {
                                        var serialized_string = room_pos_points [pos.roomName];
                                    }
                                    else {
                                        var __left0__ = [];
                                        var serialized_string = __left0__;
                                        room_pos_points [pos.roomName] = __left0__;
                                    }
                                    var last_room = pos.roomName;
                                }
                                serialized_string.push (String.fromCodePoint (pos.x | pos.y << 6));
                            }
                        }
                        else {
                            var room_pos_points = {};
                        }
                        var our_key_start = ((String.fromCodePoint ((len (mine_name) + len (spawn_id)) + 2) + String.fromCodePoint (len (mine_name))) + mine_name) + spawn_id;
                        var gmem = _get_mem ();
                        var rooms_this_is_in = Object.keys (room_pos_points);
                        var __iterable0__ = rooms_this_is_in;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var room_name = __iterable0__ [__index0__];
                            var our_data = our_key_start + ''.join (room_pos_points [room_name]);
                            if ((room_name in gmem)) {
                                var data_array = gmem [room_name];
                                _.remove (data_array, (function __lambda__ (x) {
                                    return x.startsWith (our_key_start);
                                }));
                                data_array.push (our_data);
                            }
                            else {
                                gmem [room_name] = [our_data];
                            }
                        }
                        var __iterable0__ = Object.keys (gmem);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var room_name = __iterable0__ [__index0__];
                            if (!(rooms_this_is_in.includes (room_name))) {
                                var data_list = gmem [room_name];
                                _.remove (data_list, (function __lambda__ (x) {
                                    return x.startsWith (our_key_start);
                                }));
                                if (!(len (data_list))) {
                                    delete gmem [room_name];
                                }
                            }
                        }
                    };
                    var get_set_of_all_serialized_positions_in = function (room_name) {
                        var the_set = new_set ();
                        var gmem = _get_mem ();
                        if (!(room_name in gmem)) {
                            return the_set;
                        }
                        var __iterable0__ = gmem [room_name];
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var data_string = __iterable0__ [__index0__];
                            var points = data_string.__getslice__ (data_string.codePointAt (0), null, 1);
                            for (var i = 0; i < len (points); i++) {
                                var xy = points.codePointAt (i);
                                the_set.add (xy);
                            }
                        }
                        return the_set;
                    };
                    var debug_str = function (room_name) {
                        var map_of_values = new_map ();
                        var gmem = _get_mem ();
                        if (!(room_name in gmem)) {
                            return map_of_values;
                        }
                        var __iterable0__ = gmem [room_name];
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var data_string = __iterable0__ [__index0__];
                            var points = data_string.__getslice__ (data_string.codePointAt (0), null, 1);
                            for (var i = 0; i < len (points); i++) {
                                var xy = points.codePointAt (i);
                                if (map_of_values.has (xy)) {
                                    map_of_values.set (xy, map_of_values.get (xy) + 1);
                                }
                                else {
                                    map_of_values.set (xy, 1);
                                }
                            }
                        }
                        var output = [];
                        for (var y = 0; y < 50; y++) {
                            output.push ('\n');
                            for (var x = 0; x < 50; x++) {
                                var xy = x | y << 6;
                                var value = map_of_values.get (xy);
                                if (value) {
                                    output.push (value);
                                }
                                else {
                                    output.push (' ');
                                }
                                output.push (' ');
                            }
                            output.py_pop ();
                        }
                        return ''.join (output);
                    };
                    var set_decreasing_cost_matrix_costs = function (room_name, mine_path_data, cost_matrix, base_plains, base_swamp, lowest_possible) {
                        var lowest_possible = max (lowest_possible, 1);
                        var __left0__ = _parse_mine_data (mine_path_data);
                        var mine_name = __left0__ [0];
                        var spawn_id = __left0__ [1];
                        if (mine_name === null || spawn_id === null) {
                            return ;
                        }
                        var key_to_avoid = ((String.fromCodePoint ((len (mine_name) + len (spawn_id)) + 2) + String.fromCodePoint (len (mine_name))) + mine_name) + spawn_id;
                        var gmem = _get_mem ();
                        if (!(room_name in gmem)) {
                            return ;
                        }
                        var __iterable0__ = gmem [room_name];
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var data_string = __iterable0__ [__index0__];
                            if (data_string.startsWith (key_to_avoid)) {
                                continue;
                            }
                            var points = data_string.__getslice__ (data_string.codePointAt (0), null, 1);
                            for (var i = 0; i < len (points); i++) {
                                var xy = points.codePointAt (i);
                                var x = xy & 63;
                                var y = xy >> 6 & 63;
                                var existing = cost_matrix.get (x, y);
                                if (existing == 0) {
                                    var terrain = Game.map.getTerrainAt (x, y, room_name);
                                    if (terrain [0] == 'p') {
                                        var existing = base_plains;
                                    }
                                    else if (terrain [0] == 's') {
                                        var existing = base_swamp;
                                    }
                                    else {
                                        continue;
                                    }
                                }
                                if (existing > lowest_possible) {
                                    cost_matrix.set (x, y, existing - 1);
                                }
                            }
                        }
                    };
                    var set_slightly_increased_cost = function (room_name, cost_matrix, base_plains, base_swamp, increase_by) {
                        var gmem = _get_mem ();
                        if (!(room_name in gmem)) {
                            return ;
                        }
                        var roads_added = new_set ();
                        var __iterable0__ = gmem [room_name];
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var data_string = __iterable0__ [__index0__];
                            var points = data_string.__getslice__ (data_string.codePointAt (0), null, 1);
                            for (var i = 0; i < len (points); i++) {
                                var xy = points.codePointAt (i);
                                if (roads_added.has (xy)) {
                                    continue;
                                }
                                roads_added.add (xy);
                                var x = xy & 63;
                                var y = xy >> 6 & 63;
                                var existing = cost_matrix.get (x, y);
                                if (existing == 0) {
                                    var terrain = Game.map.getTerrainAt (x, y, room_name);
                                    if (terrain [0] == 'p') {
                                        var existing = base_plains;
                                    }
                                    else if (terrain [0] == 's') {
                                        var existing = base_swamp;
                                    }
                                    else {
                                        continue;
                                    }
                                }
                                cost_matrix.set (x, y, existing + increase_by);
                            }
                        }
                    };
                    var cleanup_old_values = function (hive) {
                        var active_mines = new_set ();
                        var __iterable0__ = hive.my_rooms;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var room = __iterable0__ [__index0__];
                            var __iterable1__ = room.mining.active_mines;
                            for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                var mine = __iterable1__ [__index1__];
                                active_mines.add (mine.name);
                            }
                        }
                        var path_mem = _get_mem ();
                        var __iterable0__ = Object.keys (path_mem);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var room_name = __iterable0__ [__index0__];
                            var data_list = path_mem [room_name];
                            var to_remove_indices = [];
                            var __iterable1__ = enumerate (data_list);
                            for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                var __left0__ = __iterable1__ [__index1__];
                                var index = __left0__ [0];
                                var data_string = __left0__ [1];
                                var end_of_name_data = data_string.codePointAt (0);
                                var mine_name_length = data_string.codePointAt (1);
                                var mine_name = data_string.__getslice__ (2, 2 + mine_name_length, 1);
                                var spawn_id = data_string.__getslice__ (2 + mine_name_length, end_of_name_data, 1);
                                if (!(active_mines.has (mine_name)) || spawn_id != no_spawn_name_name && Game.getObjectById (spawn_id) === null) {
                                    to_remove_indices.push (index);
                                    print ('[mining_paths] Removing path in {} for mine: {}, spawn: {}.'.format (room_name, mine_name, spawn_id));
                                }
                            }
                            _.pullAt (data_list, to_remove_indices);
                            if (!(len (data_list))) {
                                delete path_mem [room_name];
                            }
                        }
                    };
                    __pragma__ ('<use>' +
                        'constants' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__._get_mem = _get_mem;
                        __all__._parse_mine_data = _parse_mine_data;
                        __all__.cleanup_old_values = cleanup_old_values;
                        __all__.debug_str = debug_str;
                        __all__.get_set_of_all_serialized_positions_in = get_set_of_all_serialized_positions_in;
                        __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.no_spawn_name_name = no_spawn_name_name;
                        __all__.register_new_mining_path = register_new_mining_path;
                        __all__.set_decreasing_cost_matrix_costs = set_decreasing_cost_matrix_costs;
                        __all__.set_slightly_increased_cost = set_slightly_increased_cost;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creep_management.spawning', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var floor = __init__ (__world__.math).floor;
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
                    var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
                    var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
                    var PYFIND_BUILDABLE_ROADS = __init__ (__world__.constants).PYFIND_BUILDABLE_ROADS;
                    var PYFIND_HURT_CREEPS = __init__ (__world__.constants).PYFIND_HURT_CREEPS;
                    var PYFIND_REPAIRABLE_ROADS = __init__ (__world__.constants).PYFIND_REPAIRABLE_ROADS;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var REROUTE = __init__ (__world__.constants).REROUTE;
                    var REROUTE_DESTINATION = __init__ (__world__.constants).REROUTE_DESTINATION;
                    var RESERVE_NOW = __init__ (__world__.constants).RESERVE_NOW;
                    var SCOUT = __init__ (__world__.constants).SCOUT;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var SK_USERNAME = __init__ (__world__.constants).SK_USERNAME;
                    var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
                    var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
                    var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
                    var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
                    var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var creep_base_1500miner = __init__ (__world__.constants).creep_base_1500miner;
                    var creep_base_3000miner = __init__ (__world__.constants).creep_base_3000miner;
                    var creep_base_3h = __init__ (__world__.constants).creep_base_3h;
                    var creep_base_4000miner = __init__ (__world__.constants).creep_base_4000miner;
                    var creep_base_carry3000miner = __init__ (__world__.constants).creep_base_carry3000miner;
                    var creep_base_claim_attack = __init__ (__world__.constants).creep_base_claim_attack;
                    var creep_base_claiming = __init__ (__world__.constants).creep_base_claiming;
                    var creep_base_defender = __init__ (__world__.constants).creep_base_defender;
                    var creep_base_dismantler = __init__ (__world__.constants).creep_base_dismantler;
                    var creep_base_full_move_dismantler = __init__ (__world__.constants).creep_base_full_move_dismantler;
                    var creep_base_full_move_goader = __init__ (__world__.constants).creep_base_full_move_goader;
                    var creep_base_full_move_healer = __init__ (__world__.constants).creep_base_full_move_healer;
                    var creep_base_full_move_power_attack = __init__ (__world__.constants).creep_base_full_move_power_attack;
                    var creep_base_full_upgrader = __init__ (__world__.constants).creep_base_full_upgrader;
                    var creep_base_goader = __init__ (__world__.constants).creep_base_goader;
                    var creep_base_half_move_hauler = __init__ (__world__.constants).creep_base_half_move_hauler;
                    var creep_base_half_move_healer = __init__ (__world__.constants).creep_base_half_move_healer;
                    var creep_base_hauler = __init__ (__world__.constants).creep_base_hauler;
                    var creep_base_mammoth_miner = __init__ (__world__.constants).creep_base_mammoth_miner;
                    var creep_base_power_attack = __init__ (__world__.constants).creep_base_power_attack;
                    var creep_base_rampart_defense = __init__ (__world__.constants).creep_base_rampart_defense;
                    var creep_base_ranged_offense = __init__ (__world__.constants).creep_base_ranged_offense;
                    var creep_base_reserving = __init__ (__world__.constants).creep_base_reserving;
                    var creep_base_scout = __init__ (__world__.constants).creep_base_scout;
                    var creep_base_work_full_move_hauler = __init__ (__world__.constants).creep_base_work_full_move_hauler;
                    var creep_base_work_half_move_hauler = __init__ (__world__.constants).creep_base_work_half_move_hauler;
                    var creep_base_worker = __init__ (__world__.constants).creep_base_worker;
                    var default_roles = __init__ (__world__.constants).default_roles;
                    var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
                    var gmem_key_last_room_state_refresh = __init__ (__world__.constants).gmem_key_last_room_state_refresh;
                    var gmem_key_room_mining_paths = __init__ (__world__.constants).gmem_key_room_mining_paths;
                    var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
                    var max_repave_mine_roads_every = __init__ (__world__.constants).max_repave_mine_roads_every;
                    var min_repath_mine_roads_every = __init__ (__world__.constants).min_repath_mine_roads_every;
                    var min_repave_mine_roads_every = __init__ (__world__.constants).min_repave_mine_roads_every;
                    var old_role_names = __init__ (__world__.constants).old_role_names;
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var request_priority_economy = __init__ (__world__.constants).request_priority_economy;
                    var request_priority_helping_party = __init__ (__world__.constants).request_priority_helping_party;
                    var request_priority_imminent_threat_defense = __init__ (__world__.constants).request_priority_imminent_threat_defense;
                    var request_priority_low = __init__ (__world__.constants).request_priority_low;
                    var rmem_key_building_paused = __init__ (__world__.constants).rmem_key_building_paused;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
                    var rmem_key_cache = __init__ (__world__.constants).rmem_key_cache;
                    var rmem_key_carry_parts_by_role = __init__ (__world__.constants).rmem_key_carry_parts_by_role;
                    var rmem_key_creeps_by_role = __init__ (__world__.constants).rmem_key_creeps_by_role;
                    var rmem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants).rmem_key_creeps_by_role_and_replacement_time;
                    var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
                    var rmem_key_defense_mind_storage = __init__ (__world__.constants).rmem_key_defense_mind_storage;
                    var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants).rmem_key_empty_all_resources_into_room;
                    var rmem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants).rmem_key_flag_for_testing_spawning_in_simulation;
                    var rmem_key_focusing_home = __init__ (__world__.constants).rmem_key_focusing_home;
                    var rmem_key_linking_mind_storage = __init__ (__world__.constants).rmem_key_linking_mind_storage;
                    var rmem_key_metadata = __init__ (__world__.constants).rmem_key_metadata;
                    var rmem_key_mineral_mind_storage = __init__ (__world__.constants).rmem_key_mineral_mind_storage;
                    var rmem_key_now_supporting = __init__ (__world__.constants).rmem_key_now_supporting;
                    var rmem_key_pause_all_room_operations = __init__ (__world__.constants).rmem_key_pause_all_room_operations;
                    var rmem_key_planned_role_to_spawn = __init__ (__world__.constants).rmem_key_planned_role_to_spawn;
                    var rmem_key_prepping_defenses = __init__ (__world__.constants).rmem_key_prepping_defenses;
                    var rmem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants).rmem_key_remotes_explicitly_marked_under_attack;
                    var rmem_key_remotes_safe_when_under_siege = __init__ (__world__.constants).rmem_key_remotes_safe_when_under_siege;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
                    var rmem_key_spawn_requests = __init__ (__world__.constants).rmem_key_spawn_requests;
                    var rmem_key_sponsor = __init__ (__world__.constants).rmem_key_sponsor;
                    var rmem_key_storage_use_enabled = __init__ (__world__.constants).rmem_key_storage_use_enabled;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
                    var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants).rmem_key_there_might_be_energy_lying_around;
                    var rmem_key_total_open_source_spaces = __init__ (__world__.constants).rmem_key_total_open_source_spaces;
                    var rmem_key_upgrading_paused = __init__ (__world__.constants).rmem_key_upgrading_paused;
                    var rmem_key_work_parts_by_role = __init__ (__world__.constants).rmem_key_work_parts_by_role;
                    var role_bases = __init__ (__world__.constants).role_bases;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_cleanup = __init__ (__world__.constants).role_cleanup;
                    var role_colonist = __init__ (__world__.constants).role_colonist;
                    var role_defender = __init__ (__world__.constants).role_defender;
                    var role_energy_grab = __init__ (__world__.constants).role_energy_grab;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_link_manager = __init__ (__world__.constants).role_link_manager;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
                    var role_mineral_miner = __init__ (__world__.constants).role_mineral_miner;
                    var role_mineral_steal = __init__ (__world__.constants).role_mineral_steal;
                    var role_power_attack = __init__ (__world__.constants).role_power_attack;
                    var role_power_cleanup = __init__ (__world__.constants).role_power_cleanup;
                    var role_ranged_offense = __init__ (__world__.constants).role_ranged_offense;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_remote_mining_reserve = __init__ (__world__.constants).role_remote_mining_reserve;
                    var role_room_reserve = __init__ (__world__.constants).role_room_reserve;
                    var role_scout = __init__ (__world__.constants).role_scout;
                    var role_simple_claim = __init__ (__world__.constants).role_simple_claim;
                    var role_simple_dismantle = __init__ (__world__.constants).role_simple_dismantle;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_spawn_fill_backup = __init__ (__world__.constants).role_spawn_fill_backup;
                    var role_td_goad = __init__ (__world__.constants).role_td_goad;
                    var role_td_healer = __init__ (__world__.constants).role_td_healer;
                    var role_temporary_replacing = __init__ (__world__.constants).role_temporary_replacing;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var role_tower_fill_once = __init__ (__world__.constants).role_tower_fill_once;
                    var role_upgrade_fill = __init__ (__world__.constants).role_upgrade_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var role_wall_defender = __init__ (__world__.constants).role_wall_defender;
                    var target_big_big_repair = __init__ (__world__.constants).target_big_big_repair;
                    var target_big_repair = __init__ (__world__.constants).target_big_repair;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var target_construction = __init__ (__world__.constants).target_construction;
                    var target_destruction_site = __init__ (__world__.constants).target_destruction_site;
                    var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
                    var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
                    var target_home_flag = __init__ (__world__.constants).target_home_flag;
                    var target_rampart_defense = __init__ (__world__.constants).target_rampart_defense;
                    var target_refill = __init__ (__world__.constants).target_refill;
                    var target_repair = __init__ (__world__.constants).target_repair;
                    var target_reserve_now = __init__ (__world__.constants).target_reserve_now;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var target_single_flag2 = __init__ (__world__.constants).target_single_flag2;
                    var target_source = __init__ (__world__.constants).target_source;
                    var target_spawn_deposit = __init__ (__world__.constants).target_spawn_deposit;
                    var target_tower_fill = __init__ (__world__.constants).target_tower_fill;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var naming = __init__ (__world__.utilities.naming);
                    var initial_section = {[creep_base_work_full_move_hauler]: [WORK, WORK, MOVE, MOVE], [creep_base_work_half_move_hauler]: [WORK, WORK, MOVE], [creep_base_goader]: [ATTACK, MOVE, TOUGH], [creep_base_full_move_goader]: [ATTACK, MOVE], [creep_base_full_upgrader]: [MOVE, CARRY, CARRY], [creep_base_1500miner]: [WORK, WORK, WORK], [creep_base_3000miner]: [WORK, WORK, WORK, WORK, WORK], [creep_base_4000miner]: [WORK, WORK, WORK, WORK, WORK, WORK, WORK], [creep_base_carry3000miner]: [CARRY, WORK, WORK, WORK, WORK, WORK], [creep_base_mammoth_miner]: [MOVE, CARRY, WORK, WORK, WORK], [creep_base_ranged_offense]: [MOVE, HEAL], [creep_base_3h]: [MOVE, MOVE, MOVE, HEAL, HEAL, HEAL]};
                    var scalable_sections = {[creep_base_worker]: [MOVE, MOVE, MOVE, MOVE, CARRY, CARRY, CARRY, WORK], [creep_base_hauler]: [MOVE, CARRY], [creep_base_work_full_move_hauler]: [MOVE, CARRY], [creep_base_work_half_move_hauler]: [MOVE, CARRY, CARRY], [creep_base_reserving]: [MOVE, CLAIM], [creep_base_defender]: [TOUGH, MOVE, MOVE, MOVE, ATTACK, ATTACK], [creep_base_rampart_defense]: [MOVE, ATTACK, ATTACK], [creep_base_ranged_offense]: [MOVE, RANGED_ATTACK], [creep_base_3h]: [MOVE, RANGED_ATTACK], [creep_base_1500miner]: [MOVE], [creep_base_3000miner]: [MOVE], [creep_base_4000miner]: [MOVE], [creep_base_carry3000miner]: [MOVE], [creep_base_goader]: [MOVE, TOUGH, TOUGH], [creep_base_full_move_goader]: [MOVE, TOUGH, CARRY, CARRY], [creep_base_half_move_healer]: [MOVE, HEAL, HEAL], [creep_base_full_move_healer]: [MOVE, HEAL], [creep_base_dismantler]: [WORK, WORK, MOVE], [creep_base_full_move_dismantler]: [WORK, MOVE], [creep_base_full_upgrader]: [MOVE, WORK, WORK], [creep_base_scout]: [MOVE], [creep_base_mammoth_miner]: [MOVE, WORK, WORK, WORK, WORK], [creep_base_full_move_power_attack]: [MOVE, ATTACK], [creep_base_power_attack]: [MOVE, MOVE, TOUGH, ATTACK, ATTACK, ATTACK], [creep_base_half_move_hauler]: [MOVE, CARRY, CARRY], [creep_base_claiming]: [MOVE, MOVE, MOVE, CLAIM, MOVE], [creep_base_claim_attack]: [MOVE, MOVE, MOVE, MOVE, MOVE, CLAIM, CLAIM, CLAIM, CLAIM, CLAIM]};
                    var half_sections = {[creep_base_worker]: [WORK, MOVE], [creep_base_work_half_move_hauler]: [MOVE, CARRY], [creep_base_half_move_hauler]: [MOVE, CARRY], [creep_base_full_upgrader]: [MOVE, WORK], [creep_base_defender]: [ATTACK, MOVE], [creep_base_rampart_defense]: [ATTACK, MOVE], [creep_base_goader]: [TOUGH, MOVE], [creep_base_half_move_healer]: [MOVE, HEAL], [creep_base_power_attack]: [MOVE, ATTACK], [creep_base_dismantler]: [MOVE, WORK], [creep_base_claim_attack]: [MOVE, MOVE, TOUGH, HEAL], [creep_base_3h]: [MOVE, MOVE, TOUGH, TOUGH]};
                    var low_energy_sections = {[creep_base_worker]: [MOVE, MOVE, CARRY, WORK], [creep_base_full_upgrader]: [MOVE, CARRY, WORK], [creep_base_claiming]: [MOVE, CLAIM, MOVE]};
                    var low_energy_dynamic = [creep_base_1500miner, creep_base_3000miner, creep_base_4000miner];
                    var would_be_emergency = function (room) {
                        var spawn_mass = (room.carry_mass_of (role_spawn_fill) + room.carry_mass_of (role_spawn_fill_backup)) + room.carry_mass_of (role_tower_fill);
                        return spawn_mass <= 0 || spawn_mass < room.get_target_total_spawn_fill_mass () / 2;
                    };
                    var emergency_conditions = function (room) {
                        if (volatile_cache.mem (room.name).has ('emergency_conditions')) {
                            return volatile_cache.mem (room.name).get ('emergency_conditions');
                        }
                        volatile_cache.mem (room.name).set ('emergency_conditions', false);
                        if (room.room.energyAvailable >= 300) {
                            var spawn_mass = (room.carry_mass_of (role_spawn_fill) + room.carry_mass_of (role_spawn_fill_backup)) + room.carry_mass_of (role_tower_fill);
                            var emergency = spawn_mass <= 0 || spawn_mass < room.get_target_total_spawn_fill_mass () / 2 && room.room.energyAvailable >= 100 * spawn_mass;
                        }
                        else {
                            var emergency = false;
                        }
                        volatile_cache.mem (room.name).delete ('running_emergency_conditions');
                        volatile_cache.mem (room.name).set ('emergency_conditions', emergency);
                        return emergency;
                    };
                    var run = function (room, spawn) {
                        if (spawn.spawning) {
                            return ;
                        }
                        var role_obj = room.get_next_role ();
                        if (!(role_obj)) {
                            return ;
                        }
                        var role = role_obj.role;
                        var base = role_obj.base;
                        var num_sections = role_obj.num_sections || 0;
                        var replacing = role_obj.replacing;
                        var ubos_cache = volatile_cache.mem ('energy_used_by_other_spawns');
                        if (ubos_cache.has (room.name)) {
                            var filled = spawn.room.energyAvailable - ubos_cache.get (room.name);
                        }
                        else {
                            var filled = spawn.room.energyAvailable;
                        }
                        if (emergency_conditions (room)) {
                            print ('[{}] WARNING: Bootstrapping room!'.format (room.name));
                            var energy = filled;
                        }
                        else {
                            var energy = spawn.room.energyCapacityAvailable;
                        }
                        var half_section = (__mod__ (num_sections, 1) ? 1 : 0);
                        num_sections -= __mod__ (num_sections, 1);
                        if (num_sections !== null && (base in scalable_sections)) {
                            if ((num_sections <= 0 || !(num_sections)) && !(num_sections === 0 && half_section)) {
                                print ('[{}][spawning] Trying to spawn a 0-section {} creep! Changing this to a 1-section creep!'.format (room.name, base));
                                var num_sections = 1;
                                role_obj.num_sections = 1;
                            }
                            var cost = cost_of_sections (base, num_sections, energy) + half_section * half_section_cost (base);
                            if (!(cost)) {
                                print ('[{}][spawning] ERROR: Unknown cost retrieved from cost_of_sections({}, {}, {}): {}'.format (room.name, base, num_sections, energy, cost));
                                var cost = Infinity;
                            }
                            if (cost > energy) {
                                var new_size = max_sections_of (room, base);
                                if (new_size <= 0) {
                                    if (low_energy_dynamic.includes (base)) {
                                        var cost = energy;
                                    }
                                    else {
                                        print ("[{}][spawning] ERROR: Trying to spawn a {}, which we don't have enough energy for even 1 section of!".format (room.name, base));
                                        return ;
                                    }
                                }
                                else {
                                    print ('[{}][spawning] Adjusted creep size from {} to {} to match available energy.'.format (room.name, num_sections, new_size));
                                    var __left0__ = new_size;
                                    var num_sections = __left0__;
                                    role_obj.num_sections = __left0__;
                                    var half_section = (__mod__ (num_sections, 1) ? 1 : 0);
                                    num_sections -= __mod__ (num_sections, 1);
                                    var cost = cost_of_sections (base, num_sections, energy) + half_section * half_section_cost (base);
                                }
                            }
                            var energy = cost;
                        }
                        if (filled < energy) {
                            return ;
                        }
                        var descriptive_level = null;
                        if (base === creep_base_1500miner) {
                            var parts = [];
                            var work_cost = BODYPART_COST [WORK];
                            var move_cost = BODYPART_COST [MOVE];
                            if (energy < work_cost * 3 + move_cost) {
                                print ('[{}][spawning] Building sub-optimal dedicated miner!'.format (room.name));
                                var num_work = math.floor ((energy - move_cost) / work_cost);
                                var num_move = math.floor ((energy - num_work * work_cost) / move_cost);
                            }
                            else {
                                var num_move = num_sections || 3;
                                var num_work = 3;
                            }
                            for (var i = 0; i < num_work; i++) {
                                parts.append (WORK);
                            }
                            for (var i = 0; i < num_move; i++) {
                                parts.append (MOVE);
                            }
                            var descriptive_level = 'work:{}-move:{}'.format (num_work, num_move);
                        }
                        else if (base === creep_base_3000miner) {
                            var work_cost = BODYPART_COST [WORK];
                            var move_cost = BODYPART_COST [MOVE];
                            var parts = [];
                            if (energy < work_cost * 5 + move_cost) {
                                print ('[{}][spawning] Building sub-optimal dedicated miner!'.format (room.name));
                                var num_work = math.floor ((energy - move_cost) / work_cost);
                                var num_move = math.floor ((energy - num_work * work_cost) / move_cost);
                            }
                            else {
                                var num_move = num_sections || 5;
                                var num_work = 5;
                            }
                            for (var i = 0; i < num_work; i++) {
                                parts.append (WORK);
                            }
                            for (var i = 0; i < num_move; i++) {
                                parts.append (MOVE);
                            }
                            var descriptive_level = 'work:{}-move:{}'.format (num_work, num_move);
                        }
                        else if (base === creep_base_4000miner) {
                            var work_cost = BODYPART_COST [WORK];
                            var move_cost = BODYPART_COST [MOVE];
                            var parts = [];
                            if (energy < work_cost * 7 + move_cost) {
                                print ('[{}][spawning] Building sub-optimal dedicated miner!'.format (room.name));
                                var num_work = math.floor ((energy - move_cost) / work_cost);
                                var num_move = math.floor ((energy - num_work * work_cost) / move_cost);
                            }
                            else {
                                var num_move = num_sections || 7;
                                var num_work = 7;
                            }
                            for (var i = 0; i < num_work; i++) {
                                parts.append (WORK);
                            }
                            for (var i = 0; i < num_move; i++) {
                                parts.append (MOVE);
                            }
                            var descriptive_level = 'work:{}-move:{}'.format (num_work, num_move);
                        }
                        else if (base === creep_base_carry3000miner) {
                            var work_cost = BODYPART_COST [WORK];
                            var move_cost = BODYPART_COST [MOVE];
                            var carry_cost = BODYPART_COST [CARRY];
                            if (energy < (work_cost * 5 + move_cost) + carry_cost) {
                                print ('[{}][spawning] Too few extensions to build a dedicated 3000 miner with carry!'.format (room.name));
                                if (__mod__ (Game.time, 30) == 3) {
                                    room.reset_planned_role ();
                                }
                                return ;
                            }
                            var parts = [];
                            var num_move = num_sections || 5;
                            var num_work = 5;
                            for (var i = 0; i < num_work; i++) {
                                parts.append (WORK);
                            }
                            parts.append (CARRY);
                            for (var i = 0; i < num_move; i++) {
                                parts.append (MOVE);
                            }
                            var descriptive_level = num_move;
                        }
                        else if (base === creep_base_reserving) {
                            var parts = [];
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (CLAIM);
                            }
                            var descriptive_level = num_sections;
                        }
                        else if (base === creep_base_claiming) {
                            var claim_cost = BODYPART_COST [CLAIM];
                            var move_cost = BODYPART_COST [MOVE];
                            if (energy >= claim_cost + move_cost * 4) {
                                var parts = [MOVE, MOVE, MOVE, CLAIM, MOVE];
                            }
                            else if (energy >= claim_cost + move_cost * 2) {
                                var parts = [MOVE, CLAIM, MOVE];
                            }
                            else if (energy > claim_cost + move_cost) {
                                var parts = [CLAIM, MOVE];
                            }
                            else {
                                print ('[{}][spawning] Too few extensions to build a claim creep!'.format (room.name));
                                if (__mod__ (Game.time, 30) == 3) {
                                    room.reset_planned_role ();
                                }
                                return ;
                            }
                        }
                        else if (base === creep_base_claim_attack) {
                            var parts = [];
                            for (var i = 0; i < half_section; i++) {
                                parts.append (TOUGH);
                            }
                            for (var i = 0; i < num_sections * 5; i++) {
                                parts.append (CLAIM);
                            }
                            for (var i = 0; i < num_sections * 5 + half_section * 2; i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < half_section; i++) {
                                parts.append (HEAL);
                            }
                            if (half_section) {
                                var descriptive_level = 'claim:{}-heal:{}'.format (num_sections * 5, half_section);
                            }
                            else {
                                var descriptive_level = 'claim:{}'.format (num_sections);
                            }
                        }
                        else if (base === creep_base_hauler) {
                            var parts = [];
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (CARRY);
                            }
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (MOVE);
                            }
                            var descriptive_level = num_sections;
                        }
                        else if (base === creep_base_half_move_hauler) {
                            var parts = [];
                            for (var i = 0; i < num_sections * 2 + half_section; i++) {
                                parts.append (CARRY);
                            }
                            for (var i = 0; i < num_sections + half_section; i++) {
                                parts.append (MOVE);
                            }
                            var descriptive_level = num_sections;
                        }
                        else if (base === creep_base_work_full_move_hauler) {
                            var parts = [];
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (CARRY);
                            }
                            var __iterable0__ = initial_section [base];
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var part = __iterable0__ [__index0__];
                                parts.append (part);
                            }
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (MOVE);
                            }
                            var descriptive_level = num_sections;
                        }
                        else if (base === creep_base_work_half_move_hauler) {
                            var parts = [];
                            for (var i = 0; i < num_sections * 2 + half_section; i++) {
                                parts.append (CARRY);
                            }
                            var __iterable0__ = initial_section [base];
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var part = __iterable0__ [__index0__];
                                parts.append (part);
                            }
                            for (var i = 0; i < num_sections + half_section; i++) {
                                parts.append (MOVE);
                            }
                            var descriptive_level = num_sections * 2 + 1;
                        }
                        else if (base === creep_base_worker) {
                            var move_cost = BODYPART_COST [MOVE];
                            var carry_cost = BODYPART_COST [CARRY];
                            var work_cost = BODYPART_COST [WORK];
                            if (energy >= (move_cost * 4 + carry_cost * 3) + work_cost) {
                                var parts = [];
                                for (var i = 0; i < num_sections; i++) {
                                    parts.append (CARRY);
                                    parts.append (CARRY);
                                    parts.append (CARRY);
                                    parts.append (MOVE);
                                }
                                for (var i = 0; i < num_sections + half_section; i++) {
                                    parts.append (WORK);
                                }
                                for (var i = 0; i < num_sections * 3 + half_section; i++) {
                                    parts.append (MOVE);
                                }
                                var descriptive_level = 'carry:{}-work:{}'.format (num_sections * 3, num_sections);
                            }
                            else if (energy >= (move_cost * 3 + carry_cost * 2) + work_cost) {
                                var parts = [MOVE, MOVE, MOVE, CARRY, CARRY, WORK];
                                var descriptive_level = 'carry:2-work:1';
                            }
                            else if (energy >= (move_cost * 2 + carry_cost) + work_cost) {
                                var parts = [MOVE, MOVE, CARRY, WORK];
                                var descriptive_level = 'carry:1-work:1';
                            }
                            else {
                                print ('[{}][spawning] Too few extensions to build a worker ({}/{} energy)!'.format (room.name, energy, 250));
                                if (__mod__ (Game.time, 30) == 3) {
                                    room.reset_planned_role ();
                                }
                                return ;
                            }
                        }
                        else if (base === creep_base_defender) {
                            var parts = [];
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (TOUGH);
                            }
                            for (var i = 0; i < math.floor (num_sections * 1.5); i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < num_sections * 2 + half_section; i++) {
                                parts.append (ATTACK);
                            }
                            for (var i = 0; i < math.ceil (num_sections * 1.5) + half_section; i++) {
                                parts.append (MOVE);
                            }
                            var descriptive_level = num_sections;
                        }
                        else if (base === creep_base_rampart_defense) {
                            var parts = [];
                            for (var i = 0; i < num_sections + half_section; i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < num_sections * 2 + half_section; i++) {
                                parts.append (ATTACK);
                            }
                            var descriptive_level = num_sections * 2 + half_section;
                        }
                        else if (base === creep_base_ranged_offense) {
                            var parts = [];
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (RANGED_ATTACK);
                            }
                            for (var i = 0; i < 1 + num_sections; i++) {
                                parts.append (MOVE);
                            }
                            parts.append (HEAL);
                            var descriptive_level = num_sections;
                        }
                        else if (base === creep_base_3h) {
                            var parts = [];
                            for (var i = 0; i < half_section * 2; i++) {
                                parts.append (TOUGH);
                            }
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (RANGED_ATTACK);
                            }
                            for (var i = 0; i < (3 + 2 * half_section) + num_sections; i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < 3; i++) {
                                parts.append (HEAL);
                            }
                            var descriptive_level = num_sections;
                        }
                        else if (base === creep_base_mammoth_miner) {
                            var parts = [MOVE, CARRY];
                            var move_cost = BODYPART_COST [MOVE];
                            var carry_cost = BODYPART_COST [CARRY];
                            var work_cost = BODYPART_COST [WORK];
                            var energy_counter = move_cost + carry_cost;
                            var part_counter = 2;
                            var move_counter = 0.25;
                            for (var i = 0; i < 2; i++) {
                                if (part_counter >= MAX_CREEP_SIZE) {
                                    break;
                                }
                                if (energy_counter >= energy - move_cost) {
                                    break;
                                }
                                for (var j = 0; j < 25; j++) {
                                    if (move_counter >= 1) {
                                        if (part_counter >= MAX_CREEP_SIZE) {
                                            break;
                                        }
                                        if (energy_counter >= energy - move_cost) {
                                            break;
                                        }
                                        parts.append (MOVE);
                                        energy_counter += move_cost;
                                        part_counter++;
                                        move_counter--;
                                    }
                                    if (part_counter >= MAX_CREEP_SIZE) {
                                        break;
                                    }
                                    if (energy_counter >= energy - work_cost) {
                                        break;
                                    }
                                    parts.append (WORK);
                                    energy_counter += work_cost;
                                    part_counter++;
                                    move_counter += 0.25;
                                }
                            }
                        }
                        else if (base === creep_base_goader) {
                            var parts = [];
                            for (var i = 0; i < (num_sections * 2 + 1) + half_section; i++) {
                                parts.append (TOUGH);
                            }
                            parts.append (ATTACK);
                            for (var i = 0; i < (num_sections + 1) + half_section; i++) {
                                parts.append (MOVE);
                            }
                        }
                        else if (base === creep_base_full_move_goader) {
                            var parts = [];
                            for (var i = 0; i < num_sections * 2; i++) {
                                parts.append (CARRY);
                            }
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (TOUGH);
                            }
                            parts.append (ATTACK);
                            for (var i = 0; i < num_sections + 1; i++) {
                                parts.append (MOVE);
                            }
                        }
                        else if (base === creep_base_half_move_healer) {
                            var parts = [];
                            var total_heal = num_sections * 2 + half_section;
                            var total_move = num_sections + half_section;
                            for (var i = 0; i < math.floor (total_move / 2); i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < math.floor (total_heal / 2); i++) {
                                parts.append (HEAL);
                            }
                            for (var i = 0; i < math.ceil (total_move / 2); i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < math.ceil (total_heal / 2); i++) {
                                parts.append (HEAL);
                            }
                        }
                        else if (base === creep_base_full_move_healer) {
                            var parts = [];
                            for (var i = 0; i < math.floor (num_sections / 2); i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < math.floor (num_sections / 2); i++) {
                                parts.append (HEAL);
                            }
                            for (var i = 0; i < math.ceil (num_sections / 2); i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < math.ceil (num_sections / 2); i++) {
                                parts.append (HEAL);
                            }
                        }
                        else if (base === creep_base_dismantler) {
                            var parts = [];
                            for (var i = 0; i < num_sections * 2 + half_section; i++) {
                                parts.append (WORK);
                            }
                            for (var i = 0; i < num_sections + half_section; i++) {
                                parts.append (MOVE);
                            }
                        }
                        else if (base === creep_base_full_move_dismantler) {
                            var parts = [];
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (WORK);
                            }
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (MOVE);
                            }
                        }
                        else if (base === creep_base_full_upgrader) {
                            if (num_sections > 1 || half_section) {
                                var parts = [CARRY];
                                var num_work = num_sections * 2 + half_section;
                                var num_move = (num_sections + half_section) + 1;
                                for (var i = 0; i < num_work; i++) {
                                    parts.append (WORK);
                                }
                                if (num_work > 15) {
                                    parts.append (CARRY);
                                }
                                else if (half_section) {
                                    num_move--;
                                }
                                for (var i = 0; i < num_move; i++) {
                                    parts.append (MOVE);
                                }
                                var descriptive_level = num_work;
                            }
                            else {
                                var parts = [MOVE, CARRY, WORK];
                                var descriptive_level = 'min';
                            }
                        }
                        else if (base === creep_base_power_attack) {
                            var parts = [];
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (TOUGH);
                            }
                            for (var i = 0; i < num_sections * 2 + half_section; i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < num_sections * 3 + half_section; i++) {
                                parts.append (ATTACK);
                            }
                        }
                        else if (base === creep_base_full_move_power_attack) {
                            var parts = [];
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (MOVE);
                            }
                            for (var i = 0; i < num_sections; i++) {
                                parts.append (ATTACK);
                            }
                        }
                        else if (base === creep_base_scout) {
                            var parts = [MOVE];
                        }
                        else {
                            print ('[{}][spawning] Unknown creep base {}! Role object: {}'.format (room.name, base, JSON.stringify (role_obj)));
                            room.reset_planned_role ();
                            return ;
                        }
                        var carry = 0;
                        var work = 0;
                        var __iterable0__ = parts;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var part = __iterable0__ [__index0__];
                            if (part == CARRY) {
                                carry++;
                            }
                            if (part == WORK) {
                                work++;
                            }
                        }
                        var name = naming.random_digits ();
                        if (Game.creeps [name]) {
                            var name = naming.random_digits ();
                        }
                        var home = room.name;
                        if (replacing) {
                            var memory = {'home': home, 'role': role_temporary_replacing, 'replacing': replacing, 'replacing_role': role};
                        }
                        else {
                            var memory = {'home': home, 'role': role};
                        }
                        if (role_obj.memory) {
                            _.extend (memory, role_obj.memory);
                        }
                        if (_.sum (parts, (function __lambda__ (p) {
                            return BODYPART_COST [p];
                        })) > spawn.room.energyAvailable - ubos_cache.get (room.name)) {
                            print ('[{}][spawning] Warning: Generated too costly of a body for a {}! Available energy: {}, cost: {}.'.format (room.name, role, spawn.room.energyAvailable - ubos_cache.get (room.name), _.sum (parts, (function __lambda__ (p) {
                                return BODYPART_COST [p];
                            }))));
                            room.reset_planned_role ();
                            return ;
                        }
                        var result = spawn.createCreep (parts, name, memory);
                        if (!(result in Game.creeps)) {
                            print ('[{}][spawning] Invalid response from createCreep: {}'.format (room.name, result));
                            if (result == ERR_NOT_ENOUGH_RESOURCES) {
                                print ("[{}][spawning] Couldn't create body {} with energy {} (target num_sections: {})!".format (room.name, parts, energy, num_sections));
                            }
                            else if (result == ERR_INVALID_ARGS) {
                                if (descriptive_level) {
                                    print ('[{}][spawning] Produced invalid body array for creep type {} level {}: {}'.format (room.name, base, descriptive_level, JSON.stringify (parts)));
                                }
                                else {
                                    print ('[{}][spawning] Produced invalid body array for creep type {}: {}'.format (room.name, base, JSON.stringify (parts)));
                                }
                            }
                        }
                        else {
                            var used = ubos_cache.get (room.name) || 0;
                            used += postspawn_calculate_cost_of (parts);
                            ubos_cache.set (room.name, used);
                            room.reset_planned_role ();
                            if (role_obj.targets) {
                                var __iterable0__ = role_obj.targets;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var __left0__ = __iterable0__ [__index0__];
                                    var target_type = __left0__ [0];
                                    var target_id = __left0__ [1];
                                    room.hive.targets.manually_register ({'name': name}, target_type, target_id);
                                }
                            }
                            if (role_obj.rkey) {
                                room.successfully_spawned_request (role_obj.rkey);
                            }
                            if (role_obj.run_after) {
                                (eval(role_obj.run_after))
                                 (name);
                            }
                            if (replacing) {
                                room.register_new_replacing_creep (replacing, result);
                            }
                            else {
                                room.register_to_role (Game.creeps [result]);
                            }
                        }
                    };
                    var validate_role = function (role_obj) {
                        if (role_obj === null) {
                            return ;
                        }
                        if (!(role_obj.role)) {
                            var __except0__ = new Error ('Invalid role: no .role property');
                            __except0__.__cause__ = null;
                            throw __except0__;
                        }
                        if (!(role_obj.base)) {
                            var __except0__ = new Error ('Invalid role: no .base property');
                            __except0__.__cause__ = null;
                            throw __except0__;
                        }
                        if (!(role_obj.num_sections)) {
                            role_obj.num_sections = Infinity;
                        }
                        if (('replacing' in role_obj) && !(role_obj.replacing)) {
                            delete role_obj.replacing;
                        }
                        role_obj.num_sections = ceil_sections (role_obj.num_sections, role_obj.base);
                    };
                    var find_base_type = function (creep) {
                        if (creep.creep) {
                            var creep = creep.creep;
                        }
                        var part_counts = _.countBy (creep.body, (function __lambda__ (p) {
                            return p.type;
                        }));
                        var total = _.sum (part_counts);
                        if ((part_counts [WORK] == part_counts [CARRY] && part_counts [CARRY] == part_counts [MOVE] / 2 && part_counts [MOVE] / 2 == total / 4) || (part_counts [WORK] == part_counts [CARRY] / 3 && part_counts [CARRY] / 3 == part_counts [MOVE] / 4 && part_counts [MOVE] / 4 == total / 8) || (part_counts [WORK] - 1 == part_counts [CARRY] / 3 && part_counts [CARRY] / 3 == (part_counts [MOVE] - 1) / 4 && (part_counts [MOVE] - 1) / 4 == (total - 2) / 8)) {
                            var base = creep_base_worker;
                        }
                        else if (part_counts [MOVE] + part_counts [WORK] == total && (part_counts [MOVE] <= part_counts [WORK] && part_counts [WORK] <= 3)) {
                            var base = creep_base_1500miner;
                        }
                        else if (part_counts [MOVE] + part_counts [WORK] == total && (part_counts [MOVE] <= part_counts [WORK] && part_counts [WORK] <= 5)) {
                            var base = creep_base_3000miner;
                        }
                        else if (part_counts [MOVE] + part_counts [WORK] == total && (part_counts [MOVE] <= part_counts [WORK] && part_counts [WORK] <= 7)) {
                            var base = creep_base_4000miner;
                        }
                        else if (part_counts [CARRY] == 1 && (part_counts [MOVE] + part_counts [WORK]) + 1 == total && (part_counts [MOVE] <= part_counts [WORK] && part_counts [WORK] <= 5)) {
                            var base = creep_base_carry3000miner;
                        }
                        else if ((part_counts [CARRY] == part_counts [MOVE] && part_counts [MOVE] == total / 2)) {
                            var base = creep_base_hauler;
                        }
                        else if (part_counts [WORK] == 2 && (part_counts [MOVE] == part_counts [CARRY] + 2 && part_counts [CARRY] + 2 == total / 2)) {
                            var base = creep_base_work_full_move_hauler;
                        }
                        else if (part_counts [WORK] == 2 && (part_counts [MOVE] == (part_counts [CARRY] + 2) / 2 && (part_counts [CARRY] + 2) / 2 == total / 3) || part_counts [WORK] == 2 && (part_counts [MOVE] - 2 == part_counts [CARRY] / 2 && part_counts [CARRY] / 2 == (total - 3) / 3)) {
                            var base = creep_base_work_half_move_hauler;
                        }
                        else if ((part_counts [CLAIM] == part_counts [MOVE] && part_counts [MOVE] == total / 2)) {
                            var base = creep_base_reserving;
                        }
                        else if ((part_counts [ATTACK] == part_counts [TOUGH] && part_counts [TOUGH] == part_counts [MOVE] && part_counts [MOVE] == total / 3)) {
                            var base = creep_base_defender;
                        }
                        else if (part_counts [MOVE] == total / 3 && part_counts [CARRY] == 2 && (part_counts [WORK] + part_counts [MOVE]) + part_counts [CARRY] == total || part_counts [MOVE] == (total - 1) / 3 + 1 && part_counts [CARRY] == 2 && (part_counts [WORK] + part_counts [MOVE]) + part_counts [CARRY] == total) {
                            var base = creep_base_full_upgrader;
                        }
                        else if ((part_counts [MOVE] == total && total == 1)) {
                            var base = creep_base_scout;
                        }
                        else if ((part_counts [ATTACK] / 2 == part_counts [MOVE] && part_counts [MOVE] == total / 3) || ((part_counts [ATTACK] - 1) / 2 == part_counts [MOVE] - 1 && part_counts [MOVE] - 1 == (total - 2) / 3)) {
                            var base = creep_base_rampart_defense;
                        }
                        else {
                            print ('[{}][{}] Creep has unknown body! {}'.format (creep.memory.home, creep.name, JSON.stringify (part_counts)));
                            return null;
                        }
                        return base;
                    };
                    var postspawn_calculate_cost_of = function (parts) {
                        var cost = 0;
                        var __iterable0__ = parts;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var part = __iterable0__ [__index0__];
                            cost += BODYPART_COST [part];
                        }
                        return cost;
                    };
                    var energy_per_section = function (base) {
                        if ((base in scalable_sections)) {
                            var cost = 0;
                            var __iterable0__ = scalable_sections [base];
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var part = __iterable0__ [__index0__];
                                cost += BODYPART_COST [part];
                            }
                            return cost;
                        }
                        else {
                            return null;
                        }
                    };
                    var lower_energy_per_section = function (base) {
                        if ((base in low_energy_sections)) {
                            var cost = 0;
                            var __iterable0__ = low_energy_sections [base];
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var part = __iterable0__ [__index0__];
                                cost += BODYPART_COST [part];
                            }
                            return cost;
                        }
                        else {
                            return energy_per_section (base);
                        }
                    };
                    var initial_section_cost = function (base) {
                        var cost = 0;
                        if ((base in initial_section)) {
                            var __iterable0__ = initial_section [base];
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var part = __iterable0__ [__index0__];
                                cost += BODYPART_COST [part];
                            }
                        }
                        return cost;
                    };
                    var half_section_cost = function (base) {
                        var cost = 0;
                        if ((base in half_sections)) {
                            var __iterable0__ = half_sections [base];
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var part = __iterable0__ [__index0__];
                                cost += BODYPART_COST [part];
                            }
                        }
                        return cost;
                    };
                    var cost_of_sections = function (base, num_sections, energy_available) {
                        var initial_cost = initial_section_cost (base);
                        var per_section_energy = energy_per_section (base);
                        if (initial_cost + per_section_energy > energy_available) {
                            var per_section_energy = lower_energy_per_section (base);
                        }
                        if (__mod__ (num_sections, 1) > 0) {
                            return (initial_cost + math.floor (num_sections) * per_section_energy) + half_section_cost (base);
                        }
                        else {
                            return initial_section_cost (base) + num_sections * per_section_energy;
                        }
                    };
                    var max_sections_of = function (room, base) {
                        if (emergency_conditions (room)) {
                            var energy = room.room.energyAvailable;
                        }
                        else {
                            var energy = room.room.energyCapacityAvailable;
                        }
                        var max_by_cost = floor ((energy - initial_section_cost (base)) / energy_per_section (base));
                        if (max_by_cost == 0) {
                            var max_by_cost = floor ((energy - initial_section_cost (base)) / lower_energy_per_section (base));
                        }
                        var initial_base_parts = ((base in initial_section) ? len (initial_section [base]) : 0);
                        var max_by_parts = floor ((MAX_CREEP_SIZE - initial_base_parts) / len (scalable_sections [base]));
                        var num_sections = min (max_by_cost, max_by_parts);
                        if ((base in half_sections)) {
                            var current_parts = initial_base_parts + num_sections * len (scalable_sections [base]);
                            if (current_parts + len (half_sections [base]) <= MAX_CREEP_SIZE) {
                                var current_energy = cost_of_sections (base, num_sections, energy);
                                if (current_energy + half_section_cost (base) <= energy) {
                                    num_sections += 0.5;
                                }
                            }
                        }
                        return num_sections;
                    };
                    var using_lower_energy_section = function (room, base) {
                        if (emergency_conditions (room)) {
                            var energy = room.room.energyAvailable;
                        }
                        else {
                            var energy = room.room.energyCapacityAvailable;
                        }
                        var max_by_cost = floor ((energy - initial_section_cost (base)) / energy_per_section (base));
                        if (max_by_cost == 0) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    };
                    var work_count = function (creep) {
                        if (creep.creep) {
                            var creep = creep.creep;
                        }
                        var work = 0;
                        var __iterable0__ = creep.body;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var part = __iterable0__ [__index0__];
                            if (part.type == WORK) {
                                work++;
                                if (part.boost) {
                                    var boost = BOOSTS [WORK] [part.boost];
                                    work += boost [Object.keys (boost) [0]];
                                }
                            }
                        }
                        return work;
                    };
                    var carry_count = function (creep) {
                        if (creep.creep) {
                            var creep = creep.creep;
                        }
                        return creep.carryCapacity / CARRY_CAPACITY;
                    };
                    var fit_num_sections = function (needed, maximum, extra_initial, min_split) {
                        if (typeof extra_initial == 'undefined' || (extra_initial != null && extra_initial .hasOwnProperty ("__kwargtrans__"))) {;
                            var extra_initial = 0;
                        };
                        if (typeof min_split == 'undefined' || (min_split != null && min_split .hasOwnProperty ("__kwargtrans__"))) {;
                            var min_split = 1;
                        };
                        if (maximum <= 1) {
                            return maximum;
                        }
                        var num = min_split;
                        var trying = Infinity;
                        while (trying > maximum) {
                            var trying = ceil_sections (needed / num - extra_initial);
                            num++;
                        }
                        return trying;
                    };
                    var ceil_sections = function (count, base) {
                        if (typeof base == 'undefined' || (base != null && base .hasOwnProperty ("__kwargtrans__"))) {;
                            var base = null;
                        };
                        if (base !== null && !(base in half_sections)) {
                            return math.ceil (count);
                        }
                        return math.ceil (count * 2) / 2;
                    };
                    var floor_sections = function (count, base) {
                        if (typeof base == 'undefined' || (base != null && base .hasOwnProperty ("__kwargtrans__"))) {;
                            var base = null;
                        };
                        if (base !== null && !(base in half_sections)) {
                            return math.floor (count);
                        }
                        return math.floor (count * 2) / 2;
                    };
                    __pragma__ ('<use>' +
                        'cache.volatile_cache' +
                        'constants' +
                        'jstools.screeps_constants' +
                        'math' +
                        'utilities.naming' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.DEPOT = DEPOT;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.PYFIND_BUILDABLE_ROADS = PYFIND_BUILDABLE_ROADS;
                        __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
                        __all__.PYFIND_REPAIRABLE_ROADS = PYFIND_REPAIRABLE_ROADS;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.REROUTE = REROUTE;
                        __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
                        __all__.RESERVE_NOW = RESERVE_NOW;
                        __all__.SCOUT = SCOUT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SK_USERNAME = SK_USERNAME;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__.carry_count = carry_count;
                        __all__.ceil_sections = ceil_sections;
                        __all__.cost_of_sections = cost_of_sections;
                        __all__.creep_base_1500miner = creep_base_1500miner;
                        __all__.creep_base_3000miner = creep_base_3000miner;
                        __all__.creep_base_3h = creep_base_3h;
                        __all__.creep_base_4000miner = creep_base_4000miner;
                        __all__.creep_base_carry3000miner = creep_base_carry3000miner;
                        __all__.creep_base_claim_attack = creep_base_claim_attack;
                        __all__.creep_base_claiming = creep_base_claiming;
                        __all__.creep_base_defender = creep_base_defender;
                        __all__.creep_base_dismantler = creep_base_dismantler;
                        __all__.creep_base_full_move_dismantler = creep_base_full_move_dismantler;
                        __all__.creep_base_full_move_goader = creep_base_full_move_goader;
                        __all__.creep_base_full_move_healer = creep_base_full_move_healer;
                        __all__.creep_base_full_move_power_attack = creep_base_full_move_power_attack;
                        __all__.creep_base_full_upgrader = creep_base_full_upgrader;
                        __all__.creep_base_goader = creep_base_goader;
                        __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
                        __all__.creep_base_half_move_healer = creep_base_half_move_healer;
                        __all__.creep_base_hauler = creep_base_hauler;
                        __all__.creep_base_mammoth_miner = creep_base_mammoth_miner;
                        __all__.creep_base_power_attack = creep_base_power_attack;
                        __all__.creep_base_rampart_defense = creep_base_rampart_defense;
                        __all__.creep_base_ranged_offense = creep_base_ranged_offense;
                        __all__.creep_base_reserving = creep_base_reserving;
                        __all__.creep_base_scout = creep_base_scout;
                        __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
                        __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
                        __all__.creep_base_worker = creep_base_worker;
                        __all__.default_roles = default_roles;
                        __all__.emergency_conditions = emergency_conditions;
                        __all__.energy_per_section = energy_per_section;
                        __all__.find_base_type = find_base_type;
                        __all__.fit_num_sections = fit_num_sections;
                        __all__.floor = floor;
                        __all__.floor_sections = floor_sections;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.gmem_key_last_room_state_refresh = gmem_key_last_room_state_refresh;
                        __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
                        __all__.half_section_cost = half_section_cost;
                        __all__.half_sections = half_sections;
                        __all__.initial_section = initial_section;
                        __all__.initial_section_cost = initial_section_cost;
                        __all__.low_energy_dynamic = low_energy_dynamic;
                        __all__.low_energy_sections = low_energy_sections;
                        __all__.lower_energy_per_section = lower_energy_per_section;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
                        __all__.max_sections_of = max_sections_of;
                        __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
                        __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
                        __all__.naming = naming;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.old_role_names = old_role_names;
                        __all__.postspawn_calculate_cost_of = postspawn_calculate_cost_of;
                        __all__.recycle_time = recycle_time;
                        __all__.request_priority_economy = request_priority_economy;
                        __all__.request_priority_helping_party = request_priority_helping_party;
                        __all__.request_priority_imminent_threat_defense = request_priority_imminent_threat_defense;
                        __all__.request_priority_low = request_priority_low;
                        __all__.rmem_key_building_paused = rmem_key_building_paused;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.rmem_key_cache = rmem_key_cache;
                        __all__.rmem_key_carry_parts_by_role = rmem_key_carry_parts_by_role;
                        __all__.rmem_key_creeps_by_role = rmem_key_creeps_by_role;
                        __all__.rmem_key_creeps_by_role_and_replacement_time = rmem_key_creeps_by_role_and_replacement_time;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                        __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
                        __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
                        __all__.rmem_key_flag_for_testing_spawning_in_simulation = rmem_key_flag_for_testing_spawning_in_simulation;
                        __all__.rmem_key_focusing_home = rmem_key_focusing_home;
                        __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
                        __all__.rmem_key_metadata = rmem_key_metadata;
                        __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
                        __all__.rmem_key_now_supporting = rmem_key_now_supporting;
                        __all__.rmem_key_pause_all_room_operations = rmem_key_pause_all_room_operations;
                        __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
                        __all__.rmem_key_prepping_defenses = rmem_key_prepping_defenses;
                        __all__.rmem_key_remotes_explicitly_marked_under_attack = rmem_key_remotes_explicitly_marked_under_attack;
                        __all__.rmem_key_remotes_safe_when_under_siege = rmem_key_remotes_safe_when_under_siege;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.rmem_key_spawn_requests = rmem_key_spawn_requests;
                        __all__.rmem_key_sponsor = rmem_key_sponsor;
                        __all__.rmem_key_storage_use_enabled = rmem_key_storage_use_enabled;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
                        __all__.rmem_key_total_open_source_spaces = rmem_key_total_open_source_spaces;
                        __all__.rmem_key_upgrading_paused = rmem_key_upgrading_paused;
                        __all__.rmem_key_work_parts_by_role = rmem_key_work_parts_by_role;
                        __all__.role_bases = role_bases;
                        __all__.role_builder = role_builder;
                        __all__.role_cleanup = role_cleanup;
                        __all__.role_colonist = role_colonist;
                        __all__.role_defender = role_defender;
                        __all__.role_energy_grab = role_energy_grab;
                        __all__.role_hauler = role_hauler;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_miner = role_miner;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.role_mineral_miner = role_mineral_miner;
                        __all__.role_mineral_steal = role_mineral_steal;
                        __all__.role_power_attack = role_power_attack;
                        __all__.role_power_cleanup = role_power_cleanup;
                        __all__.role_ranged_offense = role_ranged_offense;
                        __all__.role_recycling = role_recycling;
                        __all__.role_remote_mining_reserve = role_remote_mining_reserve;
                        __all__.role_room_reserve = role_room_reserve;
                        __all__.role_scout = role_scout;
                        __all__.role_simple_claim = role_simple_claim;
                        __all__.role_simple_dismantle = role_simple_dismantle;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_spawn_fill_backup = role_spawn_fill_backup;
                        __all__.role_td_goad = role_td_goad;
                        __all__.role_td_healer = role_td_healer;
                        __all__.role_temporary_replacing = role_temporary_replacing;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.role_tower_fill_once = role_tower_fill_once;
                        __all__.role_upgrade_fill = role_upgrade_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.role_wall_defender = role_wall_defender;
                        __all__.run = run;
                        __all__.scalable_sections = scalable_sections;
                        __all__.target_big_big_repair = target_big_big_repair;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_construction = target_construction;
                        __all__.target_destruction_site = target_destruction_site;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                        __all__.target_home_flag = target_home_flag;
                        __all__.target_rampart_defense = target_rampart_defense;
                        __all__.target_refill = target_refill;
                        __all__.target_repair = target_repair;
                        __all__.target_reserve_now = target_reserve_now;
                        __all__.target_single_flag = target_single_flag;
                        __all__.target_single_flag2 = target_single_flag2;
                        __all__.target_source = target_source;
                        __all__.target_spawn_deposit = target_spawn_deposit;
                        __all__.target_tower_fill = target_tower_fill;
                        __all__.using_lower_energy_section = using_lower_energy_section;
                        __all__.validate_role = validate_role;
                        __all__.volatile_cache = volatile_cache;
                        __all__.work_count = work_count;
                        __all__.would_be_emergency = would_be_emergency;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creep_management.walkby_move', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
                    var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
                    var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
                    var PYFIND_BUILDABLE_ROADS = __init__ (__world__.constants).PYFIND_BUILDABLE_ROADS;
                    var PYFIND_HURT_CREEPS = __init__ (__world__.constants).PYFIND_HURT_CREEPS;
                    var PYFIND_REPAIRABLE_ROADS = __init__ (__world__.constants).PYFIND_REPAIRABLE_ROADS;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var REROUTE = __init__ (__world__.constants).REROUTE;
                    var REROUTE_DESTINATION = __init__ (__world__.constants).REROUTE_DESTINATION;
                    var RESERVE_NOW = __init__ (__world__.constants).RESERVE_NOW;
                    var SCOUT = __init__ (__world__.constants).SCOUT;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var SK_USERNAME = __init__ (__world__.constants).SK_USERNAME;
                    var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
                    var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
                    var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
                    var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
                    var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var creep_base_1500miner = __init__ (__world__.constants).creep_base_1500miner;
                    var creep_base_3000miner = __init__ (__world__.constants).creep_base_3000miner;
                    var creep_base_3h = __init__ (__world__.constants).creep_base_3h;
                    var creep_base_4000miner = __init__ (__world__.constants).creep_base_4000miner;
                    var creep_base_carry3000miner = __init__ (__world__.constants).creep_base_carry3000miner;
                    var creep_base_claim_attack = __init__ (__world__.constants).creep_base_claim_attack;
                    var creep_base_claiming = __init__ (__world__.constants).creep_base_claiming;
                    var creep_base_defender = __init__ (__world__.constants).creep_base_defender;
                    var creep_base_dismantler = __init__ (__world__.constants).creep_base_dismantler;
                    var creep_base_full_move_dismantler = __init__ (__world__.constants).creep_base_full_move_dismantler;
                    var creep_base_full_move_goader = __init__ (__world__.constants).creep_base_full_move_goader;
                    var creep_base_full_move_healer = __init__ (__world__.constants).creep_base_full_move_healer;
                    var creep_base_full_move_power_attack = __init__ (__world__.constants).creep_base_full_move_power_attack;
                    var creep_base_full_upgrader = __init__ (__world__.constants).creep_base_full_upgrader;
                    var creep_base_goader = __init__ (__world__.constants).creep_base_goader;
                    var creep_base_half_move_hauler = __init__ (__world__.constants).creep_base_half_move_hauler;
                    var creep_base_half_move_healer = __init__ (__world__.constants).creep_base_half_move_healer;
                    var creep_base_hauler = __init__ (__world__.constants).creep_base_hauler;
                    var creep_base_mammoth_miner = __init__ (__world__.constants).creep_base_mammoth_miner;
                    var creep_base_power_attack = __init__ (__world__.constants).creep_base_power_attack;
                    var creep_base_rampart_defense = __init__ (__world__.constants).creep_base_rampart_defense;
                    var creep_base_ranged_offense = __init__ (__world__.constants).creep_base_ranged_offense;
                    var creep_base_reserving = __init__ (__world__.constants).creep_base_reserving;
                    var creep_base_scout = __init__ (__world__.constants).creep_base_scout;
                    var creep_base_work_full_move_hauler = __init__ (__world__.constants).creep_base_work_full_move_hauler;
                    var creep_base_work_half_move_hauler = __init__ (__world__.constants).creep_base_work_half_move_hauler;
                    var creep_base_worker = __init__ (__world__.constants).creep_base_worker;
                    var default_roles = __init__ (__world__.constants).default_roles;
                    var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
                    var gmem_key_last_room_state_refresh = __init__ (__world__.constants).gmem_key_last_room_state_refresh;
                    var gmem_key_room_mining_paths = __init__ (__world__.constants).gmem_key_room_mining_paths;
                    var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
                    var max_repave_mine_roads_every = __init__ (__world__.constants).max_repave_mine_roads_every;
                    var min_repath_mine_roads_every = __init__ (__world__.constants).min_repath_mine_roads_every;
                    var min_repave_mine_roads_every = __init__ (__world__.constants).min_repave_mine_roads_every;
                    var old_role_names = __init__ (__world__.constants).old_role_names;
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var request_priority_economy = __init__ (__world__.constants).request_priority_economy;
                    var request_priority_helping_party = __init__ (__world__.constants).request_priority_helping_party;
                    var request_priority_imminent_threat_defense = __init__ (__world__.constants).request_priority_imminent_threat_defense;
                    var request_priority_low = __init__ (__world__.constants).request_priority_low;
                    var rmem_key_building_paused = __init__ (__world__.constants).rmem_key_building_paused;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
                    var rmem_key_cache = __init__ (__world__.constants).rmem_key_cache;
                    var rmem_key_carry_parts_by_role = __init__ (__world__.constants).rmem_key_carry_parts_by_role;
                    var rmem_key_creeps_by_role = __init__ (__world__.constants).rmem_key_creeps_by_role;
                    var rmem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants).rmem_key_creeps_by_role_and_replacement_time;
                    var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
                    var rmem_key_defense_mind_storage = __init__ (__world__.constants).rmem_key_defense_mind_storage;
                    var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants).rmem_key_empty_all_resources_into_room;
                    var rmem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants).rmem_key_flag_for_testing_spawning_in_simulation;
                    var rmem_key_focusing_home = __init__ (__world__.constants).rmem_key_focusing_home;
                    var rmem_key_linking_mind_storage = __init__ (__world__.constants).rmem_key_linking_mind_storage;
                    var rmem_key_metadata = __init__ (__world__.constants).rmem_key_metadata;
                    var rmem_key_mineral_mind_storage = __init__ (__world__.constants).rmem_key_mineral_mind_storage;
                    var rmem_key_now_supporting = __init__ (__world__.constants).rmem_key_now_supporting;
                    var rmem_key_pause_all_room_operations = __init__ (__world__.constants).rmem_key_pause_all_room_operations;
                    var rmem_key_planned_role_to_spawn = __init__ (__world__.constants).rmem_key_planned_role_to_spawn;
                    var rmem_key_prepping_defenses = __init__ (__world__.constants).rmem_key_prepping_defenses;
                    var rmem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants).rmem_key_remotes_explicitly_marked_under_attack;
                    var rmem_key_remotes_safe_when_under_siege = __init__ (__world__.constants).rmem_key_remotes_safe_when_under_siege;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
                    var rmem_key_spawn_requests = __init__ (__world__.constants).rmem_key_spawn_requests;
                    var rmem_key_sponsor = __init__ (__world__.constants).rmem_key_sponsor;
                    var rmem_key_storage_use_enabled = __init__ (__world__.constants).rmem_key_storage_use_enabled;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
                    var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants).rmem_key_there_might_be_energy_lying_around;
                    var rmem_key_total_open_source_spaces = __init__ (__world__.constants).rmem_key_total_open_source_spaces;
                    var rmem_key_upgrading_paused = __init__ (__world__.constants).rmem_key_upgrading_paused;
                    var rmem_key_work_parts_by_role = __init__ (__world__.constants).rmem_key_work_parts_by_role;
                    var role_bases = __init__ (__world__.constants).role_bases;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_cleanup = __init__ (__world__.constants).role_cleanup;
                    var role_colonist = __init__ (__world__.constants).role_colonist;
                    var role_defender = __init__ (__world__.constants).role_defender;
                    var role_energy_grab = __init__ (__world__.constants).role_energy_grab;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_link_manager = __init__ (__world__.constants).role_link_manager;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
                    var role_mineral_miner = __init__ (__world__.constants).role_mineral_miner;
                    var role_mineral_steal = __init__ (__world__.constants).role_mineral_steal;
                    var role_power_attack = __init__ (__world__.constants).role_power_attack;
                    var role_power_cleanup = __init__ (__world__.constants).role_power_cleanup;
                    var role_ranged_offense = __init__ (__world__.constants).role_ranged_offense;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_remote_mining_reserve = __init__ (__world__.constants).role_remote_mining_reserve;
                    var role_room_reserve = __init__ (__world__.constants).role_room_reserve;
                    var role_scout = __init__ (__world__.constants).role_scout;
                    var role_simple_claim = __init__ (__world__.constants).role_simple_claim;
                    var role_simple_dismantle = __init__ (__world__.constants).role_simple_dismantle;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_spawn_fill_backup = __init__ (__world__.constants).role_spawn_fill_backup;
                    var role_td_goad = __init__ (__world__.constants).role_td_goad;
                    var role_td_healer = __init__ (__world__.constants).role_td_healer;
                    var role_temporary_replacing = __init__ (__world__.constants).role_temporary_replacing;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var role_tower_fill_once = __init__ (__world__.constants).role_tower_fill_once;
                    var role_upgrade_fill = __init__ (__world__.constants).role_upgrade_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var role_wall_defender = __init__ (__world__.constants).role_wall_defender;
                    var target_big_big_repair = __init__ (__world__.constants).target_big_big_repair;
                    var target_big_repair = __init__ (__world__.constants).target_big_repair;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var target_construction = __init__ (__world__.constants).target_construction;
                    var target_destruction_site = __init__ (__world__.constants).target_destruction_site;
                    var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
                    var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
                    var target_home_flag = __init__ (__world__.constants).target_home_flag;
                    var target_rampart_defense = __init__ (__world__.constants).target_rampart_defense;
                    var target_refill = __init__ (__world__.constants).target_refill;
                    var target_repair = __init__ (__world__.constants).target_repair;
                    var target_reserve_now = __init__ (__world__.constants).target_reserve_now;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var target_single_flag2 = __init__ (__world__.constants).target_single_flag2;
                    var target_source = __init__ (__world__.constants).target_source;
                    var target_spawn_deposit = __init__ (__world__.constants).target_spawn_deposit;
                    var target_tower_fill = __init__ (__world__.constants).target_tower_fill;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var hostile_utils = __init__ (__world__.utilities.hostile_utils);
                    var IDLE_ABOUT = 6;
                    var MOVE_THEN_WORK = 5;
                    var CONSTANT_MOVEMENT = 4;
                    var SEMICONSTANT_MOVEMENT = 3;
                    var MILITARY = 2;
                    var MOVE_THEN_STOP = 1;
                    var role_movement_types = {[role_upgrader]: MOVE_THEN_WORK, [role_spawn_fill]: SEMICONSTANT_MOVEMENT, [role_spawn_fill_backup]: SEMICONSTANT_MOVEMENT, [role_upgrade_fill]: IDLE_ABOUT, [role_link_manager]: MOVE_THEN_STOP, [role_builder]: MOVE_THEN_WORK, [role_tower_fill]: SEMICONSTANT_MOVEMENT, [role_miner]: MOVE_THEN_STOP, [role_hauler]: CONSTANT_MOVEMENT, [role_remote_mining_reserve]: MOVE_THEN_STOP, [role_defender]: MILITARY, [role_wall_defender]: MILITARY, [role_ranged_offense]: MILITARY, [role_cleanup]: MOVE_THEN_WORK, [role_temporary_replacing]: MOVE_THEN_WORK, [role_colonist]: MOVE_THEN_WORK, [role_simple_claim]: MOVE_THEN_WORK, [role_room_reserve]: MOVE_THEN_STOP, [role_mineral_steal]: CONSTANT_MOVEMENT, [role_recycling]: CONSTANT_MOVEMENT, [role_mineral_miner]: MOVE_THEN_STOP, [role_mineral_hauler]: IDLE_ABOUT, [role_td_healer]: MILITARY, [role_td_goad]: MILITARY, [role_simple_dismantle]: MILITARY, [role_scout]: MILITARY, [role_power_attack]: MILITARY, [role_power_cleanup]: MILITARY, [role_energy_grab]: MILITARY};
                    var move_prototype =
                    function move (direction) {
                        var result = this.__move(direction);
                        if (result != OK) {
                            return result;
                        }
                        var newX, newY;
                        switch (direction) {
                            case TOP_LEFT:
                                newX = this.pos.x - 1;
                                newY = this.pos.y - 1;
                                break;
                            case LEFT:
                                newX = this.pos.x - 1;
                                newY = this.pos.y;
                                break;
                            case BOTTOM_LEFT:
                                newX = this.pos.x - 1;
                                newY = this.pos.y + 1;
                                break;
                            case TOP:
                                newX = this.pos.x;
                                newY = this.pos.y - 1;
                                break;
                            case BOTTOM:
                                newX = this.pos.x;
                                newY = this.pos.y + 1;
                                break;
                            case TOP_RIGHT:
                                newX = this.pos.x + 1;
                                newY = this.pos.y - 1;
                                break;
                            case RIGHT:
                                newX = this.pos.x + 1;
                                newY = this.pos.y;
                                break;
                            case BOTTOM_RIGHT:
                                newX = this.pos.x + 1;
                                newY = this.pos.y + 1;
                                break;
                        }
                        if (newX > 49 || newY > 49 || newX < 0 || newY < 0) {
                            this.__moved = true;
                            return result;
                        }
                        var creeps = this.room.lookForAt(LOOK_CREEPS, newX, newY);
                        if (creeps.length) {
                            var creep = creeps[0]
                            if (creep.my) {
                                var myRole = this.memory.running || this.memory.role;
                                var myPriority = role_movement_types[myRole] || MOVE_THEN_WORK;
                                var otherRole = creep.memory.running || creep.memory.role;
                                var otherPriority = role_movement_types[otherRole] || MOVE_THEN_WORK;
                                if (myPriority < otherPriority
                                    || (otherPriority == myPriority
                                        && this.ticksToLive < creep.ticksToLive
                                        && (!('pt' in creep.memory) || creep.memory.pt >= Game.time))) {
                                    creep.__move(creep.pos.getDirectionTo(this.pos));
                                    creep.__moved = true;
                                } else if (otherPriority == myPriority && (!('pt' in creep.memory) || creep.memory.pt >= Game.time)) {
                                    if (!('pt' in this.memory) || Game.time - this.memory.pt > 50) {
                                        this.memory.pt = Game.time + 5;
                                    }
                                    if (this.memory.pt >= Game.time) {
                                        creep.__move(creep.pos.getDirectionTo(this.pos));
                                        creep.__moved = true;
                                    } else {
                                        delete this.memory._move;
                                        return result;
                                    }
                                } else {
                                    delete this.memory._move;
                                    return result;
                                }
                            }
                        }
                        this.__moved = true;
                        return result;
                    }

                    var apply_move_prototype = function () {
                        Creep.prototype.__move = Creep.prototype.move;
                        Creep.prototype.move = move_prototype;
                    };
                    var _add_only_blocking_creeps_to_matrix = function (my_priority, room, cost_matrix, same_role_cost, same_role_swamp_cost, existing_cost_addition) {
                        var __iterable0__ = room.find (FIND_MY_CREEPS);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var creep = __iterable0__ [__index0__];
                            var role = creep.memory.running || creep.memory.role;
                            var priority = role_movement_types [role] || MOVE_THEN_WORK;
                            if (priority == MOVE_THEN_STOP || priority < my_priority && priority !== CONSTANT_MOVEMENT) {
                                cost_matrix.set (creep.pos.x, creep.pos.y, 255);
                            }
                            else if (priority === my_priority || priority === CONSTANT_MOVEMENT && priority < my_priority) {
                                var x = creep.pos.x;
                                var y = creep.pos.y;
                                if (Game.map.getTerrainAt (x, y, room.name) == 'swamp') {
                                    if (cost_matrix.get (x, y) < same_role_swamp_cost) {
                                        cost_matrix.set (x, y, same_role_swamp_cost);
                                    }
                                    else {
                                        cost_matrix.set (x, y, cost_matrix.get (x, y) + existing_cost_addition);
                                    }
                                }
                                else if (cost_matrix.get (x, y) < same_role_cost) {
                                    cost_matrix.set (x, y, same_role_cost);
                                }
                                else {
                                    cost_matrix.set (x, y, cost_matrix.get (x, y) + existing_cost_addition);
                                }
                            }
                        }
                    };
                    var _create_basic_room_cost_matrix = function (room_name) {
                        var matrix = new PathFinder.CostMatrix ();
                        if (!(room_name in Game.rooms)) {
                            return matrix;
                        }
                        var room = Game.rooms [room_name];
                        var __iterable0__ = room.find (FIND_STRUCTURES);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var structure = __iterable0__ [__index0__];
                            if (structure.structureType == STRUCTURE_RAMPART && (structure.my || structure.isPublic)) {
                                continue;
                            }
                            if (structure.structureType == STRUCTURE_ROAD) {
                                if (matrix.get (structure.pos.x, structure.pos.y) <= 2) {
                                    matrix.set (structure.pos.x, structure.pos.y, 1);
                                }
                                continue;
                            }
                            if (structure.structureType == STRUCTURE_CONTAINER) {
                                continue;
                            }
                            matrix.set (structure.pos.x, structure.pos.y, 255);
                        }
                        var __iterable0__ = room.find (FIND_MY_CONSTRUCTION_SITES);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var site = __iterable0__ [__index0__];
                            if (site.structureType == STRUCTURE_RAMPART || site.structureType == STRUCTURE_ROAD || site.structureType == STRUCTURE_CONTAINER) {
                                continue;
                            }
                            matrix.set (site.pos.x, site.pos.y, 255);
                        }
                        if (!(room.controller) || !(room.controller.my) || !(room.controller.safeMode)) {
                            var __iterable0__ = room.find (FIND_HOSTILE_CREEPS);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var creep = __iterable0__ [__index0__];
                                matrix.set (creep.pos.x, creep.pos.y, 255);
                            }
                        }
                        return matrix;
                    };
                    var _add_avoid_things_to_cost_matrix = function (room_name, cost_matrix, roads) {
                        var multiplier = (roads ? 2 : 1);
                        var __iterable0__ = flags.find_flags (room_name, SK_LAIR_SOURCE_NOTED);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var flag = __iterable0__ [__index0__];
                            for (var x = flag.pos.x - 4; x < flag.pos.x + 5; x++) {
                                for (var y = flag.pos.y - 4; y < flag.pos.y + 5; y++) {
                                    cost_matrix.set (x, y, 255);
                                }
                            }
                        }
                        var __iterable0__ = [0, 49];
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var x = __iterable0__ [__index0__];
                            for (var y = 0; y < 49; y++) {
                                var terrain = Game.map.getTerrainAt (x, y, room_name);
                                if (terrain != 'wall') {
                                    var existing = cost_matrix.get (x, y);
                                    if (existing === 0) {
                                        if (terrain == 'swamp') {
                                            var existing = 5 * multiplier;
                                        }
                                        else {
                                            var existing = multiplier;
                                        }
                                    }
                                    cost_matrix.set (x, y, existing + 2 * multiplier);
                                }
                            }
                        }
                        var __iterable0__ = [0, 49];
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var y = __iterable0__ [__index0__];
                            for (var x = 1; x < 48; x++) {
                                var terrain = Game.map.getTerrainAt (x, y, room_name);
                                if (terrain != 'wall') {
                                    var existing = cost_matrix.get (x, y);
                                    if (existing === 0) {
                                        if (terrain == 'swamp') {
                                            var existing = 5 * multiplier;
                                        }
                                        else {
                                            var existing = multiplier;
                                        }
                                    }
                                    cost_matrix.set (x, y, existing + 2 * multiplier);
                                }
                            }
                        }
                    };
                    var get_cost_matrix_for_creep = function (me, room_name, roads, target_room) {
                        if (typeof target_room == 'undefined' || (target_room != null && target_room .hasOwnProperty ("__kwargtrans__"))) {;
                            var target_room = null;
                        };
                        if (hostile_utils.enemy_room (room_name) && room_name != target_room) {
                            return false;
                        }
                        if (!(room_name in Game.rooms)) {
                            return new PathFinder.CostMatrix ();
                        }
                        var cache = volatile_cache.submem ('matrices', room_name);
                        var my_role = me.memory.running || me.memory.role;
                        var my_priority = role_movement_types [my_role] || MOVE_THEN_WORK;
                        var key = my_priority;
                        if (roads) {
                            key <<= 5;
                        }
                        if (cache.has (key)) {
                            return cache.get (key);
                        }
                        else {
                            if (roads) {
                                var basic_key = -(2);
                            }
                            else {
                                var basic_key = -(1);
                            }
                            if (cache.has (basic_key)) {
                                var matrix = cache.get (basic_key).clone ();
                            }
                            else {
                                var matrix = _create_basic_room_cost_matrix (room_name);
                                _add_avoid_things_to_cost_matrix (room_name, matrix, roads);
                                cache.set (basic_key, matrix.clone ());
                            }
                            var multiplier = (roads ? 2 : 1);
                            _add_only_blocking_creeps_to_matrix (my_priority, Game.rooms [room_name], matrix, 5 * multiplier, 9 * multiplier, 4 * multiplier);
                            return matrix;
                        }
                    };
                    var get_basic_cost_matrix = function (room_name, roads) {
                        if (typeof roads == 'undefined' || (roads != null && roads .hasOwnProperty ("__kwargtrans__"))) {;
                            var roads = false;
                        };
                        if (!(room_name in Game.rooms)) {
                            return new PathFinder.CostMatrix ();
                        }
                        var cache = volatile_cache.submem ('matrices', room_name);
                        if (roads) {
                            var basic_key = -(2);
                        }
                        else {
                            var basic_key = -(1);
                        }
                        if (cache.has (basic_key)) {
                            var matrix = cache.get (basic_key).clone ();
                        }
                        else {
                            var matrix = _create_basic_room_cost_matrix (room_name);
                            _add_avoid_things_to_cost_matrix (room_name, matrix, roads);
                            cache.set (basic_key, matrix.clone ());
                        }
                        return matrix;
                    };
                    var create_cost_callback = function (me, roads, target_room) {
                        if (typeof target_room == 'undefined' || (target_room != null && target_room .hasOwnProperty ("__kwargtrans__"))) {;
                            var target_room = null;
                        };
                        return (function __lambda__ (room_name) {
                            return get_cost_matrix_for_creep (me, room_name, roads, target_room);
                        });
                    };
                    __pragma__ ('<use>' +
                        'cache.volatile_cache' +
                        'constants' +
                        'jstools.screeps_constants' +
                        'position_management.flags' +
                        'utilities.hostile_utils' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.CONSTANT_MOVEMENT = CONSTANT_MOVEMENT;
                        __all__.DEPOT = DEPOT;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.IDLE_ABOUT = IDLE_ABOUT;
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.MILITARY = MILITARY;
                        __all__.MOVE_THEN_STOP = MOVE_THEN_STOP;
                        __all__.MOVE_THEN_WORK = MOVE_THEN_WORK;
                        __all__.PYFIND_BUILDABLE_ROADS = PYFIND_BUILDABLE_ROADS;
                        __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
                        __all__.PYFIND_REPAIRABLE_ROADS = PYFIND_REPAIRABLE_ROADS;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.REROUTE = REROUTE;
                        __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
                        __all__.RESERVE_NOW = RESERVE_NOW;
                        __all__.SCOUT = SCOUT;
                        __all__.SEMICONSTANT_MOVEMENT = SEMICONSTANT_MOVEMENT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SK_USERNAME = SK_USERNAME;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__._add_avoid_things_to_cost_matrix = _add_avoid_things_to_cost_matrix;
                        __all__._add_only_blocking_creeps_to_matrix = _add_only_blocking_creeps_to_matrix;
                        __all__._create_basic_room_cost_matrix = _create_basic_room_cost_matrix;
                        __all__.apply_move_prototype = apply_move_prototype;
                        __all__.create_cost_callback = create_cost_callback;
                        __all__.creep_base_1500miner = creep_base_1500miner;
                        __all__.creep_base_3000miner = creep_base_3000miner;
                        __all__.creep_base_3h = creep_base_3h;
                        __all__.creep_base_4000miner = creep_base_4000miner;
                        __all__.creep_base_carry3000miner = creep_base_carry3000miner;
                        __all__.creep_base_claim_attack = creep_base_claim_attack;
                        __all__.creep_base_claiming = creep_base_claiming;
                        __all__.creep_base_defender = creep_base_defender;
                        __all__.creep_base_dismantler = creep_base_dismantler;
                        __all__.creep_base_full_move_dismantler = creep_base_full_move_dismantler;
                        __all__.creep_base_full_move_goader = creep_base_full_move_goader;
                        __all__.creep_base_full_move_healer = creep_base_full_move_healer;
                        __all__.creep_base_full_move_power_attack = creep_base_full_move_power_attack;
                        __all__.creep_base_full_upgrader = creep_base_full_upgrader;
                        __all__.creep_base_goader = creep_base_goader;
                        __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
                        __all__.creep_base_half_move_healer = creep_base_half_move_healer;
                        __all__.creep_base_hauler = creep_base_hauler;
                        __all__.creep_base_mammoth_miner = creep_base_mammoth_miner;
                        __all__.creep_base_power_attack = creep_base_power_attack;
                        __all__.creep_base_rampart_defense = creep_base_rampart_defense;
                        __all__.creep_base_ranged_offense = creep_base_ranged_offense;
                        __all__.creep_base_reserving = creep_base_reserving;
                        __all__.creep_base_scout = creep_base_scout;
                        __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
                        __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
                        __all__.creep_base_worker = creep_base_worker;
                        __all__.default_roles = default_roles;
                        __all__.flags = flags;
                        __all__.get_basic_cost_matrix = get_basic_cost_matrix;
                        __all__.get_cost_matrix_for_creep = get_cost_matrix_for_creep;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.gmem_key_last_room_state_refresh = gmem_key_last_room_state_refresh;
                        __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
                        __all__.hostile_utils = hostile_utils;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
                        __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
                        __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
                        __all__.move_prototype = move_prototype;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.old_role_names = old_role_names;
                        __all__.recycle_time = recycle_time;
                        __all__.request_priority_economy = request_priority_economy;
                        __all__.request_priority_helping_party = request_priority_helping_party;
                        __all__.request_priority_imminent_threat_defense = request_priority_imminent_threat_defense;
                        __all__.request_priority_low = request_priority_low;
                        __all__.rmem_key_building_paused = rmem_key_building_paused;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.rmem_key_cache = rmem_key_cache;
                        __all__.rmem_key_carry_parts_by_role = rmem_key_carry_parts_by_role;
                        __all__.rmem_key_creeps_by_role = rmem_key_creeps_by_role;
                        __all__.rmem_key_creeps_by_role_and_replacement_time = rmem_key_creeps_by_role_and_replacement_time;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                        __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
                        __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
                        __all__.rmem_key_flag_for_testing_spawning_in_simulation = rmem_key_flag_for_testing_spawning_in_simulation;
                        __all__.rmem_key_focusing_home = rmem_key_focusing_home;
                        __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
                        __all__.rmem_key_metadata = rmem_key_metadata;
                        __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
                        __all__.rmem_key_now_supporting = rmem_key_now_supporting;
                        __all__.rmem_key_pause_all_room_operations = rmem_key_pause_all_room_operations;
                        __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
                        __all__.rmem_key_prepping_defenses = rmem_key_prepping_defenses;
                        __all__.rmem_key_remotes_explicitly_marked_under_attack = rmem_key_remotes_explicitly_marked_under_attack;
                        __all__.rmem_key_remotes_safe_when_under_siege = rmem_key_remotes_safe_when_under_siege;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.rmem_key_spawn_requests = rmem_key_spawn_requests;
                        __all__.rmem_key_sponsor = rmem_key_sponsor;
                        __all__.rmem_key_storage_use_enabled = rmem_key_storage_use_enabled;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
                        __all__.rmem_key_total_open_source_spaces = rmem_key_total_open_source_spaces;
                        __all__.rmem_key_upgrading_paused = rmem_key_upgrading_paused;
                        __all__.rmem_key_work_parts_by_role = rmem_key_work_parts_by_role;
                        __all__.role_bases = role_bases;
                        __all__.role_builder = role_builder;
                        __all__.role_cleanup = role_cleanup;
                        __all__.role_colonist = role_colonist;
                        __all__.role_defender = role_defender;
                        __all__.role_energy_grab = role_energy_grab;
                        __all__.role_hauler = role_hauler;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_miner = role_miner;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.role_mineral_miner = role_mineral_miner;
                        __all__.role_mineral_steal = role_mineral_steal;
                        __all__.role_movement_types = role_movement_types;
                        __all__.role_power_attack = role_power_attack;
                        __all__.role_power_cleanup = role_power_cleanup;
                        __all__.role_ranged_offense = role_ranged_offense;
                        __all__.role_recycling = role_recycling;
                        __all__.role_remote_mining_reserve = role_remote_mining_reserve;
                        __all__.role_room_reserve = role_room_reserve;
                        __all__.role_scout = role_scout;
                        __all__.role_simple_claim = role_simple_claim;
                        __all__.role_simple_dismantle = role_simple_dismantle;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_spawn_fill_backup = role_spawn_fill_backup;
                        __all__.role_td_goad = role_td_goad;
                        __all__.role_td_healer = role_td_healer;
                        __all__.role_temporary_replacing = role_temporary_replacing;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.role_tower_fill_once = role_tower_fill_once;
                        __all__.role_upgrade_fill = role_upgrade_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.role_wall_defender = role_wall_defender;
                        __all__.target_big_big_repair = target_big_big_repair;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_construction = target_construction;
                        __all__.target_destruction_site = target_destruction_site;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                        __all__.target_home_flag = target_home_flag;
                        __all__.target_rampart_defense = target_rampart_defense;
                        __all__.target_refill = target_refill;
                        __all__.target_repair = target_repair;
                        __all__.target_reserve_now = target_reserve_now;
                        __all__.target_single_flag = target_single_flag;
                        __all__.target_single_flag2 = target_single_flag2;
                        __all__.target_source = target_source;
                        __all__.target_spawn_deposit = target_spawn_deposit;
                        __all__.target_tower_fill = target_tower_fill;
                        __all__.volatile_cache = volatile_cache;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.base', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var target_source = __init__ (__world__.constants).target_source;
                    var walkby_move = __init__ (__world__.creep_management.walkby_move);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var movement = __init__ (__world__.utilities.movement);
                    var _REUSE_PATH = 100;
                    var _WITH_ROAD_PF_OPTIONS = {'maxRooms': 10, 'maxOps': 4000, 'reusePath': _REUSE_PATH, 'plainCost': 2, 'swampCost': 10};
                    var _NO_ROAD_PF_OPTIONS = {'maxRooms': 10, 'maxOps': 4000, 'reusePath': _REUSE_PATH, 'plainCost': 1, 'swampCost': 5};
                    var RoleBase = __class__ ('RoleBase', [object], {
                        get __init__ () {return __get__ (this, function (self, hive, targets, home, creep) {
                            self.hive = hive;
                            self.targets = targets;
                            self.home = home;
                            self.creep = creep;
                            if (creep.memory) {
                                self.memory = creep.memory;
                            }
                            else if (Memory.creeps [creep.name]) {
                                self.memory = Memory.creeps [creep.name];
                            }
                            else {
                                var memory = {'targets': {}, 'path': {}};
                                Memory.creeps [creep.name] = memory;
                                self.memory = memory;
                            }
                            self._room = null;
                        });},
                        get get_name () {return __get__ (this, function (self) {
                            return self.creep.name;
                        }, 'get_name');},
                        get get_pos () {return __get__ (this, function (self) {
                            return self.creep.pos;
                        }, 'get_pos');},
                        get get_room () {return __get__ (this, function (self) {
                            if (!(self._room)) {
                                self._room = self.hive.get_room (self.creep.room.name);
                                if (!(self._room)) {
                                    self.log ("ERROR: can't find room we're in from hive! Room: {}".format (self.creep.room.name));
                                }
                            }
                            return self._room;
                        }, 'get_room');},
                        get get_replacement_time () {return __get__ (this, function (self) {
                            if (('calculated_replacement_time' in self.memory)) {
                                return self.memory.calculated_replacement_time;
                            }
                            else {
                                var store = true;
                                var ticks_to_live = self.creep.ticksToLive;
                                if (!(ticks_to_live)) {
                                    if (self.creep.spawning) {
                                        var ticks_to_live = 1500;
                                        var store = false;
                                    }
                                    else {
                                        self.log ('ticksToLive is not defined, while spawning is false!');
                                    }
                                }
                                var ttr = self._calculate_time_to_replace ();
                                if (ttr == -(1)) {
                                    var ttr = RoleBase._calculate_time_to_replace (self);
                                    var store = false;
                                }
                                var replacement_time = (Game.time + ticks_to_live) - ttr;
                                if (store) {
                                    self.memory.calculated_replacement_time = math.floor (replacement_time);
                                }
                                return self.memory.calculated_replacement_time;
                            }
                        }, 'get_replacement_time');},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            return recycle_time + _.size (self.creep.body) * 3;
                        }, '_calculate_time_to_replace');},
                        get run () {return __get__ (this, function (self) {
                            // pass;
                        }, 'run');},
                        get _move_options () {return __get__ (this, function (self, target_room) {
                            var roads = self.creep.getActiveBodyparts (MOVE) < len (self.creep.body) / 2;
                            if (roads) {
                                var options = _WITH_ROAD_PF_OPTIONS;
                            }
                            else {
                                var options = _NO_ROAD_PF_OPTIONS;
                            }
                            options ['roomCallback'] = walkby_move.create_cost_callback (self, roads, target_room);
                            return options;
                        }, '_move_options');},
                        get _try_move_to () {return __get__ (this, function (self, pos) {
                            var here = self.creep.pos;
                            if (here == pos) {
                                return OK;
                            }
                            else if (here.isNearTo (pos)) {
                                self.basic_move_to (pos);
                                return OK;
                            }
                            var move_opts = self._move_options (pos.roomName);
                            var result = self.creep.moveTo (pos, move_opts);
                            if (result == -(2)) {
                                self.basic_move_to (pos);
                            }
                            return result;
                        });},
                        get move_to () {return __get__ (this, function (self, target) {
                            if (self.creep.fatigue <= 0) {
                                if (target.pos) {
                                    var target = target.pos;
                                }
                                var result = self._try_move_to (target);
                                if (result == ERR_NO_BODYPART) {
                                    self.log ("Couldn't move, all move parts dead!");
                                    var tower_here = false;
                                    var __iterable0__ = self.room.find (FIND_STRUCTURES);
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var struct = __iterable0__ [__index0__];
                                        if (struct.structureType == STRUCTURE_TOWER) {
                                            var tower_here = true;
                                            break;
                                        }
                                    }
                                    if (!(tower_here)) {
                                        self.creep.suicide ();
                                        self.home.check_all_creeps_next_tick ();
                                    }
                                }
                                else if (result != OK) {
                                    if (result != ERR_NOT_FOUND && (result != ERR_NO_PATH || self.pos.x != 49 && self.pos.y != 49 && self.pos.x != 0 && self.pos.y != 0)) {
                                        self.log ('WARNING: Unknown result from ({} at {}:{},{}).moveTo({}:{},{}): {}', self.memory.role, self.pos.roomName, self.pos.x, self.pos.y, target.roomName, target.x, target.y, result);
                                    }
                                }
                            }
                        });},
                        get harvest_energy () {return __get__ (this, function (self) {
                            if (self.home.full_storage_use || self.home.room.storage && !(self.home.any_local_miners ()) && (self.memory.role == role_spawn_fill || self.memory.role == role_tower_fill)) {
                                var storage = self.home.room.storage;
                                if (self.carry_sum () == self.creep.carry.energy) {
                                    var target = self.targets.get_new_target (self, target_closest_energy_site);
                                    if (!(target)) {
                                        var target = storage;
                                    }
                                    else if (target.energy <= 0 && !(self.home.links.enabled)) {
                                        var target = storage;
                                    }
                                    else if (target.pos.inRangeTo (self.home.room.controller, 4)) {
                                        var target = storage;
                                    }
                                    else if (self.pos.getRangeTo (target) > self.pos.getRangeTo (storage)) {
                                        var target = storage;
                                    }
                                    if (target.structureType == STRUCTURE_LINK) {
                                        self.home.links.register_target_withdraw (target, self, self.creep.carryCapacity - self.creep.carry.energy, self.pos.getRangeTo (target));
                                    }
                                }
                                else {
                                    var target = storage;
                                }
                                if (!(self.pos.isNearTo (target))) {
                                    if (self.creep.carry.energy > 0.4 * self.creep.carryCapacity && self.pos.getRangeTo (target) > 5) {
                                        self.memory.filling = false;
                                    }
                                    self.move_to (target);
                                    return false;
                                }
                                if (self.carry_sum () > self.creep.carry.energy) {
                                    var resource = _.findKey (self.creep.carry);
                                    var result = self.creep.transfer (target, resource);
                                }
                                else {
                                    var result = self.creep.withdraw (target, RESOURCE_ENERGY);
                                }
                                if (result == OK) {
                                    // pass;
                                }
                                else if (result == ERR_NOT_ENOUGH_RESOURCES) {
                                    if (target == storage) {
                                        self.log ('Storage empty in {}!'.format (target.pos.roomName));
                                    }
                                    else {
                                        self.move_around (target);
                                    }
                                }
                                else {
                                    self.log ('Unknown result from creep.withdraw({}): {}', target, result);
                                }
                                return false;
                            }
                            var source = self.targets.get_new_target (self, target_source);
                            if (!(source)) {
                                if (self.creep.hasActiveBodyparts (WORK)) {
                                    self.log ("Wasn't able to find a source!");
                                    self.finished_energy_harvest ();
                                }
                                if (self.creep.carry.energy > 10 && self.memory.filling) {
                                    self.memory.filling = false;
                                    return true;
                                }
                                self.go_to_depot ();
                                return false;
                            }
                            if (self.pos.roomName != source.pos.roomName) {
                                self.move_to (source);
                                return false;
                            }
                            var piles = self.room.find_in_range (FIND_DROPPED_ENERGY, 3, source.pos);
                            if (len (piles) > 0) {
                                var pile = _.max (piles, 'amount');
                                if (!(self.creep.pos.isNearTo (pile))) {
                                    if (self.creep.carry.energy > 0.4 * self.creep.carryCapacity && self.pos.getRangeTo (pile) > 5) {
                                        self.memory.filling = false;
                                    }
                                    self.move_to (pile);
                                    return false;
                                }
                                var result = self.creep.pickup (pile);
                                if (result == OK) {
                                    self.creep.picked_up = true;
                                    pile.picked_up = true;
                                }
                                else {
                                    self.log ('Unknown result from creep.pickup({}): {}', pile, result);
                                }
                                return false;
                            }
                            var containers = _.filter (self.room.find_in_range (FIND_STRUCTURES, 3, source.pos), {'structureType': STRUCTURE_CONTAINER});
                            if (len (containers) > 0) {
                                var container = containers [0];
                                if (!(self.pos.isNearTo (container))) {
                                    if (self.creep.carry.energy > 0.4 * self.creep.carryCapacity && self.pos.getRangeTo (container) > 5) {
                                        self.memory.filling = false;
                                    }
                                    self.move_to (container);
                                }
                                var result = self.creep.withdraw (container, RESOURCE_ENERGY);
                                if (result != OK) {
                                    self.log ('Unknown result from creep.withdraw({}): {}', container, result);
                                }
                                return false;
                            }
                            var miner = _.find (self.home.find_in_range (FIND_MY_CREEPS, 1, source), (function __lambda__ (c) {
                                return c.memory.role == role_miner;
                            }));
                            if (miner) {
                                if (!(self.pos.isNearTo (miner))) {
                                    if (self.creep.carry.energy > 0.4 * self.creep.carryCapacity && self.pos.getRangeTo (miner) > 5) {
                                        self.memory.filling = false;
                                    }
                                    if (_.sum (self.room.find_in_range (FIND_DROPPED_ENERGY, 1, source.pos), 'amount') > 1500) {
                                        self.move_to (miner);
                                    }
                                    self.move_to (miner);
                                }
                                return false;
                            }
                            if (_.find (self.room.find_in_range (FIND_MY_CREEPS, 2, self.pos), (function __lambda__ (c) {
                                return c.memory.role == role_miner;
                            }))) {
                                self.go_to_depot ();
                                return false;
                            }
                            if (!(self.creep.hasActiveBodyparts (WORK))) {
                                self.go_to_depot ();
                                self.finished_energy_harvest ();
                                return false;
                            }
                            if (source.energy <= 2 && __mod__ (Game.time, 10) == 5 && source.ticksToRegeneration >= 50) {
                                if (_.find (self.home.sources, (function __lambda__ (s) {
                                    return s.energy > 0;
                                }))) {
                                    self.targets.untarget (self, target_source);
                                }
                                else if (self.creep.carry.energy >= 100) {
                                    self.memory.filling = false;
                                }
                            }
                            if (!(self.pos.isNearTo (source))) {
                                self.move_to (source);
                                return false;
                            }
                            var result = self.creep.harvest (source);
                            if (result != OK && result != ERR_NOT_ENOUGH_RESOURCES) {
                                self.log ('Unknown result from creep.harvest({}): {}', source, result);
                            }
                            return false;
                        });},
                        get finished_energy_harvest () {return __get__ (this, function (self) {
                            self.targets.untarget (self, target_source);
                            self.targets.untarget (self, target_closest_energy_site);
                        });},
                        get repair_nearby_roads () {return __get__ (this, function (self) {
                            if (!(self.creep.hasActiveBodyparts (WORK))) {
                                return false;
                            }
                            if (self.creep.carry.energy <= 0) {
                                return false;
                            }
                            var road = _.find (self.room.look_at (LOOK_STRUCTURES, self.pos), (function __lambda__ (s) {
                                return s.structureType == STRUCTURE_ROAD;
                            }));
                            if (road) {
                                if (road.hits < road.hitsMax && road.hitsMax - road.hits >= REPAIR_POWER * self.creep.getActiveBodyparts (WORK)) {
                                    var result = self.creep.repair (road);
                                    if (result == OK) {
                                        return true;
                                    }
                                    else {
                                        self.log ('Unknown result from passingby-road-repair on {}: {}'.format (road, result));
                                    }
                                }
                            }
                            else {
                                var build = self.room.look_at (LOOK_CONSTRUCTION_SITES, self.pos);
                                if (len (build)) {
                                    var build = _.find (build, (function __lambda__ (s) {
                                        return s.structureType == STRUCTURE_ROAD;
                                    }));
                                    if (build) {
                                        var result = self.creep.build (build);
                                        if (result == OK) {
                                            return true;
                                        }
                                        else {
                                            self.log ('Unknown result from passingby-road-build on {}: {}'.format (build, result));
                                        }
                                    }
                                }
                            }
                            return false;
                        });},
                        get find_depot () {return __get__ (this, function (self) {
                            var depots = flags.find_flags (self.home, DEPOT);
                            if (len (depots)) {
                                var depot = depots [0].pos;
                            }
                            else {
                                self.log ('WARNING: No depots found in {}!'.format (self.home.name));
                                self.home.building.place_depot_flag ();
                                var depots = flags.find_flags_global (DEPOT);
                                if (len (depots)) {
                                    var depot = depots [0].pos;
                                }
                                else if (self.home.spawn) {
                                    var depot = self.home.spawn.pos;
                                }
                                else {
                                    var depot = movement.find_an_open_space (self.home.name);
                                }
                            }
                            return depot;
                        });},
                        get go_to_depot () {return __get__ (this, function (self) {
                            var depot = self.find_depot ();
                            if (!(self.pos.isEqualTo (depot) || self.pos.isNearTo (depot) && !(movement.is_block_clear (self.home, depot.x, depot.y)))) {
                                self.move_to (depot);
                            }
                        });},
                        get _log_recycling () {return __get__ (this, function (self) {
                            if (self.creep.ticksToLive > 50) {
                                if (self.memory.role == role_recycling) {
                                    self.log ('{} recycled (ttl: {}).', self.memory.last_role, self.creep.ticksToLive);
                                }
                                else {
                                    self.log ('{} committed suicide (ttl: {}).', self.memory.role, self.creep.ticksToLive);
                                }
                            }
                        });},
                        get recycle_me () {return __get__ (this, function (self) {
                            var spawn = self.home.spawns [0];
                            if (!(spawn)) {
                                if (self.creep.ticksToLive > 50) {
                                    self.go_to_depot ();
                                }
                                else {
                                    self._log_recycling ();
                                    self.creep.suicide ();
                                }
                                return ;
                            }
                            if (!(self.pos.isNearTo (spawn))) {
                                if (self.pos.getRangeTo (spawn) + 20 > self.creep.ticksToLive) {
                                    self._log_recycling ();
                                    self.creep.suicide ();
                                }
                                else {
                                    self.move_to (self.home.spawns [0]);
                                }
                            }
                            else {
                                var result = spawn.recycleCreep (self.creep);
                                if (result == OK) {
                                    self._log_recycling ();
                                    self.home.check_all_creeps_next_tick ();
                                }
                                else {
                                    self.log ('Unknown result from {}.recycleCreep({})! {}', spawn, self.creep, result);
                                    self.go_to_depot ();
                                }
                            }
                        });},
                        get empty_to_storage () {return __get__ (this, function (self) {
                            var total = self.carry_sum ();
                            if (total > 0) {
                                var storage = self.home.room.storage;
                                if (storage) {
                                    if (self.pos.isNearTo (storage)) {
                                        var __break0__ = false;
                                        var __iterable0__ = Object.keys (self.creep.carry);
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var rtype = __iterable0__ [__index0__];
                                            if (self.creep.carry [rtype] > 0) {
                                                var result = self.creep.transfer (storage, rtype);
                                                if (result == OK) {
                                                    return true;
                                                }
                                                else {
                                                    self.log ('Unknown result from creep.transfer({}, {}): {}'.format (storage, rtype, result));
                                                }
                                            }
                                        }
                                        if (!__break0__) {
                                            self.log ("[empty_to_storage] Couldn't find resource to empty!");
                                        }
                                    }
                                    else {
                                        self.move_to (storage);
                                        return true;
                                    }
                                }
                                else {
                                    self.log ("Can't empty to storage: no storage!");
                                }
                            }
                            return false;
                        });},
                        get move_around () {return __get__ (this, function (self, target) {
                            if (__mod__ (Game.time, 7) < 4) {
                                self.move_around_clockwise (target);
                            }
                            else {
                                self.move_around_counter_clockwise (target);
                            }
                        });},
                        get move_around_clockwise () {return __get__ (this, function (self, target) {
                            if (self.creep.fatigue > 0) {
                                return ;
                            }
                            var direction = target.pos.getDirectionTo (self.pos);
                            if (direction == TOP_LEFT || direction == TOP) {
                                self.creep.move (RIGHT);
                            }
                            else if (direction == TOP_RIGHT || direction == RIGHT) {
                                self.creep.move (BOTTOM);
                            }
                            else if (direction == BOTTOM_RIGHT || direction == BOTTOM) {
                                self.creep.move (LEFT);
                            }
                            else if (direction == BOTTOM_LEFT || direction == LEFT) {
                                self.creep.move (TOP);
                            }
                        });},
                        get move_around_counter_clockwise () {return __get__ (this, function (self, target) {
                            if (self.creep.fatigue > 0) {
                                return ;
                            }
                            var direction = target.pos.getDirectionTo (self.pos);
                            if (direction == TOP_RIGHT || direction == TOP) {
                                self.creep.move (LEFT);
                            }
                            else if (direction == BOTTOM_RIGHT || direction == RIGHT) {
                                self.creep.move (TOP);
                            }
                            else if (direction == BOTTOM_LEFT || direction == BOTTOM) {
                                self.creep.move (RIGHT);
                            }
                            else if (direction == TOP_LEFT || direction == LEFT) {
                                self.creep.move (BOTTOM);
                            }
                        });},
                        get basic_move_to () {return __get__ (this, function (self, target) {
                            if (self.creep.fatigue > 0) {
                                return true;
                            }
                            if (target.pos) {
                                var target = target.pos;
                            }
                            if (self.pos.isEqualTo (target)) {
                                return false;
                            }
                            var adx = target.x - self.pos.x;
                            var ady = target.y - self.pos.y;
                            if (target.roomName != self.pos.roomName) {
                                var __left0__ = movement.parse_room_to_xy (self.pos.roomName);
                                var room1x = __left0__ [0];
                                var room1y = __left0__ [1];
                                var __left0__ = movement.parse_room_to_xy (target.roomName);
                                var room2x = __left0__ [0];
                                var room2y = __left0__ [1];
                                adx += (room2x - room1x) * 50;
                                ady += (room2y - room1y) * 50;
                            }
                            var dx = Math.sign (adx);
                            var dy = Math.sign (ady);
                            if (dx && dy) {
                                if (movement.is_block_clear (self.room, self.pos.x + dx, self.pos.y + dy)) {
                                    self.creep.move (movement.dxdy_to_direction (dx, dy));
                                    return true;
                                }
                                else if (adx == 1 && ady == 1) {
                                    return false;
                                }
                                else if (movement.is_block_clear (self.room, self.pos.x + dx, self.pos.y)) {
                                    self.creep.move (movement.dxdy_to_direction (dx, 0));
                                    return true;
                                }
                                else if (movement.is_block_clear (self.room, self.pos.y + dy, self.pos.x)) {
                                    self.creep.move (movement.dxdy_to_direction (0, dy));
                                    return true;
                                }
                            }
                            else if (dx) {
                                if (movement.is_block_clear (self.room, self.pos.x + dx, self.pos.y)) {
                                    self.creep.move (movement.dxdy_to_direction (dx, 0));
                                    return true;
                                }
                                else if (adx == 1) {
                                    return false;
                                }
                                else if (movement.is_block_clear (self.room, self.pos.x + dx, self.pos.y + 1)) {
                                    self.creep.move (movement.dxdy_to_direction (dx, 1));
                                    return true;
                                }
                                else if (movement.is_block_clear (self.room, self.pos.x + dx, self.pos.y - 1)) {
                                    self.creep.move (movement.dxdy_to_direction (dx, -(1)));
                                    return true;
                                }
                            }
                            else if (dy) {
                                if (movement.is_block_clear (self.room, self.pos.x, self.pos.y + dy)) {
                                    self.creep.move (movement.dxdy_to_direction (0, dy));
                                    return true;
                                }
                                else if (ady == 1) {
                                    return false;
                                }
                                else if (movement.is_block_clear (self.room, self.pos.x + 1, self.pos.y + dy)) {
                                    self.creep.move (movement.dxdy_to_direction (1, dy));
                                    return true;
                                }
                                else if (movement.is_block_clear (self.room, self.pos.x - 1, self.pos.y + dy)) {
                                    self.creep.move (movement.dxdy_to_direction (-(1), dy));
                                    return true;
                                }
                            }
                            return false;
                        });},
                        get _try_force_move_to () {return __get__ (this, function (self, x, y, creep_cond) {
                            if (typeof creep_cond == 'undefined' || (creep_cond != null && creep_cond .hasOwnProperty ("__kwargtrans__"))) {;
                                var creep_cond = (function __lambda__ (x) {
                                    return true;
                                });
                            };
                            if (x > 49 || y > 49 || x < 0 || y < 0) {
                                return false;
                            }
                            if (Game.map.getTerrainAt (x, y, self.room.room.name) == 'wall') {
                                return false;
                            }
                            var __iterable0__ = self.room.look_at (LOOK_STRUCTURES, x, y);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var struct = __iterable0__ [__index0__];
                                if ((struct.structureType != STRUCTURE_RAMPART || !(struct.my)) && struct.structureType != STRUCTURE_CONTAINER && struct.structureType != STRUCTURE_ROAD) {
                                    return false;
                                }
                            }
                            var __iterable0__ = self.room.look_at (LOOK_CONSTRUCTION_SITES, x, y);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var struct = __iterable0__ [__index0__];
                                if (struct.my && struct.structureType != STRUCTURE_RAMPART && struct.structureType != STRUCTURE_CONTAINER && struct.structureType != STRUCTURE_ROAD) {
                                    return false;
                                }
                            }
                            var creeps = self.room.look_at (LOOK_CREEPS, x, y);
                            if (len (creeps)) {
                                var other = creeps [0];
                                if (!(other) || !(other.my)) {
                                    print ('{} has length, but {}[0] == {}!'.format (creeps, creeps, other));
                                    return false;
                                }
                                if (!(creep_cond (other))) {
                                    return false;
                                }
                                other.move (movement.dxdy_to_direction (self.pos.x - x, self.pos.y - y));
                                other._forced_move = true;
                            }
                            self.creep.move (movement.dxdy_to_direction (x - self.pos.x, y - self.pos.y));
                            return true;
                        }, '_try_force_move_to');},
                        get force_basic_move_to () {return __get__ (this, function (self, target, creep_cond) {
                            if (typeof creep_cond == 'undefined' || (creep_cond != null && creep_cond .hasOwnProperty ("__kwargtrans__"))) {;
                                var creep_cond = (function __lambda__ (x) {
                                    return true;
                                });
                            };
                            if (self.creep.fatigue > 0) {
                                return true;
                            }
                            if (target.pos) {
                                var target = target.pos;
                            }
                            if (self.pos.isNearTo (target)) {
                                return true;
                            }
                            var adx = target.x - self.pos.x;
                            var ady = target.y - self.pos.y;
                            var dx = Math.sign (adx);
                            var dy = Math.sign (ady);
                            if (dx && dy) {
                                if (self._try_force_move_to (self.pos.x + dx, self.pos.y + dy, creep_cond)) {
                                    return true;
                                }
                                else if (adx == 1 && ady == 1) {
                                    return false;
                                }
                                else if (self._try_force_move_to (self.pos.x + dx, self.pos.y, creep_cond)) {
                                    return true;
                                }
                                else if (self._try_force_move_to (self.pos.x, self.pos.y + dy, creep_cond)) {
                                    return true;
                                }
                            }
                            else if (dx) {
                                if (self._try_force_move_to (self.pos.x + dx, self.pos.y, creep_cond)) {
                                    return true;
                                }
                                else if (adx == 1) {
                                    return false;
                                }
                                else if (self._try_force_move_to (self.pos.x + dx, self.pos.y + 1, creep_cond)) {
                                    return true;
                                }
                                else if (self._try_force_move_to (self.pos.x + dx, self.pos.y - 1, creep_cond)) {
                                    return true;
                                }
                            }
                            else if (dy) {
                                if (self._try_force_move_to (self.pos.x, self.pos.y + dy, creep_cond)) {
                                    return true;
                                }
                                else if (ady == 1) {
                                    return false;
                                }
                                else if (self._try_force_move_to (self.pos.x + 1, self.pos.y + dy, creep_cond)) {
                                    return true;
                                }
                                else if (self._try_force_move_to (self.pos.x - 1, self.pos.y + dy, creep_cond)) {
                                    return true;
                                }
                            }
                            return false;
                        });},
                        get log () {return __get__ (this, function (self, format_string) {
                            var args = tuple ([].slice.apply (arguments).slice (2));
                            if (len (args)) {
                                print ('[{}][{}] {}'.format (self.home.name, self.name, format_string.format.apply (null, args)));
                            }
                            else {
                                print ('[{}][{}] {}'.format (self.home.name, self.name, format_string));
                            }
                        });},
                        get should_pickup () {return __get__ (this, function (self, resource_type) {
                            if (typeof resource_type == 'undefined' || (resource_type != null && resource_type .hasOwnProperty ("__kwargtrans__"))) {;
                                var resource_type = null;
                            };
                            return resource_type === null || resource_type == RESOURCE_ENERGY;
                        }, 'should_pickup');},
                        get carry_sum () {return __get__ (this, function (self) {
                            if (!('_carry_sum' in self.creep)) {
                                self.creep._carry_sum = _.sum (self.creep.carry);
                            }
                            return self.creep._carry_sum;
                        }, 'carry_sum');},
                        get toString () {return __get__ (this, function (self) {
                            return 'Creep[{}, role: {}, home: {}]'.format (self.name, self.memory.role, self.home.name);
                        }, 'toString');}
                    });
                    Object.defineProperty (RoleBase, 'name', property.call (RoleBase, RoleBase.get_name));;
                    Object.defineProperty (RoleBase, 'pos', property.call (RoleBase, RoleBase.get_pos));;
                    Object.defineProperty (RoleBase, 'room', property.call (RoleBase, RoleBase.get_room));;
                    __pragma__ ('<use>' +
                        'constants' +
                        'creep_management.walkby_move' +
                        'jstools.screeps_constants' +
                        'math' +
                        'position_management.flags' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.DEPOT = DEPOT;
                        __all__.RoleBase = RoleBase;
                        __all__._NO_ROAD_PF_OPTIONS = _NO_ROAD_PF_OPTIONS;
                        __all__._REUSE_PATH = _REUSE_PATH;
                        __all__._WITH_ROAD_PF_OPTIONS = _WITH_ROAD_PF_OPTIONS;
                        __all__.flags = flags;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.recycle_time = recycle_time;
                        __all__.role_miner = role_miner;
                        __all__.role_recycling = role_recycling;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_source = target_source;
                        __all__.walkby_move = walkby_move;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.behaviors.military', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var center_pos = __init__ (__world__.utilities.movement).center_pos;
                    var chebyshev_distance_room_pos = __init__ (__world__.utilities.movement).chebyshev_distance_room_pos;
                    var distance_squared_room_pos = __init__ (__world__.utilities.movement).distance_squared_room_pos;
                    var find_an_open_space = __init__ (__world__.utilities.movement).find_an_open_space;
                    var get_entrance_for_exit_pos = __init__ (__world__.utilities.movement).get_entrance_for_exit_pos;
                    var is_block_clear = __init__ (__world__.utilities.movement).is_block_clear;
                    var parse_room_to_xy = __init__ (__world__.utilities.movement).parse_room_to_xy;
                    var room_xy_to_name = __init__ (__world__.utilities.movement).room_xy_to_name;
                    var MilitaryBase = __class__ ('MilitaryBase', [RoleBase], {
                        get _find_nearest_junctions () {return __get__ (this, function (self) {
                            var __left0__ = parse_room_to_xy (self.pos.roomName);
                            var x = __left0__ [0];
                            var y = __left0__ [1];
                            if (x == 0 && y == 0 && self.pos.roomName == 'sim') {
                                return [];
                            }
                            var rrx = __mod__ ((x < 0 ? -(x) - 1 : x), 10);
                            var rry = __mod__ ((y < 0 ? -(y) - 1 : y), 10);
                            var floor_thing = function (coord) {
                                if (coord < 0) {
                                    return math.floor ((coord + 1) / 10) * 10 - 1;
                                }
                                else {
                                    return math.floor (coord / 10) * 10;
                                }
                            };
                            var ceil_thing = function (coord) {
                                if (coord < 0) {
                                    return math.ceil ((coord + 1) / 10) * 10 - 1;
                                }
                                else {
                                    return math.ceil (coord / 10) * 10;
                                }
                            };
                            if (rrx == 0) {
                                if (rry == 0) {
                                    return [center_pos (room_xy_to_name (x, y))];
                                }
                                else {
                                    return [center_pos (room_xy_to_name (x, floor_thing (y))), center_pos (room_xy_to_name (x, ceil_thing (y)))];
                                }
                            }
                            else if (rry == 0) {
                                return [center_pos (room_xy_to_name (floor_thing (x), y)), center_pos (room_xy_to_name (ceil_thing (x), y))];
                            }
                            else {
                                return [center_pos (room_xy_to_name (floor_thing (x), floor_thing (y))), center_pos (room_xy_to_name (floor_thing (x), ceil_thing (y))), center_pos (room_xy_to_name (ceil_thing (x), floor_thing (y))), center_pos (room_xy_to_name (ceil_thing (x), ceil_thing (y)))];
                            }
                        });},
                        get find_midpoint () {return __get__ (this, function (self, origin, target) {
                            var biggest_midpoint_angle = (math.pi * 2) / 5;
                            var best_midpoint = null;
                            var __iterable0__ = self._find_nearest_junctions ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var junction = __iterable0__ [__index0__];
                                var oj_distance_squared = distance_squared_room_pos (origin, junction);
                                var jt_distance_squared = distance_squared_room_pos (junction, target);
                                var ot_distance_squared = distance_squared_room_pos (origin, target);
                                var junction_angle = math.acos (((oj_distance_squared + jt_distance_squared) - ot_distance_squared) / ((2 * math.sqrt (oj_distance_squared)) * math.sqrt (jt_distance_squared)));
                                if (junction_angle > biggest_midpoint_angle) {
                                    var biggest_midpoint_angle = junction_angle;
                                    var best_midpoint = junction;
                                }
                            }
                            return best_midpoint;
                        });},
                        get _using_reroute () {return __get__ (this, function (self, origin, target) {
                            if (('reroute' in Game.flags) && ('reroute_destination' in Game.flags)) {
                                var reroute_start = Game.flags ['reroute'];
                                var reroute_destination = Game.flags ['reroute_destination'];
                                if (chebyshev_distance_room_pos (origin, reroute_start) + chebyshev_distance_room_pos (reroute_destination, target) < chebyshev_distance_room_pos (origin, target)) {
                                    return true;
                                }
                            }
                            return false;
                        });},
                        get recalc_military_path () {return __get__ (this, function (self, origin, target, opts) {
                            if (typeof opts == 'undefined' || (opts != null && opts .hasOwnProperty ("__kwargtrans__"))) {;
                                var opts = null;
                            };
                            if (opts && ('to_home' in opts)) {
                                var to_home = opts ['to_home'];
                            }
                            else {
                                var to_home = false;
                            }
                            if (origin.pos) {
                                var origin = origin.pos;
                            }
                            if (target.pos) {
                                var target = target.pos;
                            }
                            if (self.creep.fatigue > 0) {
                                return ;
                            }
                            if (self.pos.getRangeTo (target) < 10 || self.pos.roomName == target.roomName) {
                                self.move_to (target);
                                return ;
                            }
                            var path_opts = {'current_room': self.pos.roomName};
                            if (opts) {
                                var path_opts = _.create (path_opts, opts);
                            }
                            if (distance_squared_room_pos (origin, target) > math.pow (200, 2)) {
                                path_opts.max_ops = chebyshev_distance_room_pos (origin, target) * 150;
                                path_opts.max_rooms = math.ceil (chebyshev_distance_room_pos (origin, target) / 5);
                                path_opts.use_roads = false;
                                if (to_home) {
                                    var intermediate = find_an_open_space (origin.roomName);
                                    var origin = intermediate;
                                }
                                else {
                                    var intermediate = center_pos (target.roomName);
                                    if (self.pos.roomName != intermediate.roomName) {
                                        var target = intermediate;
                                        path_opts.range = 10;
                                    }
                                    else {
                                        self.move_to (target);
                                        return ;
                                    }
                                }
                                if (!(self._using_reroute (origin, target))) {
                                    var origin_midpoint = self.find_midpoint (self, origin);
                                    if (origin_midpoint !== null) {
                                        var origin = origin_midpoint;
                                    }
                                    var dest_midpoint = self.find_midpoint (origin, target);
                                    if (dest_midpoint !== null) {
                                        if (self.pos.roomName == dest_midpoint.roomName) {
                                            var origin = dest_midpoint;
                                        }
                                        else {
                                            var target = dest_midpoint;
                                            path_opts.range = 10;
                                        }
                                    }
                                }
                            }
                            self.hive.honey.clear_cached_path (origin, target, path_opts);
                        });},
                        get follow_military_path () {return __get__ (this, function (self, origin, target, opts) {
                            if (typeof opts == 'undefined' || (opts != null && opts .hasOwnProperty ("__kwargtrans__"))) {;
                                var opts = null;
                            };
                            if (opts && ('to_home' in opts)) {
                                var to_home = opts ['to_home'];
                            }
                            else {
                                var to_home = false;
                            }
                            if (origin.pos) {
                                var origin = origin.pos;
                            }
                            if (target.pos) {
                                var target = target.pos;
                            }
                            if (self.creep.fatigue > 0) {
                                return ;
                            }
                            if (self.pos.getRangeTo (target) < 10 || self.pos.roomName == target.roomName) {
                                self.move_to (target);
                                return ;
                            }
                            var path_opts = {'current_room': self.pos.roomName};
                            if (opts) {
                                var path_opts = _.create (path_opts, opts);
                            }
                            if (distance_squared_room_pos (origin, target) > math.pow (200, 2) && !(self._using_reroute (origin, target))) {
                                path_opts.max_ops = chebyshev_distance_room_pos (origin, target) * 150;
                                path_opts.max_rooms = math.ceil (chebyshev_distance_room_pos (origin, target) / 5);
                                if (to_home) {
                                    var intermediate = find_an_open_space (origin.roomName);
                                    var origin = intermediate;
                                }
                                else {
                                    var intermediate = center_pos (target.roomName);
                                    if (self.pos.roomName != intermediate.roomName) {
                                        var target = intermediate;
                                        path_opts.range = max (path_opts.range || 0, 10);
                                    }
                                    else {
                                        self.move_to (target);
                                        return ;
                                    }
                                }
                                // pass;
                                var origin_midpoint = self.find_midpoint (self, origin);
                                if (origin_midpoint !== null) {
                                    var origin = origin_midpoint;
                                }
                                var dest_midpoint = self.find_midpoint (origin, target);
                                if (dest_midpoint !== null) {
                                    if (self.pos.roomName == dest_midpoint.roomName) {
                                        var origin = dest_midpoint;
                                    }
                                    else {
                                        var target = dest_midpoint;
                                        path_opts.range = max (path_opts.range || 0, 10);
                                    }
                                }
                            }
                            var path = self.hive.honey.find_serialized_path (origin, target, path_opts);
                            var result = self.creep.moveByPath (path);
                            if (result == ERR_NOT_FOUND) {
                                if (self.memory.manual) {
                                    self.move_to (target);
                                }
                                else if (!(self.memory.next_ppos)) {
                                    var all_positions = self.hive.honey.list_of_room_positions_in_path (origin, target, path_opts);
                                    var closest = null;
                                    var closest_distance = Infinity;
                                    var __iterable0__ = all_positions;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var pos = __iterable0__ [__index0__];
                                        var distance = chebyshev_distance_room_pos (self.pos, pos);
                                        if (distance < closest_distance) {
                                            var closest_distance = distance;
                                            var closest = pos;
                                        }
                                    }
                                    if (closest) {
                                        self.memory.next_ppos = closest;
                                        if (closest.isEqualTo (self.pos)) {
                                            self.log ('WARNING: ERR_NOT_FOUND when actually still on military path! Path retrieved:\n{}\nPos: {}.'.format (path, self.pos));
                                            if (chebyshev_distance_room_pos (self.pos, target) <= 50) {
                                                self.memory.manual = true;
                                                self.move_to (target);
                                                return ;
                                            }
                                        }
                                    }
                                    else {
                                        self.log ("WARNING: Couldn't find closest position on path from {} to {} near {}!\nMoving manually... (all pos: {})".format (origin, target, self.pos, all_positions));
                                        self.memory.next_ppos = target;
                                    }
                                }
                                var mtarget = self.memory.next_ppos;
                                if (mtarget) {
                                    var new_target = new RoomPosition (mtarget.x, mtarget.y, mtarget.roomName);
                                    if (self.pos.isNearTo (new_target)) {
                                        self.creep.move (self.pos.getDirectionTo (new_target));
                                    }
                                    else {
                                        self.move_to (new_target);
                                    }
                                    if (self.pos.isEqualTo (new_target)) {
                                        delete self.memory.next_ppos;
                                    }
                                    if (!(self.memory.off_path_for)) {
                                        self.memory.off_path_for = 1;
                                        self.memory.lost_path_at = self.pos;
                                    }
                                    else {
                                        if (!(self.memory.lost_path_at)) {
                                            self.memory.lost_path_at = self.pos;
                                        }
                                        self.memory.off_path_for++;
                                        if (self.memory.off_path_for > 10) {
                                            self.log ('Lost the path from {} to {}! Pos: {}. Retargeting to: {}'.format (origin, target, self.pos, new_target));
                                            if (chebyshev_distance_room_pos (self.memory.lost_path_at, self.pos) < 5 && !(self.pos.isEqualTo (new_target)) && !(self.pos.isEqualTo (get_entrance_for_exit_pos (new_target)))) {
                                                self.hive.honey.clear_cached_path (origin, target, path_opts);
                                                delete self.memory.off_path_for;
                                                delete self.memory.lost_path_at;
                                                delete self.memory.next_ppos;
                                            }
                                        }
                                    }
                                }
                            }
                            else if (result != OK) {
                                self.log ('Unknown result from follow_military_path: {}'.format (result));
                            }
                            else if (self.memory.off_path_for) {
                                delete self.memory.next_ppos;
                                delete self.memory.off_path_for;
                                delete self.memory.lost_path_at;
                            }
                            var serialized_pos = self.pos.x | self.pos.y << 6;
                            if (self.memory.last_pos == serialized_pos) {
                                self.log ('Standstill!');
                                if (self.memory.standstill_for) {
                                    self.memory.standstill_for++;
                                }
                                else {
                                    self.memory.standstill_for = 1;
                                }
                                if (self.memory.standstill_for == 5) {
                                    delete self.memory.next_ppos;
                                    var found_mine = false;
                                    var __iterable0__ = self.hive.honey.find_path (origin, target, path_opts);
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var pos = __iterable0__ [__index0__];
                                        if (pos.x == self.pos.x && pos.y == self.pos.y) {
                                            var found_mine = true;
                                        }
                                        else if (found_mine) {
                                            if (is_block_clear (self.room, pos.x, pos.y)) {
                                                self.memory.next_ppos = {'x': pos.x, 'y': pos.y, 'roomName': self.pos.roomName};
                                                self.move_to (new RoomPosition (pos.x, pos.y, self.pos.roomName));
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (self.memory.standstill_for > 10) {
                                    delete self.memory.last_position;
                                    delete self.memory.standstill_for;
                                    delete self.memory.next_ppos;
                                    self.hive.honey.clear_cached_path (origin, target, path_opts);
                                    self.move_to (target);
                                }
                            }
                            else {
                                self.memory.last_pos = serialized_pos;
                                delete self.memory.standstill_for;
                            }
                        });},
                        get get_military_path_length () {return __get__ (this, function (self, spawn, target, opts) {
                            if (typeof opts == 'undefined' || (opts != null && opts .hasOwnProperty ("__kwargtrans__"))) {;
                                var opts = null;
                            };
                            if (spawn.pos) {
                                var spawn = spawn.pos;
                            }
                            if (target.pos) {
                                var target = target.pos;
                            }
                            if (opts) {
                                var path_opts = opts;
                            }
                            else {
                                var path_opts = {};
                            }
                            path_opts.max_ops = chebyshev_distance_room_pos (spawn, target) * 150;
                            path_opts.max_rooms = math.ceil (chebyshev_distance_room_pos (spawn, target) / 5);
                            return self.hive.honey.find_path_length (spawn, target, path_opts);
                        });}
                    });
                    __pragma__ ('<use>' +
                        'creeps.base' +
                        'jstools.screeps_constants' +
                        'math' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.MilitaryBase = MilitaryBase;
                        __all__.RoleBase = RoleBase;
                        __all__.center_pos = center_pos;
                        __all__.chebyshev_distance_room_pos = chebyshev_distance_room_pos;
                        __all__.distance_squared_room_pos = distance_squared_room_pos;
                        __all__.find_an_open_space = find_an_open_space;
                        __all__.get_entrance_for_exit_pos = get_entrance_for_exit_pos;
                        __all__.is_block_clear = is_block_clear;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.parse_room_to_xy = parse_room_to_xy;
                        __all__.room_xy_to_name = room_xy_to_name;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.behaviors.refill', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var creep_base_full_upgrader = __init__ (__world__.constants).creep_base_full_upgrader;
                    var rmem_key_planned_role_to_spawn = __init__ (__world__.constants).rmem_key_planned_role_to_spawn;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var target_big_repair = __init__ (__world__.constants).target_big_repair;
                    var target_construction = __init__ (__world__.constants).target_construction;
                    var target_refill = __init__ (__world__.constants).target_refill;
                    var target_repair = __init__ (__world__.constants).target_repair;
                    var spawning = __init__ (__world__.creep_management.spawning);
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var generate_role_obj = function (room) {
                        if (room.role_count (role_upgrader) >= 6 && !(room.get_target_builder_work_mass ())) {
                            var role = role_upgrader;
                            var base = creep_base_full_upgrader;
                            var num_sections = spawning.max_sections_of (room, base);
                        }
                        else {
                            var role = role_builder;
                            var base = room.get_variable_base (role);
                            var num_sections = spawning.max_sections_of (room, base);
                        }
                        var role_obj = {'role': role, 'base': base, 'num_sections': num_sections};
                        spawning.validate_role (role_obj);
                        return role_obj;
                    };
                    var Refill = __class__ ('Refill', [RoleBase], {
                        get refill_creeps () {return __get__ (this, function (self) {
                            if (!(self.creep.carry.energy)) {
                                self.memory.filling = true;
                                return true;
                            }
                            var target = self.targets.get_new_target (self, target_refill);
                            if (target) {
                                var full = target.energyCapacity && target.energy >= target.energyCapacity || target.storeCapacity && _.sum (target.store) >= target.storeCapacity || target.carryCapacity && _.sum (target.carry) >= target.carryCapacity;
                                if (full) {
                                    self.targets.untarget (self, target_refill);
                                    var target = self.targets.get_new_target (self, target_refill);
                                }
                            }
                            if (target) {
                                if (!(self.pos.isNearTo (target))) {
                                    self.move_to (target);
                                    if (Game.cpu.bucket >= 4000) {
                                        var other = _.find (self.home.find_in_range (FIND_MY_STRUCTURES, 1, self.pos), (function __lambda__ (c) {
                                            return c.energyCapacity && c.energy < c.energyCapacity || c.storeCapacity && _.sum (c.store) < c.storeCapacity;
                                        }));
                                        if (!(other)) {
                                            var other = _.find (self.home.find_in_range (FIND_MY_CREEPS, 1, self.pos), (function __lambda__ (c) {
                                                return c.name != self.name && (c.memory.role == role_builder || c.memory.role == role_upgrader) && _.sum (c.carry) < c.carryCapacity;
                                            }));
                                        }
                                        if (other) {
                                            var result = self.creep.transfer (other, RESOURCE_ENERGY);
                                            if (result == ERR_NOT_ENOUGH_RESOURCES) {
                                                self.memory.filling = true;
                                                return true;
                                            }
                                            else if (result != OK) {
                                                self.log ('Unknown result from passingby refill.transfer({}): {}', other, result);
                                            }
                                        }
                                        return false;
                                    }
                                }
                                var latched = false;
                                if (self.creep.hasActiveBodyparts (WORK) && target.memory && !(target.filling)) {
                                    var role = target.memory.role;
                                    var result = null;
                                    var latched_target = null;
                                    if (role == role_builder) {
                                        var sc_last_action = target.memory.la;
                                        if (sc_last_action == 'r') {
                                            var latched_target = self.targets.get_existing_target (target, target_repair);
                                            if (latched_target) {
                                                var result = self.creep.repair (latched_target);
                                            }
                                        }
                                        else if (sc_last_action == 'c') {
                                            var latched_target = self.targets.get_existing_target (target, target_construction);
                                            if (latched_target) {
                                                var result = self.creep.build (latched_target);
                                            }
                                        }
                                        else if (sc_last_action == 'b') {
                                            var latched_target = self.targets.get_existing_target (target, target_big_repair);
                                            if (latched_target) {
                                                var result = self.creep.repair (latched_target);
                                            }
                                        }
                                    }
                                    else if (role == role_upgrader) {
                                        var latched_target = self.home.room.controller;
                                        var result = self.creep.upgradeController (latched_target);
                                    }
                                    if (result !== null) {
                                        if (result == OK) {
                                            var latched = true;
                                        }
                                        else if (result == ERR_NOT_IN_RANGE) {
                                            self.basic_move_to (latched_target);
                                        }
                                    }
                                }
                                if (Game.cpu.bucket >= 8000 && target.carry) {
                                    var min_cap = 0;
                                    var other = target;
                                    var __iterable0__ = self.home.look_for_in_area_around (LOOK_CREEPS, 1, self.pos);
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var obj = __iterable0__ [__index0__];
                                        var creep = obj.creep;
                                        if ((creep.memory.role == role_builder || creep.memory.role == role_upgrader) && creep.name != self.name) {
                                            var empty_percent = (creep.carryCapacity - _.sum (creep.carry)) / creep.carryCapacity;
                                            if (empty_percent > min_cap) {
                                                var other = creep;
                                                var min_cap = empty_percent;
                                            }
                                        }
                                    }
                                    var __iterable0__ = self.home.look_for_in_area_around (LOOK_STRUCTURES, 1, self.pos);
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var obj = __iterable0__ [__index0__];
                                        var structure = obj.structure;
                                        if (structure.structureType == STRUCTURE_EXTENSION || structure.structureType == STRUCTURE_SPAWN) {
                                            var empty_percent = (0.1 * (structure.energyCapacity - structure.energy)) / structure.energyCapacity;
                                            if (empty_percent > 0.1 && empty_percent > min_cap) {
                                                var other = structure;
                                                var min_cap = empty_percent;
                                            }
                                        }
                                    }
                                    if (other != target) {
                                        var result = self.creep.transfer (other, RESOURCE_ENERGY);
                                        if (result != OK) {
                                            self.log ('Unknown result from passingby refill.transfer({}): {}', other, result);
                                        }
                                        return false;
                                    }
                                }
                                var result = self.creep.transfer (target, RESOURCE_ENERGY);
                                if (result == OK) {
                                    var target_empty = (target.energyCapacity || target.storeCapacity || target.carryCapacity) - (target.energy || target.store && target.store.energy || target.carry && target.carry.energy || 0);
                                    if (!(latched) && self.creep.carry.energy > target_empty) {
                                        volatile_cache.mem ('extensions_filled').set (target.id, true);
                                        if (self.creep.carry.energy - target_empty > 0) {
                                            self.targets.untarget (self, target_refill);
                                            var new_target = self.targets.get_new_target (self, target_refill);
                                            if (new_target && !(self.pos.isNearTo (new_target))) {
                                                self.move_to (new_target);
                                            }
                                        }
                                    }
                                }
                                else if (result == ERR_FULL) {
                                    if (!(latched)) {
                                        self.targets.untarget (self, target_refill);
                                        return true;
                                    }
                                }
                                else {
                                    self.log ('Unknown result from refill.transfer({}): {}', target, result);
                                    self.targets.untarget (self, target_refill);
                                }
                                return false;
                            }
                            else {
                                self.go_to_depot ();
                                if (!(self.home.spawn)) {
                                    return ;
                                }
                                if (!(self.home.spawn.spawning) && self.home.get_next_role () === null) {
                                    self.home.mem [rmem_key_planned_role_to_spawn] = generate_role_obj (self.home);
                                }
                                else {
                                    var v = volatile_cache.volatile ();
                                    if (v.has ('refills_idle')) {
                                        var idle = v.get ('refills_idle') + 1;
                                    }
                                    else {
                                        var idle = 1;
                                    }
                                    if (idle >= 3) {
                                        var role = self.home.get_next_role ();
                                        if (!(role) || role.role == role_hauler || role.role == role_spawn_fill || idle >= 7) {
                                            self.home.mem [rmem_key_planned_role_to_spawn] = generate_role_obj (self.home);
                                            v.set ('refills_idle', -(Infinity));
                                        }
                                    }
                                    else {
                                        v.set ('refills_idle', idle);
                                    }
                                }
                            }
                        });}
                    });
                    __pragma__ ('<use>' +
                        'cache.volatile_cache' +
                        'constants' +
                        'creep_management.spawning' +
                        'creeps.base' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.Refill = Refill;
                        __all__.RoleBase = RoleBase;
                        __all__.creep_base_full_upgrader = creep_base_full_upgrader;
                        __all__.generate_role_obj = generate_role_obj;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
                        __all__.role_builder = role_builder;
                        __all__.role_hauler = role_hauler;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.spawning = spawning;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_construction = target_construction;
                        __all__.target_refill = target_refill;
                        __all__.target_repair = target_repair;
                        __all__.volatile_cache = volatile_cache;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.behaviors.transport', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var movement = __init__ (__world__.utilities.movement);
                    var TransportPickup = __class__ ('TransportPickup', [RoleBase], {
                        get transport () {return __get__ (this, function (self, pickup, fill, paved) {
                            var total_carried_now = self.carry_sum ();
                            if (self.memory.filling) {
                                var target = pickup.pos;
                                if (!(self.creep.carryCapacity)) {
                                    if (self.creep.hits < self.creep.hitsMax && self.home.defense.healing_capable ()) {
                                        if (paved) {
                                            self.follow_energy_path (pickup, fill, pickup);
                                        }
                                        else {
                                            self.follow_energy_path (pickup, fill);
                                        }
                                    }
                                    else {
                                        self.log ('All carry parts dead, committing suicide.');
                                        self.creep.suicide ();
                                    }
                                    return ;
                                }
                                if (total_carried_now >= self.creep.carryCapacity) {
                                    self.memory.filling = false;
                                    if (paved) {
                                        self.repair_nearby_roads ();
                                        self.follow_energy_path (pickup, fill, pickup);
                                    }
                                    else {
                                        self.follow_energy_path (pickup, fill);
                                    }
                                    return ;
                                }
                                if (self.pos.roomName != target.roomName || !(self.pos.inRangeTo (target, 4))) {
                                    if (total_carried_now) {
                                        self.repair_nearby_roads ();
                                    }
                                    self.follow_energy_path (fill, pickup, pickup);
                                    return ;
                                }
                                var piles = self.room.look_for_in_area_around (LOOK_RESOURCES, target, 1);
                                if (len (piles)) {
                                    if (len (piles) > 1) {
                                        var energy = _.max (piles, 'resource.amount').resource;
                                    }
                                    else {
                                        var energy = piles [0].resource;
                                    }
                                    if (self.pos.isNearTo (energy)) {
                                        var result = self.creep.pickup (energy);
                                        if (result == OK) {
                                            self.creep.picked_up = true;
                                            energy.picked_up = true;
                                            if (energy.amount > self.creep.carryCapacity - total_carried_now) {
                                                self.memory.filling = false;
                                                if (paved) {
                                                    self.follow_energy_path (pickup, fill, pickup);
                                                }
                                                else {
                                                    self.follow_energy_path (pickup, fill);
                                                }
                                            }
                                            else if (__mod__ (Game.time, 6) == 1 && self.creep.ticksToLive < 10 + self.path_length (fill, pickup)) {
                                                self.memory.filling = false;
                                                self.follow_energy_path (fill, pickup);
                                                return ;
                                            }
                                        }
                                        else {
                                            self.log ('Unknown result from creep.pickup({}): {}'.format (energy, result));
                                        }
                                    }
                                    else if (self.pos.isNearTo (target)) {
                                        self.basic_move_to (energy);
                                    }
                                    else {
                                        self.follow_energy_path (fill, pickup);
                                    }
                                    return ;
                                }
                                var containers = self.room.look_for_in_area_around (LOOK_STRUCTURES, target, 1);
                                var container = _.find (containers, (function __lambda__ (s) {
                                    return s.structure.structureType == STRUCTURE_CONTAINER || s.structure.structureType == STRUCTURE_STORAGE;
                                }));
                                if (container) {
                                    var container = container.structure;
                                    if (self.pos.isNearTo (container)) {
                                        var mtype = _.findKey (container.store);
                                        var amount = container.store [mtype];
                                        var result = self.creep.withdraw (container, mtype);
                                        if (result != OK) {
                                            self.log ('Unknown result from creep.withdraw({}, {}): {}'.format (container, mtype, result));
                                            return ;
                                        }
                                        if (amount > self.creep.carryCapacity - total_carried_now) {
                                            self.memory.filling = false;
                                            if (paved) {
                                                self.follow_energy_path (pickup, fill, pickup);
                                            }
                                            else {
                                                self.follow_energy_path (pickup, fill);
                                            }
                                        }
                                    }
                                    else if (self.pos.isNearTo (target)) {
                                        self.creep.move (movement.diff_as_direction (self.pos, container));
                                    }
                                    else {
                                        self.follow_energy_path (fill, pickup);
                                    }
                                    return ;
                                }
                                if (!(_.find (self.room.look_for_in_area_around (LOOK_CREEPS, target, 1), (function __lambda__ (o) {
                                    return o.my && o.creep.memory.role == role_miner;
                                })))) {
                                    if (total_carried_now > self.creep.carryCapacity * 0.5) {
                                        self.memory.filling = false;
                                        if (paved) {
                                            self.follow_energy_path (pickup, fill, pickup);
                                        }
                                        else {
                                            self.follow_energy_path (pickup, fill);
                                        }
                                        return ;
                                    }
                                }
                            }
                            else {
                                if (total_carried_now && total_carried_now + 50 >= self.creep.carryCapacity / 2) {
                                    self.repair_nearby_roads ();
                                }
                                if (total_carried_now > self.creep.carry.energy && self.home.room.storage) {
                                    var fill = self.home.room.storage;
                                }
                                else if (total_carried_now <= 0) {
                                    if (self.creep.ticksToLive < 2.2 * self.path_length (fill, pickup)) {
                                        self.creep.suicide ();
                                        return ;
                                    }
                                    self.creep.memory.filling = true;
                                    self.follow_energy_path (fill, pickup);
                                    return ;
                                }
                                var target = fill;
                                if (target.pos) {
                                    var target = target.pos;
                                }
                                if (fill.structureType == STRUCTURE_LINK && self.pos.roomName == target.roomName) {
                                    self.room.links.register_target_deposit (fill, self, self.creep.carry.energy, self.pos.getRangeTo (target));
                                }
                                if (self.pos.roomName != target.roomName || !(self.pos.isNearTo (target))) {
                                    if (paved) {
                                        self.follow_energy_path (pickup, fill, pickup);
                                    }
                                    else {
                                        self.follow_energy_path (pickup, fill);
                                    }
                                    return ;
                                }
                                var energy_only = fill.structureType == STRUCTURE_LINK || fill.structureType == STRUCTURE_SPAWN;
                                if (energy_only) {
                                    var resource = RESOURCE_ENERGY;
                                }
                                else {
                                    var resource = _.findKey (self.creep.carry);
                                }
                                var amount = self.creep.carry [resource];
                                if (resource && amount) {
                                    var result = self.creep.transfer (fill, resource);
                                    if (result != OK && result != ERR_FULL) {
                                        self.log ('Unknown result from transport-creep.transfer({}, {}): {}'.format (fill, resource, result));
                                        var amount = 0;
                                    }
                                }
                                else {
                                    if (self.creep.ticksToLive < 2.2 * self.path_length (fill, pickup)) {
                                        self.creep.suicide ();
                                        return ;
                                    }
                                    self.memory.filling = true;
                                    self.follow_energy_path (fill, pickup);
                                    return ;
                                }
                                if (energy_only) {
                                    var empty = fill.energyCapacity - fill.energy;
                                }
                                else {
                                    var empty = fill.storeCapacity - _.sum (fill.store);
                                }
                                if (min (amount, empty) >= total_carried_now) {
                                    self.follow_energy_path (fill, pickup);
                                    return ;
                                }
                            }
                        });},
                        get path_length () {return __get__ (this, function (self, origin, target) {
                            if (origin.pos) {
                                var origin = origin.pos;
                            }
                            if (target.pos) {
                                var target = target.pos;
                            }
                            return self.hive.honey.find_path_length (origin, target);
                        });},
                        get follow_energy_path () {return __get__ (this, function (self, origin, target, mine) {
                            if (typeof mine == 'undefined' || (mine != null && mine .hasOwnProperty ("__kwargtrans__"))) {;
                                var mine = null;
                            };
                            if (origin.pos) {
                                var origin = origin.pos;
                            }
                            if (target.pos) {
                                var target = target.pos;
                            }
                            if (self.creep.fatigue > 0) {
                                return ;
                            }
                            if (origin.isNearTo (target)) {
                                var origin = self.home.spawn.pos;
                            }
                            var opts = {'current_room': self.pos.roomName, 'paved_for': mine};
                            var path = self.hive.honey.find_serialized_path (origin, target, opts);
                            var result = self.creep.moveByPath (path);
                            if (result == ERR_NOT_FOUND || result == ERR_NO_PATH) {
                                if (self.pos.isNearTo (target)) {
                                    self.basic_move_to (target);
                                    return ;
                                }
                                if (!(self.memory.next_ppos) || self.memory.off_path_for > 10) {
                                    self.memory.off_path_for = 0;
                                    var all_positions = self.hive.honey.list_of_room_positions_in_path (origin, target, opts);
                                    var closest = null;
                                    var closest_distance = Infinity;
                                    var __iterable0__ = enumerate (all_positions);
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var __left0__ = __iterable0__ [__index0__];
                                        var index = __left0__ [0];
                                        var pos = __left0__ [1];
                                        if (movement.chebyshev_distance_room_pos (pos, origin) < 3 || movement.chebyshev_distance_room_pos (pos, target) < 3) {
                                            var room = self.hive.get_room (pos.roomName);
                                            if (room && !(movement.is_block_clear (room, pos.x, pos.y))) {
                                                continue;
                                            }
                                        }
                                        var distance = movement.chebyshev_distance_room_pos (self.pos, pos) - index * 0.7;
                                        if (pos.roomName != self.pos.roomName || pos.x < 2 || pos.x > 48 || pos.y < 2 || pos.y > 48) {
                                            distance += 10;
                                        }
                                        if (distance < closest_distance) {
                                            var closest_distance = distance;
                                            var closest = pos;
                                        }
                                    }
                                    if (!(closest)) {
                                        self.log ("WARNING: Transport creep off path, with no positions to return to. I'm at {}, going from {} to {}. All positions: {}!".format (self.pos, origin, target, all_positions));
                                        if (!(len (all_positions))) {
                                            if (__mod__ (Game.time, 20) == 10) {
                                                self.hive.honey.clear_cached_path (origin, target);
                                            }
                                        }
                                        return ;
                                    }
                                    self.memory.next_ppos = closest;
                                }
                                var mtarget = self.memory.next_ppos;
                                var new_target = new RoomPosition (mtarget.x, mtarget.y, mtarget.roomName);
                                if (self.pos.isEqualTo (new_target)) {
                                    delete self.memory.next_ppos;
                                    if (!(self.memory.tried_new_next_ppos)) {
                                        self.memory.tried_new_next_ppos = true;
                                    }
                                    else {
                                        delete self.memory.tried_new_next_ppos;
                                        self.log ("WARNING: Path from {} to {} found to be cached incorrectly - it should contain {}, but it doesn't.".format (origin, target, new_target));
                                        self.log ('Path (tbd) retrieved from HoneyTrails with options ({}):\n{}'.format (opts, JSON.stringify (path, 0, 4)));
                                        self.hive.honey.clear_cached_path (origin, target, opts);
                                    }
                                }
                                else if (self.pos.isNearTo (new_target)) {
                                    self.basic_move_to (new_target);
                                    return ;
                                }
                                else {
                                    delete self.memory.tried_new_next_ppos;
                                }
                                self.move_to (new_target);
                                if (!(self.memory.off_path_for)) {
                                    self.memory.off_path_for = 1;
                                }
                                else {
                                    self.memory.off_path_for++;
                                }
                            }
                            else if (result != OK) {
                                self.log ('Unknown result from follow_energy_path: {}. Going from {} to {} (path {}, in {})'.format (result, origin, target, path, self.pos.roomName));
                            }
                            else {
                                delete self.memory.tried_new_next_ppos;
                                if (self.memory.off_path_for) {
                                    self.memory.on_path_for = 1;
                                    delete self.memory.off_path_for;
                                }
                                else if (self.memory.on_path_for) {
                                    self.memory.on_path_for++;
                                    if (self.memory.on_path_for >= 2) {
                                        delete self.memory.next_ppos;
                                        delete self.memory.on_path_for;
                                    }
                                }
                                var serialized_pos = self.pos.x | self.pos.y << 6;
                                if (self.memory.last_pos == serialized_pos) {
                                    if (('standstill_for' in self.memory)) {
                                        self.memory.standstill_for++;
                                    }
                                    else {
                                        self.memory.standstill_for = 1;
                                    }
                                    if (__mod__ (self.memory.standstill_for, 10) == 5 && (!(self.memory.filling) || !(_.find (self.room.find_in_range (FIND_MY_CREEPS, 1, self.pos), (function __lambda__ (c) {
                                        return c.memory.role != role_hauler && c.memory.role != role_miner;
                                    }))))) {
                                        delete self.memory.next_ppos;
                                        var found_mine = false;
                                        var __iterable0__ = self.hive.honey.find_path (origin, target, opts);
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var pos = __iterable0__ [__index0__];
                                            if (pos.x == self.pos.x && pos.y == self.pos.y) {
                                                var found_mine = true;
                                            }
                                            else if (found_mine) {
                                                if (movement.is_block_clear (self.room, pos.x, pos.y)) {
                                                    self.memory.next_ppos = {'x': pos.x, 'y': pos.y, 'roomName': self.pos.roomName};
                                                    self.move_to (new RoomPosition (pos.x, pos.y, self.pos.roomName));
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                else if (!(self.creep.fatigue)) {
                                    self.memory.last_pos = serialized_pos;
                                    delete self.memory.standstill_for;
                                }
                            }
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.base' +
                        'jstools.screeps_constants' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.RoleBase = RoleBase;
                        __all__.TransportPickup = TransportPickup;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.role_hauler = role_hauler;
                        __all__.role_miner = role_miner;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.building', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
                    var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants).rmem_key_there_might_be_energy_lying_around;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var target_big_big_repair = __init__ (__world__.constants).target_big_big_repair;
                    var target_big_repair = __init__ (__world__.constants).target_big_repair;
                    var target_construction = __init__ (__world__.constants).target_construction;
                    var target_destruction_site = __init__ (__world__.constants).target_destruction_site;
                    var target_repair = __init__ (__world__.constants).target_repair;
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var upgrading = __init__ (__world__.creeps.roles.upgrading);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var Builder = __class__ ('Builder', [upgrading.Upgrader], {
                        get any_building_targets () {return __get__ (this, function (self) {
                            return !(!(len (self.home.building.get_big_repair_targets ()) || len (self.home.building.get_construction_targets ())));
                        });},
                        get any_destruct_targets () {return __get__ (this, function (self) {
                            if (self.targets.get_existing_target (self, target_destruction_site)) {
                                return true;
                            }
                            if (self.targets.get_new_target (self, target_destruction_site)) {
                                self.targets.untarget (self, target_destruction_site);
                                return true;
                            }
                            return false;
                        });},
                        get should_pickup () {return __get__ (this, function (self, resource_type) {
                            if (typeof resource_type == 'undefined' || (resource_type != null && resource_type .hasOwnProperty ("__kwargtrans__"))) {;
                                var resource_type = null;
                            };
                            return RoleBase.should_pickup (self, resource_type) && self.any_building_targets ();
                        });},
                        get run () {return __get__ (this, function (self) {
                            if (self.creep.ticksToLive < recycle_time && self.home.spawn) {
                                self.memory.role = role_recycling;
                                self.memory.last_role = role_builder;
                                return false;
                            }
                            if (self.memory.filling && self.creep.carry.energy >= self.creep.carryCapacity) {
                                self.memory.filling = false;
                                self.targets.untarget_all (self);
                                if (self.home.room.controller.ticksToDowngrade < 500 && !(self.home.role_count (role_upgrader)) && self.memory.role == role_builder) {
                                    self.memory.role = role_upgrader;
                                    self.home.register_to_role (self);
                                    return false;
                                }
                            }
                            else if (!(self.memory.filling) && self.creep.carry.energy <= 0) {
                                self.targets.untarget_all (self);
                                self.memory.filling = true;
                            }
                            if (__mod__ (Game.time, 5) == 0 && !(self.creep.hasActiveBodyparts (WORK) & self.creep.hasActiveBodyparts (CARRY)) && !(self.home.defense.healing_capable ())) {
                                if (self.home.spawn) {
                                    return self.recycle_me ();
                                }
                                else {
                                    self.creep.suicide ();
                                    return ;
                                }
                            }
                            if (!('la' in self.memory) && !(self.any_building_targets ())) {
                                var destruct = self.targets.get_new_target (self, target_destruction_site);
                                if (destruct) {
                                    if (self.memory.filling) {
                                        return self.execute_destruction_target (destruct);
                                    }
                                    else {
                                        return self.empty_to_storage ();
                                    }
                                }
                                else if (self.home.get_target_upgrader_work_mass ()) {
                                    self.log ('No targets found, repurposing as upgrader.');
                                    self.memory.role = role_upgrader;
                                    return false;
                                }
                                else {
                                    self.log ('No targets found, recycling.');
                                    self.memory.role = role_recycling;
                                    self.memory.last_role = role_upgrader;
                                    return false;
                                }
                            }
                            if (self.memory.filling) {
                                if (self.creep.getActiveBodyparts (WORK) >= 4) {
                                    var destruct = self.targets.get_new_target (self, target_destruction_site);
                                }
                                else {
                                    var destruct = null;
                                }
                                if (destruct) {
                                    self.execute_destruction_target (destruct);
                                }
                                else if (self.home.building_paused ()) {
                                    if (self.creep.carry.energy > 0) {
                                        self.memory.filling = false;
                                        return true;
                                    }
                                    self.go_to_depot ();
                                }
                                else {
                                    if (self.home.mem [rmem_key_there_might_be_energy_lying_around]) {
                                        var closest = self.pos.findClosestByRange (FIND_DROPPED_ENERGY, {'filter': (function __lambda__ (x) {
                                            return x.amount >= self.creep.carryCapacity;
                                        })});
                                        if (closest) {
                                            if (!(self.pos.isNearTo (closest))) {
                                                self.move_to (closest);
                                                return ;
                                            }
                                        }
                                        else {
                                            delete self.home.mem [rmem_key_there_might_be_energy_lying_around];
                                        }
                                    }
                                    self.build_swamp_roads ();
                                    return self.harvest_energy ();
                                }
                            }
                            else {
                                var sc_last_action = self.memory.la;
                                if (sc_last_action == 'r') {
                                    var target = self.targets.get_existing_target (self, target_repair);
                                    if (target) {
                                        return self.execute_repair_target (target, self.home.min_sane_wall_hits, target_repair);
                                    }
                                    else {
                                        delete self.memory.la;
                                        if (Game.cpu.bucket >= 8000) {
                                            self.home.building.refresh_repair_targets (true);
                                        }
                                    }
                                }
                                else if (sc_last_action == 'm') {
                                    var target = self.targets.get_existing_target (self, target_repair);
                                    if (target) {
                                        return self.execute_repair_target (target, 5000, target_repair);
                                    }
                                    else {
                                        delete self.memory.la;
                                    }
                                }
                                else if (sc_last_action == 'b') {
                                    var target = self.targets.get_existing_target (self, target_big_repair);
                                    if (target) {
                                        return self.execute_repair_target (target, self.home.max_sane_wall_hits, target_big_repair);
                                    }
                                    else {
                                        delete self.memory.la;
                                    }
                                }
                                else if (sc_last_action == 'e') {
                                    var target = self.targets.get_existing_target (self, target_big_big_repair);
                                    if (target) {
                                        return self.execute_repair_target (target, Infinity, target_big_big_repair);
                                    }
                                    else {
                                        delete self.memory.la;
                                    }
                                }
                                else if (sc_last_action == 'c') {
                                    var target = self.targets.get_existing_target (self, target_construction);
                                    if (target) {
                                        return self.execute_construction_target (target);
                                    }
                                    else {
                                        delete self.memory.la;
                                    }
                                }
                                else if (sc_last_action == 'f') {
                                    var target = self.home.room.storage;
                                    if (target) {
                                        if (self.pos.isNearTo (target)) {
                                            var resource = _.findKey (self.creep.carry);
                                            self.creep.transfer (target, resource);
                                        }
                                        else {
                                            self.move_to (target);
                                        }
                                    }
                                    else {
                                        delete self.memory.la;
                                    }
                                }
                                else {
                                    var target = self.targets.get_existing_target (self, target_repair);
                                    if (target) {
                                        self.memory.la = 'r';
                                        return self.execute_repair_target (target, self.home.min_sane_wall_hits, target_repair);
                                    }
                                    var target = self.targets.get_existing_target (self, target_construction);
                                    if (target) {
                                        self.memory.la = 'c';
                                        return self.execute_construction_target (target);
                                    }
                                    var target = self.targets.get_existing_target (self, target_big_repair);
                                    if (target) {
                                        self.memory.la = 'b';
                                        return self.execute_repair_target (target, self.home.max_sane_wall_hits, target_big_repair);
                                    }
                                    var target = self.targets.get_existing_target (self, target_big_big_repair);
                                    if (target) {
                                        self.memory.la = 'e';
                                        return self.execute_repair_target (target, self.home.max_sane_wall_hits, target_big_big_repair);
                                    }
                                }
                                if (self.memory.building_walls_at) {
                                    var walls = self.room.look_at (LOOK_STRUCTURES, self.memory.building_walls_at & 63, self.memory.building_walls_at >> 6 & 63);
                                    var wall = _.find (walls, (function __lambda__ (s) {
                                        return s.structureType == STRUCTURE_WALL || s.structureType == STRUCTURE_RAMPART;
                                    }));
                                    delete self.memory.building_walls_at;
                                    if (wall) {
                                        if (Game.cpu.bucket >= 8000) {
                                            self.home.building.refresh_repair_targets ();
                                        }
                                        self.targets.manually_register (self, target_repair, wall.id);
                                        self.memory.la = 'm';
                                        return self.execute_repair_target (wall, 5000, target_repair);
                                    }
                                }
                                if (!(self.home.spawn) && (!(self.home.being_bootstrapped ()) || self.home.mem [rmem_key_building_priority_spawn])) {
                                    var target = null;
                                    if (self.home.rcl >= 4) {
                                        if (self.home.room.storage && self.home.mem [rmem_key_there_might_be_energy_lying_around]) {
                                            self.memory.la = 'f';
                                        }
                                        else if (self.home.mem [rmem_key_there_might_be_energy_lying_around]) {
                                            var target = _.find (self.home.find (FIND_MY_CONSTRUCTION_SITES), {'structureType': STRUCTURE_STORAGE});
                                            if (!(target)) {
                                                var storage = flags.find_ms_flags (self.home, flags.MAIN_BUILD, flags.SUB_STORAGE) [0];
                                                if (storage && len (self.home.look_at (LOOK_RESOURCES, storage))) {
                                                    var site = self.home.look_at (LOOK_CONSTRUCTION_SITES, storage) [0];
                                                    if (!(site)) {
                                                        storage.pos.createConstructionSite (STRUCTURE_STORAGE);
                                                        return ;
                                                    }
                                                    else {
                                                        var target = site;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (!(target)) {
                                        var target = _.find (self.home.find (FIND_MY_CONSTRUCTION_SITES), {'structureType': STRUCTURE_SPAWN});
                                    }
                                    if (target) {
                                        self.targets.manually_register (self, target_construction, target.id);
                                        self.memory.la = 'c';
                                        return self.execute_construction_target (target);
                                    }
                                }
                                var target = self.get_new_construction_target (true);
                                if (target) {
                                    self.memory.la = 'c';
                                    return self.execute_construction_target (target);
                                }
                                var target = self.get_new_repair_target (5000, target_repair);
                                if (target) {
                                    self.memory.la = 'm';
                                    return self.execute_repair_target (target, 5000, target_repair);
                                }
                                var target = self.get_new_construction_target ();
                                if (target) {
                                    self.memory.la = 'c';
                                    return self.execute_construction_target (target);
                                }
                                var target = self.get_new_repair_target (self.home.min_sane_wall_hits, target_repair);
                                if (target) {
                                    self.memory.la = 'r';
                                    return self.execute_repair_target (target, self.home.min_sane_wall_hits, target_repair);
                                }
                                var target = self.get_new_repair_target (self.home.max_sane_wall_hits, target_big_repair);
                                if (target) {
                                    self.memory.la = 'b';
                                    return self.execute_repair_target (target, self.home.max_sane_wall_hits, target_big_repair);
                                }
                                var target = self.get_new_repair_target (Infinity, target_big_big_repair);
                                if (target) {
                                    self.memory.la = 'e';
                                    return self.execute_repair_target (target, Infinity, target_big_big_repair);
                                }
                                if (self.home.get_target_upgrader_work_mass ()) {
                                    self.log ('No targets found, repurposing as upgrader.');
                                    self.memory.role = role_upgrader;
                                    return false;
                                }
                                else {
                                    self.log ('No targets found, recycling.');
                                    self.memory.role = role_recycling;
                                    self.memory.last_role = role_upgrader;
                                    return false;
                                }
                            }
                        });},
                        get get_new_repair_target () {return __get__ (this, function (self, max_hits, ttype) {
                            var target = self.targets.get_new_target (self, ttype, max_hits);
                            if (target && (target.hits >= max_hits && (target.structureType == STRUCTURE_WALL || target.structureType == STRUCTURE_RAMPART) || target.hits >= target.maxHits)) {
                                self.log ('WARNING: TargetMind.get_new_target({}, {}, {}) returned {} ({} hits)'.format (self, ttype, max_hits, target, target.hits));
                                self.targets.untarget (self, ttype);
                                return null;
                            }
                            return target;
                        });},
                        get get_new_construction_target () {return __get__ (this, function (self, walls_only) {
                            if (typeof walls_only == 'undefined' || (walls_only != null && walls_only .hasOwnProperty ("__kwargtrans__"))) {;
                                var walls_only = false;
                            };
                            return self.targets.get_new_target (self, target_construction, walls_only);
                        });},
                        get execute_repair_target () {return __get__ (this, function (self, target, max_hits, ttype) {
                            if (target.hits >= target.hitsMax || target.hits >= max_hits * 2 && (target.structureType == STRUCTURE_WALL || target.structureType == STRUCTURE_RAMPART)) {
                                if (Game.cpu.bucket >= 8000) {
                                    self.home.building.refresh_repair_targets ();
                                }
                                self.targets.untarget (self, ttype);
                                if (self.home.role_count (role_builder) > 10) {
                                    var nearby = self.room.look_for_in_area_around (LOOK_CREEPS, self.pos, 1);
                                    self.refill_nearby (nearby);
                                }
                                return false;
                            }
                            if (!(self.pos.inRangeTo (target, 2))) {
                                self.build_swamp_roads ();
                                self.move_to (target);
                                if (!(self.pos.inRangeTo (target, 3))) {
                                    return false;
                                }
                            }
                            var result = self.creep.repair (target);
                            if (result == OK) {
                                // pass;
                            }
                            else if (result == ERR_INVALID_TARGET) {
                                self.targets.untarget (self, ttype);
                                self.home.building.refresh_repair_targets ();
                                return false;
                            }
                            else {
                                self.log ('Unknown result from creep.repair({}): {}', target, result);
                            }
                            return false;
                        });},
                        get execute_construction_target () {return __get__ (this, function (self, target) {
                            if (!(target.structureType) && target.color) {
                                var site = _.find (target.pos.lookFor (LOOK_CONSTRUCTION_SITES));
                                if (site) {
                                    if (site.my) {
                                        self.targets.manually_register (self, target_construction, site.id);
                                        var target = site;
                                    }
                                    else {
                                        self.move_to (site);
                                    }
                                }
                                else {
                                    var creeps = target.pos.lookFor (LOOK_CREEPS);
                                    if (len (creeps)) {
                                        if (!(_.find (creeps, (function __lambda__ (c) {
                                            return !(c.my);
                                        })))) {
                                            var mine = _.find (creeps, 'my');
                                            if (!(mine.__moved)) {
                                                self.hive.wrap_creep (mine).go_to_depot ();
                                            }
                                        }
                                    }
                                    else {
                                        self.log ("WARNING: Couldn't find site for flag at {}! Refreshing building targets...".format (target.pos));
                                        self.home.building.refresh_building_targets ();
                                        self.targets.untarget (self, target_construction);
                                        if (!(self.pos.inRangeTo (target, 2))) {
                                            self.move_to (target);
                                        }
                                    }
                                    return false;
                                }
                            }
                            if (!(self.pos.inRangeTo (target, 2))) {
                                self.build_swamp_roads ();
                                self.move_to (target);
                                if (!(self.pos.inRangeTo (target, 3))) {
                                    if (self.home.role_count (role_builder) > 10) {
                                        var nearby = self.room.look_for_in_area_around (LOOK_CREEPS, self.pos, 1);
                                        self.refill_nearby (nearby);
                                    }
                                    return false;
                                }
                            }
                            var result = self.creep.build (target);
                            if (result == OK) {
                                if (target.structureType == STRUCTURE_WALL || target.structureType == STRUCTURE_RAMPART) {
                                    var pos = target.pos || target;
                                    self.memory.building_walls_at = pos.x | pos.y << 6;
                                }
                            }
                            else if (result == ERR_INVALID_TARGET) {
                                self.targets.untarget (self, target_construction);
                            }
                            else {
                                self.log ('Unknown result from creep.build({}): {}', target, result);
                                return false;
                            }
                            return false;
                        });},
                        get execute_destruction_target () {return __get__ (this, function (self, target) {
                            if (!(self.pos.isNearTo (target))) {
                                self.build_swamp_roads ();
                                self.move_to (target);
                                return false;
                            }
                            var result = self.creep.dismantle (target);
                            if (result == OK) {
                                self.move_around (target);
                                if (target.hits < self.creep.getActiveBodyparts (WORK) * DISMANTLE_POWER) {
                                    self.home.building.refresh_building_targets ();
                                }
                            }
                            else {
                                self.log ('Unknown result from creep.dismantle({}): {}', target, result);
                            }
                        });},
                        get refill_nearby () {return __get__ (this, function (self, nearby) {
                            var refill_target_obj = _ (nearby).filter ((function __lambda__ (c) {
                                return c.creep.name != self.name && (c.creep.memory.role == role_builder || c.creep.memory.running == role_builder) && !(c.creep.memory.filling);
                            })).max ((function __lambda__ (c) {
                                return c.creep.carryCapacity - c.creep.carry.energy;
                            }));
                            if (refill_target_obj !== -(Infinity)) {
                                var refill_target = refill_target_obj.creep;
                                var target_empty = refill_target.carryCapacity - refill_target.carry.energy;
                                var self_empty = self.creep.carryCapacity - self.creep.carry.energy;
                                if (target_empty > self_empty) {
                                    var amount = math.floor ((min (target_empty - self_empty, (self.creep.carry.energy * 3) / 4) * 2) / 3);
                                    if (amount > 0) {
                                        var result = self.creep.transfer (refill_target, RESOURCE_ENERGY, amount);
                                        if (result == OK) {
                                            refill_target.memory.filling = false;
                                        }
                                        else {
                                            self.log ('Unknown result from btb-transfer({}, {}, {}): {}', refill_target, RESOURCE_ENERGY, amount, result);
                                        }
                                    }
                                }
                            }
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.base' +
                        'creeps.roles.upgrading' +
                        'jstools.screeps_constants' +
                        'math' +
                        'position_management.flags' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.Builder = Builder;
                        __all__.RoleBase = RoleBase;
                        __all__.flags = flags;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.recycle_time = recycle_time;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
                        __all__.role_builder = role_builder;
                        __all__.role_recycling = role_recycling;
                        __all__.role_upgrader = role_upgrader;
                        __all__.target_big_big_repair = target_big_big_repair;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_construction = target_construction;
                        __all__.target_destruction_site = target_destruction_site;
                        __all__.target_repair = target_repair;
                        __all__.upgrading = upgrading;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.colonizing', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
                    var rmem_key_sponsor = __init__ (__world__.constants).rmem_key_sponsor;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_mineral_steal = __init__ (__world__.constants).role_mineral_steal;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_tower_fill_once = __init__ (__world__.constants).role_tower_fill_once;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var target_reserve_now = __init__ (__world__.constants).target_reserve_now;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var MilitaryBase = __init__ (__world__.creeps.behaviors.military).MilitaryBase;
                    var TransportPickup = __init__ (__world__.creeps.behaviors.transport).TransportPickup;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var movement = __init__ (__world__.utilities.movement);
                    var Colonist = __class__ ('Colonist', [MilitaryBase], {
                        get get_colony () {return __get__ (this, function (self) {
                            if (!(self.memory.colonizing)) {
                                var closest_distance = Infinity;
                                var closest_room_name = null;
                                var __iterable0__ = self.home.subsidiaries;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var room = __iterable0__ [__index0__];
                                    if (!(len (room.spawns)) && _.sum (room.role_counts) < 3) {
                                        var distance = movement.distance_squared_room_pos (self.pos, movement.center_pos (room.name));
                                        if (distance < closest_distance) {
                                            var closest_room_name = room.name;
                                        }
                                    }
                                }
                                if (!(closest_room_name)) {
                                    var __iterable0__ = self.home.subsidiaries;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var room = __iterable0__ [__index0__];
                                        if (!(len (room.spawns))) {
                                            var distance = movement.distance_squared_room_pos (self.pos, movement.center_pos (room.name));
                                            if (distance < closest_distance) {
                                                var closest_room_name = room.name;
                                            }
                                        }
                                    }
                                }
                                self.memory.colonizing = closest_room_name;
                            }
                            return self.memory.colonizing;
                        });},
                        get run () {return __get__ (this, function (self) {
                            var colony = self.get_colony ();
                            if (self.creep.room.name == colony) {
                                delete self.memory.colonizing;
                                var sponsor = self.home;
                                self.memory.home = colony;
                                delete self.memory.calculated_replacement_time;
                                var room = self.hive.get_room (colony);
                                var storage = room.room.storage;
                                if (storage && !(storage.my)) {
                                    if (_.sum (storage.store) > 0) {
                                        var enemy_storage_exhausted = false;
                                    }
                                    else {
                                        var enemy_storage_exhausted = true;
                                        storage.destroy ();
                                    }
                                }
                                else {
                                    var enemy_storage_exhausted = true;
                                }
                                if (room.role_count (role_upgrader) < 1 && !(room.upgrading_paused ())) {
                                    self.memory.role = role_upgrader;
                                }
                                else if (enemy_storage_exhausted && (room.rcl >= 5 || room.rcl >= sponsor.rcl) || room.mem.prio_spawn || room.mem.prio_walls) {
                                    self.memory.role = role_builder;
                                }
                                else {
                                    self.memory.role = role_upgrader;
                                }
                                if (_.some (room.defense.towers (), (function __lambda__ (t) {
                                    return t.energy < t.energyCapacity * 0.9;
                                }))) {
                                    self.memory.old_role = self.memory.role;
                                    self.memory.role = role_tower_fill_once;
                                }
                                var meta = room.mem.meta;
                                if (meta) {
                                    meta.clear_next = 0;
                                }
                            }
                            else {
                                self.follow_military_path (self.home.spawn, movement.center_pos (colony), {'range': 20});
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var colony = self.get_colony ();
                            var path_len = self.get_military_path_length (self.home.spawn, movement.center_pos (colony), {'range': 20});
                            if (self.creep.getActiveBodyparts (MOVE) < len (self.creep.body) / 2) {
                                path_len *= 2;
                            }
                            return (path_len + _.size (self.creep.body) * 3) + 10;
                        });}
                    });
                    var Claim = __class__ ('Claim', [MilitaryBase], {
                        get run () {return __get__ (this, function (self) {
                            var claim_flag = self.targets.get_new_target (self, target_single_flag, CLAIM_LATER);
                            if (!(claim_flag)) {
                                self.recycle_me ();
                                return ;
                            }
                            if (self.pos.roomName != claim_flag.pos.roomName) {
                                var target = claim_flag.pos;
                                if (!('checkpoint' in self.memory) || movement.chebyshev_distance_room_pos (self.memory.checkpoint, self.pos) > 50) {
                                    self.memory.checkpoint = self.pos;
                                }
                                var opts = {'range': 15};
                                if (self.creep.getActiveBodyparts (MOVE) >= (len (self.creep.body) * 5) / 7) {
                                    opts.ignore_swamp = true;
                                    opts.use_roads = false;
                                }
                                else if (self.creep.getActiveBodyparts (MOVE) >= len (self.creep.body) / 2) {
                                    opts.use_roads = false;
                                }
                                self.follow_military_path (_.create (RoomPosition.prototype, self.memory.checkpoint), target, opts);
                                return false;
                            }
                            var target = self.creep.room.controller;
                            if (!(target)) {
                                self.log ("ERROR: Claim can't find controller in room {}!".format (self.creep.room.name));
                                self.targets.untarget_all (self);
                                return true;
                            }
                            if (target.my) {
                                self.memory.home = self.pos.roomName;
                                self.targets.untarget_all (self);
                                return true;
                            }
                            if (!(self.pos.isNearTo (target))) {
                                self.move_to (target);
                                return false;
                            }
                            if (target.owner) {
                                self.creep.attackController (target);
                            }
                            else {
                                self.creep.claimController (target);
                            }
                            var room = self.hive.get_room (target.pos.roomName);
                            room.mem.sponsor = self.home.name;
                            if (_.get (flags.find_flags (room, CLAIM_LATER) [0], 'memory.prio_walls', false)) {
                                room.mem.prio_walls = true;
                            }
                            if (_.get (flags.find_flags (room, CLAIM_LATER) [0], 'memory.prio_spawn', false)) {
                                room.mem.prio_spawn = true;
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            if (self.creep.getActiveBodyparts (CLAIM) > 1) {
                                var target = self.targets.get_new_target (self, target_single_flag, CLAIM_LATER);
                                if (!(target)) {
                                    return -(1);
                                }
                                var path_len = self.get_military_path_length (self.home.spawn, target);
                                return path_len + _.size (self.creep.body) * 3;
                            }
                            else {
                                return 0;
                            }
                        });}
                    });
                    var ReserveNow = __class__ ('ReserveNow', [MilitaryBase], {
                        get run () {return __get__ (this, function (self) {
                            var reserve_flag = self.targets.get_new_target (self, target_reserve_now);
                            if (!(reserve_flag)) {
                                self.log ("ReserveNow couldn't find controller to reserve.");
                                self.recycle_me ();
                                return false;
                            }
                            if (self.pos.roomName != reserve_flag.pos.roomName) {
                                self.follow_military_path (self.home.spawn, reserve_flag);
                                return false;
                            }
                            var controller = self.creep.room.controller;
                            if (!(self.pos.isNearTo (controller))) {
                                self.move_to (controller);
                                return false;
                            }
                            if (controller.reservation && controller.reservation.username != self.creep.owner.username) {
                                self.log ('Remote reserve creep target owned by another player! {} has taken our reservation!', controller.reservation.username);
                            }
                            if (!(controller.reservation) || controller.reservation.ticksToEnd < 4998) {
                                if (len (flags.find_flags (controller.room, CLAIM_LATER))) {
                                    self.creep.claimController (controller);
                                    controller.room.memory [rmem_key_sponsor] = self.home.name;
                                }
                                self.creep.reserveController (controller);
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_reserve_now);
                            if (!(target)) {
                                return -(1);
                            }
                            var path_len = self.get_military_path_length (self.home.spawn, target);
                            if (self.creep.getActiveBodyparts (MOVE) < len (self.creep.body) / 2) {
                                path_len *= 2;
                            }
                            return (path_len + _.size (self.creep.body) * 3) + 10;
                        });}
                    });
                    var MineralSteal = __class__ ('MineralSteal', [TransportPickup], {
                        get get_colony () {return __get__ (this, function (self) {
                            if (!(self.memory.colonizing)) {
                                var closest_distance = Infinity;
                                var closest_room_name = null;
                                var __iterable0__ = self.hive.my_rooms;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var room = __iterable0__ [__index0__];
                                    if (room.room.storage && room.room.storage.storeCapacity <= 0 && _.sum (room.room.storage.store) > room.room.storage.store.energy) {
                                        var distance = movement.distance_squared_room_pos (self.pos, movement.center_pos (room.name));
                                        if (distance < closest_distance) {
                                            var closest_room_name = room.name;
                                        }
                                    }
                                }
                                if (!(closest_room_name)) {
                                    return null;
                                }
                                self.memory.colonizing = closest_room_name;
                            }
                            return self.memory.colonizing;
                        });},
                        get run () {return __get__ (this, function (self) {
                            var colony_name = self.get_colony ();
                            var colony = self.hive.get_room (colony_name);
                            if (!(colony)) {
                                self.memory.role = role_recycling;
                                self.memory.last_role = role_mineral_steal;
                                return ;
                            }
                            var pickup = colony.room.storage;
                            var fill = self.home.room.storage;
                            return self.transport (pickup, fill, false);
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            return _.size (self.creep.body) * 3 + 15;
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.behaviors.military' +
                        'creeps.behaviors.transport' +
                        'jstools.screeps_constants' +
                        'position_management.flags' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.Claim = Claim;
                        __all__.Colonist = Colonist;
                        __all__.MilitaryBase = MilitaryBase;
                        __all__.MineralSteal = MineralSteal;
                        __all__.ReserveNow = ReserveNow;
                        __all__.TransportPickup = TransportPickup;
                        __all__.flags = flags;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.rmem_key_sponsor = rmem_key_sponsor;
                        __all__.role_builder = role_builder;
                        __all__.role_mineral_steal = role_mineral_steal;
                        __all__.role_recycling = role_recycling;
                        __all__.role_tower_fill_once = role_tower_fill_once;
                        __all__.role_upgrader = role_upgrader;
                        __all__.target_reserve_now = target_reserve_now;
                        __all__.target_single_flag = target_single_flag;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.defensive', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
                    var role_defender = __init__ (__world__.constants).role_defender;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var target_rampart_defense = __init__ (__world__.constants).target_rampart_defense;
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var MilitaryBase = __init__ (__world__.creeps.behaviors.military).MilitaryBase;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var hostile_utils = __init__ (__world__.utilities.hostile_utils);
                    var movement = __init__ (__world__.utilities.movement);
                    var positions = __init__ (__world__.utilities.positions);
                    var RoleDefender = __class__ ('RoleDefender', [MilitaryBase], {
                        get should_pickup () {return __get__ (this, function (self, resource_type) {
                            if (typeof resource_type == 'undefined' || (resource_type != null && resource_type .hasOwnProperty ("__kwargtrans__"))) {;
                                var resource_type = null;
                            };
                            return false;
                        });},
                        get run () {return __get__ (this, function (self) {
                            var target_id = self.memory.attack_target;
                            if (!(target_id)) {
                                var best_id = null;
                                var closest_distance = Infinity;
                                var __iterable0__ = self.room.defense.dangerous_hostiles ();
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var hostile = __iterable0__ [__index0__];
                                    var distance = movement.chebyshev_distance_room_pos (self.pos, hostile.pos);
                                    if (distance < closest_distance) {
                                        var best_id = hostile.id;
                                        var closest_distance = distance;
                                    }
                                }
                                if (!(best_id)) {
                                    var __iterable0__ = self.home.defense.remote_hostiles ();
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var mem_hostile = __iterable0__ [__index0__];
                                        var distance = movement.chebyshev_distance_room_pos (self.pos, positions.deserialize_xy_to_pos (mem_hostile.pos, mem_hostile.room));
                                        if (mem_hostile.ranged && !(mem_hostile.attack)) {
                                            distance += 1000;
                                        }
                                        if (distance < closest_distance) {
                                            var best_id = mem_hostile.id;
                                            var closest_distance = distance;
                                        }
                                    }
                                }
                                if (best_id) {
                                    var target_id = best_id;
                                    self.memory.attack_target = best_id;
                                }
                                else {
                                    self.memory.role = role_recycling;
                                    self.memory.last_role = role_defender;
                                    return false;
                                }
                            }
                            var hostile_info = Memory.hostiles [target_id];
                            if (!(hostile_info) || Game.time >= hostile_info.dead) {
                                delete self.memory.attack_target;
                                return true;
                            }
                            var hostile_room = hostile_info.room;
                            var hostile_pos = positions.deserialize_xy_to_pos (hostile_info.pos, hostile_room);
                            if (self.pos.roomName != hostile_room) {
                                if (!('checkpoint' in self.memory) || movement.chebyshev_distance_room_pos (self.memory.checkpoint, self.pos) > 50) {
                                    self.memory.checkpoint = self.pos;
                                }
                                if (hostile_utils.enemy_room (self.memory.checkpoint.roomName)) {
                                    self.memory.checkpoint = self.home.spawn || movement.find_an_open_space (self.home.name);
                                }
                                if (('enemy_checkpoint' in self.memory)) {
                                    var enemy_checkpoint = self.memory.enemy_checkpoint;
                                    if (movement.chebyshev_distance_room_pos (enemy_checkpoint, hostile_pos) > 10) {
                                        var __left0__ = hostile_pos;
                                        var enemy_checkpoint = __left0__;
                                        self.memory.enemy_checkpoint = __left0__;
                                    }
                                }
                                else {
                                    var __left0__ = hostile_pos;
                                    var enemy_checkpoint = __left0__;
                                    self.memory.enemy_checkpoint = __left0__;
                                }
                                self.follow_military_path (_.create (RoomPosition.prototype, self.memory.checkpoint), _.create (RoomPosition.prototype, enemy_checkpoint), {'range': 1});
                                return false;
                            }
                            var target = Game.getObjectById (target_id);
                            if (target === null || self.room.hostile && target.owner.username != INVADER_USERNAME) {
                                delete self.memory.attack_target;
                                delete Memory.hostiles [target_id];
                                if ((hostile_room in Memory.rooms)) {
                                    var room_hostiles = Memory.rooms [hostile_room] [rmem_key_stored_hostiles];
                                    var index = _.findIndex (room_hostiles, (function __lambda__ (x) {
                                        return x.id == target_id;
                                    }));
                                    if (index != -(1)) {
                                        room_hostiles.splice (index, 1);
                                    }
                                }
                                return true;
                            }
                            self.creep.moveTo (target, _.create (self._move_options (target.pos.roomName), {'reusePath': 2}));
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            return 0;
                        });}
                    });
                    var WallDefender = __class__ ('WallDefender', [RoleBase], {
                        get run () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_rampart_defense);
                            if (!(target)) {
                                self.go_to_depot ();
                                self.log ('no new target! target: {}'.format (target));
                                return ;
                            }
                            var nearby_enemies = self.room.look_for_in_area_around (LOOK_CREEPS, self, 1);
                            if (len (nearby_enemies)) {
                                var biggest_threat = _.max (nearby_enemies, (function __lambda__ (x) {
                                    return self.home.defense.danger_level (x.creep);
                                }));
                                if (self.home.defense.danger_level (biggest_threat.creep) > 0) {
                                    var result = self.creep.attack (biggest_threat.creep);
                                    if (result != OK) {
                                        self.log ('Unknown result from creep.attack({}): {}'.format (biggest_threat.creep, result));
                                    }
                                }
                            }
                            else if (self.pos.isEqualTo (target) && len (self.home.defense.dangerous_hostiles ())) {
                                if (_.some (self.home.defense.get_current_defender_spots () [0], (function __lambda__ (loc) {
                                    return !(self.targets.targets [target_rampart_defense] [loc.name]);
                                }))) {
                                    self.log ('Found a new hot spot: untargeting.');
                                    self.targets.untarget (self, target_rampart_defense);
                                }
                            }
                            if (!(self.pos.isEqualTo (target))) {
                                try {
                                    self.move_to (target);
                                }
                                catch (__except0__) {
                                    self.log ('Error moving to {}'.format (target));
                                }
                            }
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.base' +
                        'creeps.behaviors.military' +
                        'jstools.screeps_constants' +
                        'utilities.hostile_utils' +
                        'utilities.movement' +
                        'utilities.positions' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.MilitaryBase = MilitaryBase;
                        __all__.RoleBase = RoleBase;
                        __all__.RoleDefender = RoleDefender;
                        __all__.WallDefender = WallDefender;
                        __all__.hostile_utils = hostile_utils;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.positions = positions;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.role_defender = role_defender;
                        __all__.role_recycling = role_recycling;
                        __all__.target_rampart_defense = target_rampart_defense;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.exploring', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var SCOUT = __init__ (__world__.constants).SCOUT;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var MilitaryBase = __init__ (__world__.creeps.behaviors.military).MilitaryBase;
                    var honey = __init__ (__world__.empire.honey);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var movement = __init__ (__world__.utilities.movement);
                    var positions = __init__ (__world__.utilities.positions);
                    var Scout = __class__ ('Scout', [MilitaryBase], {
                        get run () {return __get__ (this, function (self) {
                            var destination = self.targets.get_existing_target (self, target_single_flag);
                            if (!(destination)) {
                                if (!(self.memory.idle_for)) {
                                    self.log ('WARNING: Scout does not have destination set!');
                                    self.memory.idle_for = 1;
                                }
                                else {
                                    self.memory.idle_for++;
                                    if (self.memory.idle_for >= 10) {
                                        self.log ('Scout idle for 10 ticks, committing suicide.');
                                        self.creep.suicide ();
                                    }
                                }
                                return ;
                            }
                            var still_exploring = !('explored_at' in destination.memory) || positions.serialize_pos_xy (destination) + destination.pos.roomName != destination.memory.explored_at;
                            if (still_exploring) {
                                if (self.memory.rp) {
                                    honey.clear_serialized_cost_matrix (self.memory.rp);
                                    if (self.memory.rp == self.pos.roomName) {
                                        self.hive.honey.generate_serialized_cost_matrix (self.pos.roomName);
                                    }
                                    self.recalc_military_path (self.home.spawn, destination, {'ignore_swamp': true, 'use_roads': false});
                                    delete self.memory.rp;
                                }
                                if (self.memory.last_room != self.pos.roomName) {
                                    self.memory.last_room = self.pos.roomName;
                                    if (self.room.enemy && self.pos.roomName != destination.pos.roomName) {
                                        self.recalc_military_path (self.home.spawn, destination, {'ignore_swamp': true, 'use_roads': false});
                                    }
                                    var __left0__ = movement.parse_room_to_xy (self.pos.roomName);
                                    var rx = __left0__ [0];
                                    var ry = __left0__ [1];
                                    var rrx = __mod__ ((rx < 0 ? -(rx) - 1 : rx), 10);
                                    var rry = __mod__ ((ry < 0 ? -(ry) - 1 : ry), 10);
                                    var lair_count = 0;
                                    if ((rrx == 4 || rrx == 5 || rrx == 6) && (rry == 4 || rry == 5 || rry == 6) && !(rrx == 5 && rry == 5)) {
                                        if (!(len (flags.find_flags (self.room, SK_LAIR_SOURCE_NOTED)))) {
                                            var __iterable0__ = self.room.find (FIND_HOSTILE_STRUCTURES);
                                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                                var lair = __iterable0__ [__index0__];
                                                if (lair.structureType == STRUCTURE_KEEPER_LAIR) {
                                                    if (!(flags.look_for (self.room, lair, SK_LAIR_SOURCE_NOTED))) {
                                                        flags.create_flag (lair, SK_LAIR_SOURCE_NOTED);
                                                    }
                                                    lair_count++;
                                                }
                                            }
                                            if (lair_count) {
                                                var __iterable0__ = self.room.find (FIND_SOURCES).concat (self.room.find (FIND_MINERALS));
                                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                                    var source = __iterable0__ [__index0__];
                                                    if (!(flags.look_for (self.room, source, SK_LAIR_SOURCE_NOTED))) {
                                                        flags.create_flag (source, SK_LAIR_SOURCE_NOTED);
                                                    }
                                                }
                                            }
                                            else {
                                                self.log ('WARNING: Scout found no lairs in supposed source keeper room {}! Logic error?'.format (self.pos.roomName));
                                            }
                                        }
                                    }
                                    if (lair_count > 0) {
                                        self.memory.rp = self.pos.roomName;
                                    }
                                    self.hive.honey.generate_serialized_cost_matrix (self.pos.roomName);
                                    self.log ('Scouted room {}, {}.'.format (rx, ry));
                                }
                            }
                            if (self.pos.isEqualTo (destination) || self.pos.isNearTo (destination) && !(movement.is_block_empty (self.room, destination.pos.x, destination.pos.y))) {
                                if (still_exploring) {
                                    destination.memory.travel_time = CREEP_LIFE_TIME - self.creep.ticksToLive;
                                    self.log ('Arrived at {} ({}), traveling from {} in {} ticks.'.format (destination, destination.pos, self.home.spawn, destination.memory.travel_time));
                                    destination.memory.explored_at = positions.serialize_pos_xy (destination) + destination.pos.roomName;
                                }
                            }
                            else if (self.pos.isNearTo (destination)) {
                                self.basic_move_to (destination);
                            }
                            else {
                                self.follow_military_path (self.home.spawn, destination, {'ignore_swamp': true, 'use_roads': false});
                            }
                            if (self.pos.roomName == destination.pos.roomName && destination.memory.activate_attack_in) {
                                if (len (self.room.defense.dangerous_hostiles ()) && _.sum (self.room.defense.dangerous_hostiles (), (function __lambda__ (h) {
                                    return h.owner.username != INVADER_USERNAME && _.sum (h.body, (function __lambda__ (p) {
                                        return p.type == ATTACK || p.type == RANGED_ATTACK || p.type == HEAL;
                                    }));
                                })) >= 10) {
                                    var rooms_newly_activated = [];
                                    var __iterable0__ = destination.memory.activate_attack_in;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var name = __iterable0__ [__index0__];
                                        var activate_attack_in = self.hive.get_room (name);
                                        if (activate_attack_in) {
                                            activate_attack_in.defense.activate_live_defenses ();
                                            rooms_newly_activated.push (name);
                                        }
                                        else {
                                            self.log ("WARNING: Couldn't find room {} which flag {} is supposed to alert for attack.".format (name, destination.name));
                                        }
                                    }
                                    if (len (rooms_newly_activated)) {
                                        var with_mining_op_shutdowns = _.filter (rooms_newly_activated, (function __lambda__ (r) {
                                            return !(_.get (Memory, ['rooms', r, 'remotes_safe'], false));
                                        }));
                                        var hostiles = self.room.defense.dangerous_hostiles ();
                                        var message = '\nDANGER: -----\nHostile belonging to player {} detected in room {}. Game time: {}\n\n{}\n\nThis has triggered active-defense mode in rooms {}{}.\nDANGER: -----'.format (hostiles [0].owner.username, self.pos.roomName, Game.time, '\n'.join (function () {
                                            var __accu0__ = [];
                                            var __iterable0__ = hostiles;
                                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                                var h = __iterable0__ [__index0__];
                                                __accu0__.append ('Found hostile with hits {}/{}, owner {}, body [{}]'.format (h.hits, h.hitsMax, h.owner.username, function () {
                                                    var __accu1__ = [];
                                                    var __iterable1__ = h.body;
                                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                                        var p = __iterable1__ [__index1__];
                                                        __accu1__.append ((p.boost ? '{}:{}'.format (p.boost, p.type) : p.type));
                                                    }
                                                    return __accu1__;
                                                } ()));
                                            }
                                            return __accu0__;
                                        } ()), rooms_newly_activated, (len (with_mining_op_shutdowns) ? ', and shut down mining operations in rooms {}'.format (with_mining_op_shutdowns) : ''));
                                        console.log (message);
                                        Game.notify (message);
                                    }
                                }
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_single_flag, SCOUT);
                            if (!(target)) {
                                return -(1);
                            }
                            var path_len = self.get_military_path_length (self.home.spawn, target, {'ignore_swamp': true, 'use_roads': false});
                            return path_len + 28;
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.behaviors.military' +
                        'empire.honey' +
                        'jstools.screeps_constants' +
                        'position_management.flags' +
                        'utilities.movement' +
                        'utilities.positions' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.MilitaryBase = MilitaryBase;
                        __all__.SCOUT = SCOUT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.Scout = Scout;
                        __all__.flags = flags;
                        __all__.honey = honey;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.positions = positions;
                        __all__.target_single_flag = target_single_flag;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.generic', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
                    var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
                    var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
                    var PYFIND_BUILDABLE_ROADS = __init__ (__world__.constants).PYFIND_BUILDABLE_ROADS;
                    var PYFIND_HURT_CREEPS = __init__ (__world__.constants).PYFIND_HURT_CREEPS;
                    var PYFIND_REPAIRABLE_ROADS = __init__ (__world__.constants).PYFIND_REPAIRABLE_ROADS;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var REROUTE = __init__ (__world__.constants).REROUTE;
                    var REROUTE_DESTINATION = __init__ (__world__.constants).REROUTE_DESTINATION;
                    var RESERVE_NOW = __init__ (__world__.constants).RESERVE_NOW;
                    var SCOUT = __init__ (__world__.constants).SCOUT;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var SK_USERNAME = __init__ (__world__.constants).SK_USERNAME;
                    var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
                    var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
                    var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
                    var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
                    var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var creep_base_1500miner = __init__ (__world__.constants).creep_base_1500miner;
                    var creep_base_3000miner = __init__ (__world__.constants).creep_base_3000miner;
                    var creep_base_3h = __init__ (__world__.constants).creep_base_3h;
                    var creep_base_4000miner = __init__ (__world__.constants).creep_base_4000miner;
                    var creep_base_carry3000miner = __init__ (__world__.constants).creep_base_carry3000miner;
                    var creep_base_claim_attack = __init__ (__world__.constants).creep_base_claim_attack;
                    var creep_base_claiming = __init__ (__world__.constants).creep_base_claiming;
                    var creep_base_defender = __init__ (__world__.constants).creep_base_defender;
                    var creep_base_dismantler = __init__ (__world__.constants).creep_base_dismantler;
                    var creep_base_full_move_dismantler = __init__ (__world__.constants).creep_base_full_move_dismantler;
                    var creep_base_full_move_goader = __init__ (__world__.constants).creep_base_full_move_goader;
                    var creep_base_full_move_healer = __init__ (__world__.constants).creep_base_full_move_healer;
                    var creep_base_full_move_power_attack = __init__ (__world__.constants).creep_base_full_move_power_attack;
                    var creep_base_full_upgrader = __init__ (__world__.constants).creep_base_full_upgrader;
                    var creep_base_goader = __init__ (__world__.constants).creep_base_goader;
                    var creep_base_half_move_hauler = __init__ (__world__.constants).creep_base_half_move_hauler;
                    var creep_base_half_move_healer = __init__ (__world__.constants).creep_base_half_move_healer;
                    var creep_base_hauler = __init__ (__world__.constants).creep_base_hauler;
                    var creep_base_mammoth_miner = __init__ (__world__.constants).creep_base_mammoth_miner;
                    var creep_base_power_attack = __init__ (__world__.constants).creep_base_power_attack;
                    var creep_base_rampart_defense = __init__ (__world__.constants).creep_base_rampart_defense;
                    var creep_base_ranged_offense = __init__ (__world__.constants).creep_base_ranged_offense;
                    var creep_base_reserving = __init__ (__world__.constants).creep_base_reserving;
                    var creep_base_scout = __init__ (__world__.constants).creep_base_scout;
                    var creep_base_work_full_move_hauler = __init__ (__world__.constants).creep_base_work_full_move_hauler;
                    var creep_base_work_half_move_hauler = __init__ (__world__.constants).creep_base_work_half_move_hauler;
                    var creep_base_worker = __init__ (__world__.constants).creep_base_worker;
                    var default_roles = __init__ (__world__.constants).default_roles;
                    var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
                    var gmem_key_last_room_state_refresh = __init__ (__world__.constants).gmem_key_last_room_state_refresh;
                    var gmem_key_room_mining_paths = __init__ (__world__.constants).gmem_key_room_mining_paths;
                    var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
                    var max_repave_mine_roads_every = __init__ (__world__.constants).max_repave_mine_roads_every;
                    var min_repath_mine_roads_every = __init__ (__world__.constants).min_repath_mine_roads_every;
                    var min_repave_mine_roads_every = __init__ (__world__.constants).min_repave_mine_roads_every;
                    var old_role_names = __init__ (__world__.constants).old_role_names;
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var request_priority_economy = __init__ (__world__.constants).request_priority_economy;
                    var request_priority_helping_party = __init__ (__world__.constants).request_priority_helping_party;
                    var request_priority_imminent_threat_defense = __init__ (__world__.constants).request_priority_imminent_threat_defense;
                    var request_priority_low = __init__ (__world__.constants).request_priority_low;
                    var rmem_key_building_paused = __init__ (__world__.constants).rmem_key_building_paused;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
                    var rmem_key_cache = __init__ (__world__.constants).rmem_key_cache;
                    var rmem_key_carry_parts_by_role = __init__ (__world__.constants).rmem_key_carry_parts_by_role;
                    var rmem_key_creeps_by_role = __init__ (__world__.constants).rmem_key_creeps_by_role;
                    var rmem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants).rmem_key_creeps_by_role_and_replacement_time;
                    var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
                    var rmem_key_defense_mind_storage = __init__ (__world__.constants).rmem_key_defense_mind_storage;
                    var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants).rmem_key_empty_all_resources_into_room;
                    var rmem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants).rmem_key_flag_for_testing_spawning_in_simulation;
                    var rmem_key_focusing_home = __init__ (__world__.constants).rmem_key_focusing_home;
                    var rmem_key_linking_mind_storage = __init__ (__world__.constants).rmem_key_linking_mind_storage;
                    var rmem_key_metadata = __init__ (__world__.constants).rmem_key_metadata;
                    var rmem_key_mineral_mind_storage = __init__ (__world__.constants).rmem_key_mineral_mind_storage;
                    var rmem_key_now_supporting = __init__ (__world__.constants).rmem_key_now_supporting;
                    var rmem_key_pause_all_room_operations = __init__ (__world__.constants).rmem_key_pause_all_room_operations;
                    var rmem_key_planned_role_to_spawn = __init__ (__world__.constants).rmem_key_planned_role_to_spawn;
                    var rmem_key_prepping_defenses = __init__ (__world__.constants).rmem_key_prepping_defenses;
                    var rmem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants).rmem_key_remotes_explicitly_marked_under_attack;
                    var rmem_key_remotes_safe_when_under_siege = __init__ (__world__.constants).rmem_key_remotes_safe_when_under_siege;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
                    var rmem_key_spawn_requests = __init__ (__world__.constants).rmem_key_spawn_requests;
                    var rmem_key_sponsor = __init__ (__world__.constants).rmem_key_sponsor;
                    var rmem_key_storage_use_enabled = __init__ (__world__.constants).rmem_key_storage_use_enabled;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
                    var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants).rmem_key_there_might_be_energy_lying_around;
                    var rmem_key_total_open_source_spaces = __init__ (__world__.constants).rmem_key_total_open_source_spaces;
                    var rmem_key_upgrading_paused = __init__ (__world__.constants).rmem_key_upgrading_paused;
                    var rmem_key_work_parts_by_role = __init__ (__world__.constants).rmem_key_work_parts_by_role;
                    var role_bases = __init__ (__world__.constants).role_bases;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_cleanup = __init__ (__world__.constants).role_cleanup;
                    var role_colonist = __init__ (__world__.constants).role_colonist;
                    var role_defender = __init__ (__world__.constants).role_defender;
                    var role_energy_grab = __init__ (__world__.constants).role_energy_grab;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_link_manager = __init__ (__world__.constants).role_link_manager;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
                    var role_mineral_miner = __init__ (__world__.constants).role_mineral_miner;
                    var role_mineral_steal = __init__ (__world__.constants).role_mineral_steal;
                    var role_power_attack = __init__ (__world__.constants).role_power_attack;
                    var role_power_cleanup = __init__ (__world__.constants).role_power_cleanup;
                    var role_ranged_offense = __init__ (__world__.constants).role_ranged_offense;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_remote_mining_reserve = __init__ (__world__.constants).role_remote_mining_reserve;
                    var role_room_reserve = __init__ (__world__.constants).role_room_reserve;
                    var role_scout = __init__ (__world__.constants).role_scout;
                    var role_simple_claim = __init__ (__world__.constants).role_simple_claim;
                    var role_simple_dismantle = __init__ (__world__.constants).role_simple_dismantle;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_spawn_fill_backup = __init__ (__world__.constants).role_spawn_fill_backup;
                    var role_td_goad = __init__ (__world__.constants).role_td_goad;
                    var role_td_healer = __init__ (__world__.constants).role_td_healer;
                    var role_temporary_replacing = __init__ (__world__.constants).role_temporary_replacing;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var role_tower_fill_once = __init__ (__world__.constants).role_tower_fill_once;
                    var role_upgrade_fill = __init__ (__world__.constants).role_upgrade_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var role_wall_defender = __init__ (__world__.constants).role_wall_defender;
                    var target_big_big_repair = __init__ (__world__.constants).target_big_big_repair;
                    var target_big_repair = __init__ (__world__.constants).target_big_repair;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var target_construction = __init__ (__world__.constants).target_construction;
                    var target_destruction_site = __init__ (__world__.constants).target_destruction_site;
                    var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
                    var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
                    var target_home_flag = __init__ (__world__.constants).target_home_flag;
                    var target_rampart_defense = __init__ (__world__.constants).target_rampart_defense;
                    var target_refill = __init__ (__world__.constants).target_refill;
                    var target_repair = __init__ (__world__.constants).target_repair;
                    var target_reserve_now = __init__ (__world__.constants).target_reserve_now;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var target_single_flag2 = __init__ (__world__.constants).target_single_flag2;
                    var target_source = __init__ (__world__.constants).target_source;
                    var target_spawn_deposit = __init__ (__world__.constants).target_spawn_deposit;
                    var target_tower_fill = __init__ (__world__.constants).target_tower_fill;
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var MilitaryBase = __init__ (__world__.creeps.behaviors.military).MilitaryBase;
                    var Refill = __init__ (__world__.creeps.behaviors.refill).Refill;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var movement = __init__ (__world__.utilities.movement);
                    var immediately_replace_roles = [];
                    var let_live_roles = [role_spawn_fill_backup, role_spawn_fill, role_upgrader, role_tower_fill, role_builder, role_cleanup, role_colonist, role_hauler, role_miner, role_remote_mining_reserve, role_mineral_steal, role_mineral_hauler];
                    var ReplacingExpendedCreep = __class__ ('ReplacingExpendedCreep', [RoleBase], {
                        get run () {return __get__ (this, function (self) {
                            var old_name = self.memory.replacing;
                            if (!(old_name)) {
                                self.memory.role = role_recycling;
                                self.memory.last_role = (role_temporary_replacing + '->') + self.memory.replacing_role;
                                return ;
                            }
                            var role = self.memory.replacing_role;
                            var old_creep = Game.creeps [old_name];
                            if (!(old_creep) || !(Memory.creeps [old_name]) || Memory.creeps [old_name].role == role_recycling || let_live_roles.includes (role)) {
                                var home = self.memory.home;
                                self.memory = Memory.creeps [self.name];
                                Memory.creeps [self.name] = {'role': role, 'home': home};
                                self.home.register_to_role (self);
                                return ;
                            }
                            if (immediately_replace_roles.includes (role) && !(self.creep.spawning)) {
                                Memory.creeps [old_creep.name] = {'role': role_recycling, 'home': self.memory.home, 'last_role': 'replaced-{}'.format (self.memory.role)};
                                self.targets.untarget_all (old_creep);
                                var home = self.memory.home;
                                self.memory = Memory.creeps [self.name];
                                Memory.creeps [self.name] = {'role': role, 'home': home};
                                self.home.register_to_role (self);
                                self.home.check_all_creeps_next_tick ();
                                return ;
                            }
                            if (old_creep.ticksToLive > 1) {
                                if (self.creep.spawning) {
                                    return ;
                                }
                                if (!(self.pos.isNearTo (old_creep))) {
                                    self.move_to (old_creep);
                                    return ;
                                }
                            }
                            if (self.pos.isNearTo (old_creep.pos) && !(self.creep.spawning)) {
                                self.creep.move (movement.diff_as_direction (self.pos, old_creep.pos));
                                old_creep.move (movement.diff_as_direction (old_creep.pos, self.pos));
                                var mineral = _.findKey (old_creep.carry);
                                if (mineral) {
                                    old_creep.transfer (self.creep, mineral);
                                }
                            }
                            Memory.creeps [self.name] = {};
                            _.assign (Memory.creeps [self.name], Memory.creeps [old_name]);
                            self.targets.assume_identity (old_name, self.creep.name);
                            self.memory = Memory.creeps [self.name];
                            delete Memory.creeps [old_name];
                            Memory.creeps [old_name] = {'role': role_recycling, 'home': self.memory.home, 'last_role': 'replaced-{}'.format (self.memory.role)};
                            delete self.memory.calculated_replacement_time;
                            delete self.memory.replacement;
                            delete self.memory._path;
                            delete self.memory.last_checkpoint;
                            var role = self.memory.role;
                            if (role == role_remote_mining_reserve) {
                                var room = self.memory.claiming;
                                if (room) {
                                    Memory.reserving [room] = self.name;
                                }
                            }
                            self.home.check_all_creeps_next_tick ();
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            return 0;
                        });}
                    });
                    var Recycling = __class__ ('Recycling', [Refill, MilitaryBase], {
                        get should_pickup () {return __get__ (this, function (self, resource_type) {
                            if (typeof resource_type == 'undefined' || (resource_type != null && resource_type .hasOwnProperty ("__kwargtrans__"))) {;
                                var resource_type = null;
                            };
                            return self.creep.ticksToLive > 100;
                        });},
                        get run () {return __get__ (this, function (self) {
                            if (('filling' in self.memory)) {
                                delete self.memory.filling;
                            }
                            if (self.pos.roomName != self.room.name) {
                                var target = null;
                                if (self.carry_sum () > 0) {
                                    var target = self.home.room.storage;
                                }
                                if (target === null) {
                                    var target = self.home.spawn;
                                }
                                if (target === null || self.creep.ticksToLive < movement.chebyshev_distance_room_pos (self, target)) {
                                    self.creep.suicide ();
                                    return false;
                                }
                                if (!('checkpoint' in self.memory) || movement.chebyshev_distance_room_pos (self.memory.checkpoint, self.pos) > 50) {
                                    self.memory.checkpoint = self.pos;
                                }
                                self.follow_military_path (_.create (RoomPosition.prototype, self.memory.checkpoint), target, {'range': 1});
                                return false;
                            }
                            if (self.carry_sum () > 0) {
                                var storage = self.home.room.storage;
                                if (storage && _.sum (storage.store) < storage.storeCapacity) {
                                    if (self.pos.isNearTo (storage)) {
                                        var __iterable0__ = Object.keys (self.creep.carry);
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var rtype = __iterable0__ [__index0__];
                                            if (self.creep.carry [rtype] > 0) {
                                                var result = self.creep.transfer (storage, rtype);
                                                if (result == OK) {
                                                    break;
                                                }
                                                else {
                                                    self.log ('Unknown result from recycling-creep.transfer({}, {}): {}'.format (storage, rtype, result));
                                                }
                                            }
                                        }
                                    }
                                    else if (self.creep.ticksToLive <= self.pos.getRangeTo (storage.pos)) {
                                        self.creep.suicide ();
                                    }
                                    else {
                                        self.move_to (storage);
                                    }
                                    return false;
                                }
                                else if (self.creep.carry.energy > 0) {
                                    return self.refill_creeps ();
                                }
                            }
                            self.recycle_me ();
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            return 0;
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.base' +
                        'creeps.behaviors.military' +
                        'creeps.behaviors.refill' +
                        'jstools.screeps_constants' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.DEPOT = DEPOT;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.MilitaryBase = MilitaryBase;
                        __all__.PYFIND_BUILDABLE_ROADS = PYFIND_BUILDABLE_ROADS;
                        __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
                        __all__.PYFIND_REPAIRABLE_ROADS = PYFIND_REPAIRABLE_ROADS;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.REROUTE = REROUTE;
                        __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
                        __all__.RESERVE_NOW = RESERVE_NOW;
                        __all__.Recycling = Recycling;
                        __all__.Refill = Refill;
                        __all__.ReplacingExpendedCreep = ReplacingExpendedCreep;
                        __all__.RoleBase = RoleBase;
                        __all__.SCOUT = SCOUT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SK_USERNAME = SK_USERNAME;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__.creep_base_1500miner = creep_base_1500miner;
                        __all__.creep_base_3000miner = creep_base_3000miner;
                        __all__.creep_base_3h = creep_base_3h;
                        __all__.creep_base_4000miner = creep_base_4000miner;
                        __all__.creep_base_carry3000miner = creep_base_carry3000miner;
                        __all__.creep_base_claim_attack = creep_base_claim_attack;
                        __all__.creep_base_claiming = creep_base_claiming;
                        __all__.creep_base_defender = creep_base_defender;
                        __all__.creep_base_dismantler = creep_base_dismantler;
                        __all__.creep_base_full_move_dismantler = creep_base_full_move_dismantler;
                        __all__.creep_base_full_move_goader = creep_base_full_move_goader;
                        __all__.creep_base_full_move_healer = creep_base_full_move_healer;
                        __all__.creep_base_full_move_power_attack = creep_base_full_move_power_attack;
                        __all__.creep_base_full_upgrader = creep_base_full_upgrader;
                        __all__.creep_base_goader = creep_base_goader;
                        __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
                        __all__.creep_base_half_move_healer = creep_base_half_move_healer;
                        __all__.creep_base_hauler = creep_base_hauler;
                        __all__.creep_base_mammoth_miner = creep_base_mammoth_miner;
                        __all__.creep_base_power_attack = creep_base_power_attack;
                        __all__.creep_base_rampart_defense = creep_base_rampart_defense;
                        __all__.creep_base_ranged_offense = creep_base_ranged_offense;
                        __all__.creep_base_reserving = creep_base_reserving;
                        __all__.creep_base_scout = creep_base_scout;
                        __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
                        __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
                        __all__.creep_base_worker = creep_base_worker;
                        __all__.default_roles = default_roles;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.gmem_key_last_room_state_refresh = gmem_key_last_room_state_refresh;
                        __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
                        __all__.immediately_replace_roles = immediately_replace_roles;
                        __all__.let_live_roles = let_live_roles;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
                        __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
                        __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.old_role_names = old_role_names;
                        __all__.recycle_time = recycle_time;
                        __all__.request_priority_economy = request_priority_economy;
                        __all__.request_priority_helping_party = request_priority_helping_party;
                        __all__.request_priority_imminent_threat_defense = request_priority_imminent_threat_defense;
                        __all__.request_priority_low = request_priority_low;
                        __all__.rmem_key_building_paused = rmem_key_building_paused;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.rmem_key_cache = rmem_key_cache;
                        __all__.rmem_key_carry_parts_by_role = rmem_key_carry_parts_by_role;
                        __all__.rmem_key_creeps_by_role = rmem_key_creeps_by_role;
                        __all__.rmem_key_creeps_by_role_and_replacement_time = rmem_key_creeps_by_role_and_replacement_time;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                        __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
                        __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
                        __all__.rmem_key_flag_for_testing_spawning_in_simulation = rmem_key_flag_for_testing_spawning_in_simulation;
                        __all__.rmem_key_focusing_home = rmem_key_focusing_home;
                        __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
                        __all__.rmem_key_metadata = rmem_key_metadata;
                        __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
                        __all__.rmem_key_now_supporting = rmem_key_now_supporting;
                        __all__.rmem_key_pause_all_room_operations = rmem_key_pause_all_room_operations;
                        __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
                        __all__.rmem_key_prepping_defenses = rmem_key_prepping_defenses;
                        __all__.rmem_key_remotes_explicitly_marked_under_attack = rmem_key_remotes_explicitly_marked_under_attack;
                        __all__.rmem_key_remotes_safe_when_under_siege = rmem_key_remotes_safe_when_under_siege;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.rmem_key_spawn_requests = rmem_key_spawn_requests;
                        __all__.rmem_key_sponsor = rmem_key_sponsor;
                        __all__.rmem_key_storage_use_enabled = rmem_key_storage_use_enabled;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
                        __all__.rmem_key_total_open_source_spaces = rmem_key_total_open_source_spaces;
                        __all__.rmem_key_upgrading_paused = rmem_key_upgrading_paused;
                        __all__.rmem_key_work_parts_by_role = rmem_key_work_parts_by_role;
                        __all__.role_bases = role_bases;
                        __all__.role_builder = role_builder;
                        __all__.role_cleanup = role_cleanup;
                        __all__.role_colonist = role_colonist;
                        __all__.role_defender = role_defender;
                        __all__.role_energy_grab = role_energy_grab;
                        __all__.role_hauler = role_hauler;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_miner = role_miner;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.role_mineral_miner = role_mineral_miner;
                        __all__.role_mineral_steal = role_mineral_steal;
                        __all__.role_power_attack = role_power_attack;
                        __all__.role_power_cleanup = role_power_cleanup;
                        __all__.role_ranged_offense = role_ranged_offense;
                        __all__.role_recycling = role_recycling;
                        __all__.role_remote_mining_reserve = role_remote_mining_reserve;
                        __all__.role_room_reserve = role_room_reserve;
                        __all__.role_scout = role_scout;
                        __all__.role_simple_claim = role_simple_claim;
                        __all__.role_simple_dismantle = role_simple_dismantle;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_spawn_fill_backup = role_spawn_fill_backup;
                        __all__.role_td_goad = role_td_goad;
                        __all__.role_td_healer = role_td_healer;
                        __all__.role_temporary_replacing = role_temporary_replacing;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.role_tower_fill_once = role_tower_fill_once;
                        __all__.role_upgrade_fill = role_upgrade_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.role_wall_defender = role_wall_defender;
                        __all__.target_big_big_repair = target_big_big_repair;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_construction = target_construction;
                        __all__.target_destruction_site = target_destruction_site;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                        __all__.target_home_flag = target_home_flag;
                        __all__.target_rampart_defense = target_rampart_defense;
                        __all__.target_refill = target_refill;
                        __all__.target_repair = target_repair;
                        __all__.target_reserve_now = target_reserve_now;
                        __all__.target_single_flag = target_single_flag;
                        __all__.target_single_flag2 = target_single_flag2;
                        __all__.target_source = target_source;
                        __all__.target_spawn_deposit = target_spawn_deposit;
                        __all__.target_tower_fill = target_tower_fill;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.minerals', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
                    var role_mineral_miner = __init__ (__world__.constants).role_mineral_miner;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var movement = __init__ (__world__.utilities.movement);
                    var MineralMiner = __class__ ('MineralMiner', [RoleBase], {
                        get run () {return __get__ (this, function (self) {
                            var minerals = self.home.find (FIND_MINERALS);
                            if (len (minerals) != 1) {
                                self.log ("MineralMiner's home has an incomprehensible number of minerals: {}! To the depot it is.".format (len (minerals)));
                                self.go_to_depot ();
                                return false;
                            }
                            var mineral = minerals [0];
                            var extractor = _.find (self.home.look_at (LOOK_STRUCTURES, mineral.pos), {'structureType': STRUCTURE_EXTRACTOR});
                            if (!(extractor) || !(extractor.my)) {
                                self.log ("MineralMiner's mineral at {} does not have an extractor. D:".format (mineral.pos));
                                self.go_to_depot ();
                                return false;
                            }
                            if (!(self.pos.isNearTo (mineral))) {
                                self.move_to (mineral);
                                return false;
                            }
                            if (extractor.cooldown <= 0 && self.creep.carryCapacity - self.carry_sum () >= 1 * self.creep.getActiveBodyparts (WORK)) {
                                var result = self.creep.harvest (mineral);
                                if (result == ERR_NOT_ENOUGH_RESOURCES) {
                                    self.log ('Mineral depleted, going to recycle now!');
                                    self.memory.role = role_recycling;
                                    self.memory.last_role = role_mineral_miner;
                                }
                                else if (result != OK) {
                                    self.log ('Unknown result from creep.harvest({}): {}'.format (mineral, result));
                                }
                            }
                            else {
                                if (!('container' in self.memory)) {
                                    var container = _.find (self.room.look_for_in_area_around (LOOK_STRUCTURES, mineral.pos, 2), (function __lambda__ (c) {
                                        return c.structure.structureType == STRUCTURE_CONTAINER;
                                    }));
                                    if (container) {
                                        self.memory.container = container.structure.id;
                                    }
                                }
                                if (self.memory.container) {
                                    var transfer_target = Game.getObjectById (self.memory.container);
                                    if (!(self.pos.isNearTo (transfer_target))) {
                                        var pos = null;
                                        for (var x = mineral.pos.x - 1; x < mineral.pos.x + 2; x++) {
                                            for (var y = mineral.pos.y - 1; y < mineral.pos.y + 2; y++) {
                                                if (abs (x - transfer_target.pos.x) <= 1 && abs (y - transfer_target.pos.y) <= 1 && movement.is_block_empty (self.room, x, y)) {
                                                    var pos = new RoomPosition (x, y, mineral.pos.roomName);
                                                    break;
                                                }
                                            }
                                            if (pos) {
                                                break;
                                            }
                                        }
                                        if (pos) {
                                            self.basic_move_to (pos);
                                            return ;
                                        }
                                    }
                                }
                                else {
                                    var hauler = _.find (self.room.look_for_in_area_around (LOOK_CREEPS, self.pos, 1), (function __lambda__ (c) {
                                        return c.creep.memory.role == role_mineral_hauler;
                                    }));
                                    if (hauler) {
                                        var transfer_target = hauler [0];
                                    }
                                    else {
                                        return ;
                                    }
                                }
                                var resource = _.findKey (self.creep.carry);
                                if (resource) {
                                    self.creep.transfer (transfer_target, resource);
                                }
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var minerals = self.home.find (FIND_MINERALS);
                            if (!(len (minerals))) {
                                return -(1);
                            }
                            var mineral_pos = minerals [0].pos;
                            var spawn_pos = self.home.spawn.pos;
                            var time = (self.hive.honey.find_path_length (spawn_pos, mineral_pos) * 2 + _.size (self.creep.body) * 3) + 15;
                            return time;
                        });}
                    });
                    var _STORAGE_PICKUP = 'storage_pickup';
                    var _STORAGE_DROPOFF = 'storage_dropoff';
                    var _TERMINAL_PICKUP = 'terminal_pickup';
                    var _TERMINAL_DROPOFF = 'terminal_dropoff';
                    var _MINER_HARVEST = 'miner_harvesting';
                    var _DEAD = 'recycling';
                    var _DEPOT = 'depot';
                    var _FILL_LABS = 'fill_lab';
                    var MineralHauler = __class__ ('MineralHauler', [RoleBase], {
                        get should_pickup () {return __get__ (this, function (self, resource_type) {
                            if (typeof resource_type == 'undefined' || (resource_type != null && resource_type .hasOwnProperty ("__kwargtrans__"))) {;
                                var resource_type = null;
                            };
                            return true;
                        });},
                        get determine_next_state () {return __get__ (this, function (self) {
                            var mind = self.home.minerals;
                            var now_held = self.carry_sum ();
                            if (now_held < self.creep.carryCapacity) {
                                var mineral = self.home.find (FIND_MINERALS) [0];
                                if (mineral) {
                                    var containers = _.filter (self.home.find_in_range (FIND_STRUCTURES, 2, mineral.pos), {'structureType': STRUCTURE_CONTAINER});
                                    if (_.sum (containers, (function __lambda__ (s) {
                                        return _.sum (s.store);
                                    })) > 1000 || !(len (containers)) && _.find (self.home.find_in_range (FIND_MY_CREEPS, 1, mineral.pos), (function __lambda__ (c) {
                                        return c.memory.role == role_mineral_miner;
                                    }))) {
                                        var sending_resource_to_storage = (mind.terminal.store [mineral.resourceType] || 0) >= (mind.get_all_terminal_targets () [mineral.resourceType] || 0);
                                        var __break0__ = false;
                                        var __iterable0__ = Object.keys (self.creep.carry);
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var resource = __iterable0__ [__index0__];
                                            if (resource != mineral.resourceType) {
                                                if (sending_resource_to_storage) {
                                                    if ((mind.terminal.store [resource] || 0) < mind.get_all_terminal_targets () [resource]) {
                                                        __break0__ = true;
                                                        break;
                                                    }
                                                }
                                                else if (mind.terminal.store [resource] > (mind.get_all_terminal_targets () [resource] || 0)) {
                                                    __break0__ = true;
                                                    break;
                                                }
                                            }
                                        }
                                        if (!__break0__) {
                                            return _MINER_HARVEST;
                                        }
                                    }
                                }
                            }
                            var terminal_can_handle_more = _.sum (mind.terminal.store) <= mind.terminal.storeCapacity - self.creep.carryCapacity;
                            if (!(terminal_can_handle_more)) {
                                if (now_held) {
                                    return _STORAGE_DROPOFF;
                                }
                                else if (len (mind.removing_from_terminal ())) {
                                    return _TERMINAL_PICKUP;
                                }
                                else {
                                    return _DEPOT;
                                }
                            }
                            var __iterable0__ = Object.keys (self.creep.carry);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var resource = __iterable0__ [__index0__];
                                if (self.creep.carry [resource] > 0) {
                                    if ((mind.terminal.store [resource] || 0) < mind.get_all_terminal_targets () [resource]) {
                                        return _TERMINAL_DROPOFF;
                                    }
                                    else if (mind.get_lab_target_mineral () == resource && mind.amount_needed_in_lab1 ()) {
                                        return _FILL_LABS;
                                    }
                                    else if (mind.get_lab2_target_mineral () == resource && mind.amount_needed_in_lab2 ()) {
                                        return _FILL_LABS;
                                    }
                                    else if (resource == RESOURCE_ENERGY && mind.energy_needed_in_labs ()) {
                                        return _FILL_LABS;
                                    }
                                }
                            }
                            if (now_held) {
                                return _STORAGE_DROPOFF;
                            }
                            else if (self.creep.ticksToLive < 100) {
                                return _DEAD;
                            }
                            else if (len (mind.removing_from_terminal ()) && self.pos.isNearTo (mind.terminal)) {
                                return _TERMINAL_PICKUP;
                            }
                            else if (len (mind.adding_to_terminal ())) {
                                return _STORAGE_PICKUP;
                            }
                            else if (len (mind.removing_from_terminal ())) {
                                return _TERMINAL_PICKUP;
                            }
                            else if (self.home.role_count (role_mineral_miner)) {
                                return _MINER_HARVEST;
                            }
                            else if (mind.amount_needed_in_lab1 () || mind.amount_needed_in_lab2 () || mind.energy_needed_in_labs ()) {
                                return _STORAGE_PICKUP;
                            }
                            else {
                                return _DEPOT;
                            }
                        });},
                        get run () {return __get__ (this, function (self) {
                            var mind = self.home.minerals;
                            if (mind.has_no_terminal_or_storage ()) {
                                self.memory.role = role_recycling;
                                self.memory.last_role = role_mineral_hauler;
                                return ;
                            }
                            mind.note_mineral_hauler (self.name);
                            if (!('state' in self.memory)) {
                                self.memory.state = self.determine_next_state ();
                                if (self.memory.last_state == self.memory.state) {
                                    self.log ('State loop on state {}!'.format (self.memory.state));
                                    delete self.memory.last_state;
                                    return false;
                                }
                                else {
                                    self.memory.last_state = self.memory.state;
                                }
                            }
                            var state = self.memory.state;
                            if (state == _MINER_HARVEST) {
                                return self.run_miner_harvesting ();
                            }
                            else if (state == _STORAGE_PICKUP) {
                                return self.run_storage_pickup ();
                            }
                            else if (state == _STORAGE_DROPOFF) {
                                return self.run_storage_dropoff ();
                            }
                            else if (state == _TERMINAL_PICKUP) {
                                return self.run_terminal_pickup ();
                            }
                            else if (state == _TERMINAL_DROPOFF) {
                                return self.run_terminal_deposit ();
                            }
                            else if (state == _FILL_LABS) {
                                return self.run_lab_drop_off ();
                            }
                            else if (state == _DEAD) {
                                self.memory.role = role_recycling;
                                self.memory.last_role = role_mineral_hauler;
                            }
                            else if (state == _DEPOT) {
                                self.go_to_depot ();
                                if (__mod__ (Game.time, 10) == 0) {
                                    delete self.memory.state;
                                    delete self.memory.last_state;
                                }
                            }
                            else {
                                self.log ("ERROR: mineral-hauler in unknown state '{}'".format (self.memory.state));
                                delete self.memory.state;
                            }
                            return false;
                        });},
                        get run_miner_harvesting () {return __get__ (this, function (self) {
                            if (self.carry_sum () >= self.creep.carryCapacity) {
                                delete self.memory.state;
                                return true;
                            }
                            if (self.creep.ticksToLive < 50) {
                                delete self.memory.state;
                                return true;
                            }
                            var mind = self.home.minerals;
                            var minerals = self.home.find (FIND_MINERALS);
                            if (len (minerals) != 1) {
                                self.log ("MineralHauler's home has an incomprehensible number of minerals: {}! To the depot it is.".format (len (minerals)));
                                self.go_to_depot ();
                                return false;
                            }
                            var mineral = minerals [0];
                            var extractor = _.find (self.home.look_at (LOOK_STRUCTURES, mineral.pos), {'my': true, 'structureType': STRUCTURE_EXTRACTOR});
                            if (!(extractor)) {
                                self.log ("MineralHauler's mineral at {} does not have an extractor. D:".format (mineral.pos));
                                self.go_to_depot ();
                                return false;
                            }
                            if (!('containers' in self.memory)) {
                                self.memory.containers = _ (self.home.find_in_range (FIND_STRUCTURES, 2, mineral.pos)).filter ('structureType', STRUCTURE_CONTAINER).pluck ('id').value ();
                            }
                            if (len (self.memory.containers)) {
                                if (len (self.memory.containers) > 1) {
                                    var container = _ (self.memory.containers).map (Game.getObjectById).max ((function __lambda__ (c) {
                                        return _.sum (c.store);
                                    }));
                                }
                                else {
                                    var container = Game.getObjectById (self.memory.containers [0]);
                                }
                                var container_filled = _.sum (container.store);
                                if (self.pos.isNearTo (container)) {
                                    if (container_filled + self.carry_sum () >= self.creep.carryCapacity || !(mineral.mineralAmount)) {
                                        var resource = _.findKey (container.store);
                                        if (resource) {
                                            self.creep.withdraw (container, resource);
                                        }
                                        else if (self.carry_sum () || !(mineral.mineralAmount)) {
                                            delete self.memory.state;
                                        }
                                    }
                                }
                                else {
                                    self.move_to (container);
                                }
                                return false;
                            }
                            else {
                                var miner = _.find (self.home.find_in_range (FIND_MY_CREEPS, 1, mineral.pos), (function __lambda__ (c) {
                                    return c.memory.role == role_mineral_miner;
                                }));
                                if (!(miner)) {
                                    if (mind.get_target_mineral_miner_count ()) {
                                        self.go_to_depot ();
                                        return false;
                                    }
                                    else {
                                        delete self.memory.state;
                                        return true;
                                    }
                                }
                                if (!(self.pos.isNearTo (miner))) {
                                    self.move_to (miner);
                                }
                            }
                        });},
                        get run_storage_pickup () {return __get__ (this, function (self) {
                            var mind = self.home.minerals;
                            var now_carrying = self.carry_sum ();
                            if (now_carrying >= self.creep.carryCapacity) {
                                delete self.memory.state;
                                return true;
                            }
                            if (!(self.pos.isNearTo (mind.storage))) {
                                var access = mind.storage_terminal_access_pos ();
                                if (access) {
                                    self.move_to (movement.room_pos_of_closest_serialized (self, access));
                                }
                                else {
                                    self.move_to (mind.storage);
                                }
                                return false;
                            }
                            var __break0__ = false;
                            var __iterable0__ = mind.adding_to_terminal ().concat ([[RESOURCE_ENERGY, mind.energy_needed_in_labs ()], [mind.get_lab_target_mineral (), mind.amount_needed_in_lab1 ()], [mind.get_lab2_target_mineral (), mind.amount_needed_in_lab2 ()]]);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var resource = __left0__ [0];
                                var needed_in_terminal = __left0__ [1];
                                var to_withdraw = min (self.creep.carryCapacity - now_carrying, needed_in_terminal - (self.creep.carry [resource] || 0), mind.storage.store [resource] || 0);
                                if (to_withdraw > 0) {
                                    var result = self.creep.withdraw (mind.storage, resource, to_withdraw);
                                    if (result != OK) {
                                        self.log ('Unknown result from mineral-hauler.withdraw({}, {}, {}): {}'.format (mind.storage, resource, to_withdraw, result));
                                    }
                                    __break0__ = true;
                                    break;
                                }
                            }
                            if (!__break0__) {
                                delete self.memory.state;
                                return true;
                            }
                        });},
                        get run_storage_dropoff () {return __get__ (this, function (self) {
                            var mind = self.home.minerals;
                            var now_carrying = self.carry_sum ();
                            if (now_carrying <= 0) {
                                delete self.memory.state;
                                return true;
                            }
                            if (!(self.pos.isNearTo (mind.storage))) {
                                self.move_to (mind.storage);
                                return false;
                            }
                            var resource = _.findKey (self.creep.carry);
                            var result = self.creep.transfer (mind.storage, resource);
                            if (result != OK) {
                                self.log ('Unknown result from mineral-hauler.transfer({}, {}): {}'.format (mind.storage, resource, result));
                            }
                        });},
                        get run_terminal_pickup () {return __get__ (this, function (self) {
                            var mind = self.home.minerals;
                            var now_carrying = self.carry_sum ();
                            if (now_carrying >= self.creep.carryCapacity) {
                                delete self.memory.state;
                                return true;
                            }
                            if (!(self.pos.isNearTo (mind.terminal))) {
                                var access = mind.storage_terminal_access_pos ();
                                if (access) {
                                    self.move_to (movement.room_pos_of_closest_serialized (self, access));
                                }
                                else {
                                    self.move_to (mind.terminal);
                                }
                                return false;
                            }
                            var __break0__ = false;
                            var __iterable0__ = mind.removing_from_terminal ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var resource = __left0__ [0];
                                var remove_from_terminal = __left0__ [1];
                                if (resource == RESOURCE_ENERGY && len (mind.removing_from_terminal ()) > 1) {
                                    continue;
                                }
                                var to_withdraw = min (self.creep.carryCapacity - now_carrying, remove_from_terminal);
                                if (to_withdraw) {
                                    var result = self.creep.withdraw (mind.terminal, resource, to_withdraw);
                                    if (result != OK) {
                                        self.log ('Unknown result from mineral-hauler.withdraw({}, {}, {}): {}'.format (mind.terminal, resource, to_withdraw, result));
                                    }
                                    __break0__ = true;
                                    break;
                                }
                            }
                            if (!__break0__) {
                                delete self.memory.state;
                                return true;
                            }
                        });},
                        get run_terminal_deposit () {return __get__ (this, function (self) {
                            var mind = self.home.minerals;
                            var now_carrying = self.carry_sum ();
                            if (now_carrying <= 0) {
                                delete self.memory.state;
                                return true;
                            }
                            if (!(self.pos.isNearTo (mind.terminal))) {
                                self.move_to (mind.terminal);
                                return false;
                            }
                            var resource = _.findKey (self.creep.carry, (function __lambda__ (amount, resource) {
                                return amount > 0 && (mind.terminal.store [resource] || 0) < mind.get_all_terminal_targets () [resource];
                            }));
                            if (!(resource)) {
                                delete self.memory.state;
                                return false;
                            }
                            var amount = min (self.creep.carry [resource], mind.get_all_terminal_targets () [resource] - (mind.terminal.store [resource] || 0));
                            var result = self.creep.transfer (mind.terminal, resource, amount);
                            if (result == ERR_FULL) {
                                delete self.memory.state;
                                return false;
                            }
                            else if (result != OK) {
                                self.log ('Unknown result from mineral-hauler.transfer({}, {}, {}): {}'.format (mind.terminal, resource, amount, result));
                            }
                        });},
                        get run_lab_drop_off () {return __get__ (this, function (self) {
                            var mind = self.home.minerals;
                            var mineral1 = mind.get_lab_target_mineral ();
                            var mineral2 = mind.get_lab2_target_mineral ();
                            var mineral1_holding = self.creep.carry [mineral1];
                            var mineral2_holding = self.creep.carry [mineral2];
                            var energy_holding = self.creep.carry [RESOURCE_ENERGY];
                            if (mind.energy_needed_in_labs () && energy_holding) {
                                var target = _ (mind.labs ()).filter ((function __lambda__ (l) {
                                    return l.energy < l.energyCapacity && l.mineralAmount;
                                })).min ((function __lambda__ (l) {
                                    return movement.chebyshev_distance_room_pos (self.pos, l.pos);
                                }));
                                var resource = RESOURCE_ENERGY;
                            }
                            else if (mind.amount_needed_in_lab1 () && mineral1_holding) {
                                var labs = _ (mind.labs ()).filter ((function __lambda__ (l) {
                                    return l.mineralAmount < l.mineralCapacity;
                                }));
                                if (labs.find ((function __lambda__ (l) {
                                    return l.mineralType == mineral1;
                                }))) {
                                    var labs = labs.filter ((function __lambda__ (l) {
                                        return l.mineralType == mineral1;
                                    }));
                                }
                                else {
                                    var labs = labs.filter ((function __lambda__ (l) {
                                        return !(l.mineralAmount);
                                    }));
                                }
                                var target = labs.min ((function __lambda__ (l) {
                                    return movement.chebyshev_distance_room_pos (self.pos, l.pos);
                                }));
                                var resource = mineral1;
                            }
                            else if (mind.amount_needed_in_lab2 () && mineral2_holding) {
                                var labs = _ (mind.labs ()).filter ((function __lambda__ (l) {
                                    return l.mineralAmount < l.mineralCapacity;
                                }));
                                if (labs.find ((function __lambda__ (l) {
                                    return l.mineralType == mineral2;
                                }))) {
                                    var labs = labs.filter ((function __lambda__ (l) {
                                        return l.mineralType == mineral2;
                                    }));
                                }
                                else {
                                    var labs = labs.filter ((function __lambda__ (l) {
                                        return !(l.mineralAmount);
                                    }));
                                }
                                var target = labs.min ((function __lambda__ (l) {
                                    return movement.chebyshev_distance_room_pos (self.pos, l.pos);
                                }));
                                var resource = mineral2;
                            }
                            else {
                                delete self.memory.state;
                                return true;
                            }
                            if (!(self.pos.isNearTo (target))) {
                                self.move_to (target);
                                return false;
                            }
                            var result = self.creep.transfer (target, resource);
                            if (result != OK) {
                                self.log ('Unknown result from mineral-hauler.transfer({}, {}): {}'.format (target, resource, result));
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            return _.size (self.creep.body) * 3;
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.base' +
                        'jstools.screeps_constants' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.MineralHauler = MineralHauler;
                        __all__.MineralMiner = MineralMiner;
                        __all__.RoleBase = RoleBase;
                        __all__._DEAD = _DEAD;
                        __all__._DEPOT = _DEPOT;
                        __all__._FILL_LABS = _FILL_LABS;
                        __all__._MINER_HARVEST = _MINER_HARVEST;
                        __all__._STORAGE_DROPOFF = _STORAGE_DROPOFF;
                        __all__._STORAGE_PICKUP = _STORAGE_PICKUP;
                        __all__._TERMINAL_DROPOFF = _TERMINAL_DROPOFF;
                        __all__._TERMINAL_PICKUP = _TERMINAL_PICKUP;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.role_mineral_miner = role_mineral_miner;
                        __all__.role_recycling = role_recycling;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.mining', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
                    var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var Refill = __init__ (__world__.creeps.behaviors.refill).Refill;
                    var TransportPickup = __init__ (__world__.creeps.behaviors.transport).TransportPickup;
                    var SpawnFill = __init__ (__world__.creeps.roles.spawn_fill).SpawnFill;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var movement = __init__ (__world__.utilities.movement);
                    var positions = __init__ (__world__.utilities.positions);
                    var EnergyMiner = __class__ ('EnergyMiner', [TransportPickup], {
                        get run () {return __get__ (this, function (self) {
                            var source_flag = self.targets.get_existing_target (self, target_energy_miner_mine);
                            if (!(source_flag)) {
                                self.log ('WARNING: Getting new remote mine for remote miner!');
                                var source_flag = self.targets.get_new_target (self, target_energy_miner_mine);
                            }
                            if (!(source_flag)) {
                                self.log ("Remote miner can't find any sources! Flag: {}".format (source_flag));
                                self.memory.role = role_recycling;
                                self.memory.last_role = role_miner;
                                return false;
                            }
                            if (source_flag.memory.sponsor && source_flag.memory.sponsor != self.home.name) {
                                self.memory.home = source_flag.memory.sponsor;
                            }
                            if (self.creep.hits < self.creep.hitsMax) {
                                if (!(len (flags.find_flags (self, RANGED_DEFENSE))) || !(_.some (self.room.find (FIND_CREEPS), (function __lambda__ (creep) {
                                    return creep.hasActiveBodyparts (HEAL);
                                })))) {
                                    if (self.home.defense.healing_capable () && (self.pos.roomName != self.home.name || self.pos.x > 40 || self.pos.y > 40 || self.pos.x < 10 || self.pos.y < 10)) {
                                        self.follow_energy_path (source_flag, self.home.spawn);
                                        return ;
                                    }
                                    else if (!(self.creep.getActiveBodyparts (WORK))) {
                                        self.creep.suicide ();
                                        return ;
                                    }
                                }
                            }
                            if (self.memory.container_pos) {
                                var sitting_target = positions.deserialize_xy_to_pos (self.memory.container_pos, source_flag.pos.roomName);
                            }
                            else {
                                var sitting_target = source_flag.pos;
                            }
                            var distance_away = self.pos.getRangeTo (source_flag);
                            if (distance_away > 2) {
                                if (self.pos.roomName == source_flag.pos.roomName) {
                                    if (distance_away <= 3) {
                                        var total_mass = self.home.mining.get_ideal_miner_workmass_for (source_flag);
                                        if (self.creep.getActiveBodyparts (WORK) >= total_mass) {
                                            var other_miner = _.find (self.room.look_for_in_area_around (LOOK_CREEPS, source_flag.pos, 1), (function __lambda__ (c) {
                                                return c.creep.my && c.creep.memory.role == role_miner && c.creep.ticksToLive < self.creep.ticksToLive;
                                            }));
                                            if (other_miner) {
                                                other_miner.creep.suicide ();
                                                delete self.memory._move;
                                            }
                                        }
                                    }
                                    self.move_to (sitting_target);
                                }
                                else {
                                    self.follow_energy_path (self.home.spawn, sitting_target);
                                }
                                return false;
                            }
                            else if (distance_away > 1) {
                                var creep = _.find (self.room.look_at (LOOK_CREEPS, sitting_target), (function __lambda__ (c) {
                                    return c.my;
                                }));
                                if (creep && creep.memory.role == role_miner && creep.ticksToLive > 100) {
                                    self.memory.container_pos = null;
                                    var sitting_target = source_flag.pos;
                                }
                                self.move_to (sitting_target);
                                return false;
                            }
                            if (!('container_pos' in self.memory)) {
                                var container = _.find (self.room.find_in_range (FIND_STRUCTURES, 1, source_flag.pos), (function __lambda__ (s) {
                                    return s.structureType == STRUCTURE_CONTAINER;
                                }));
                                if (container) {
                                    self.memory.container_pos = container.pos.x | container.pos.y << 6;
                                }
                                else {
                                    var biggest_pile = _.max (self.room.find_in_range (FIND_DROPPED_RESOURCES, 1, source_flag.pos), (function __lambda__ (e) {
                                        return e.amount;
                                    }));
                                    if (biggest_pile != -(Infinity)) {
                                        self.memory.container_pos = biggest_pile.pos.x | biggest_pile.pos.y << 6;
                                    }
                                    else {
                                        self.memory.container_pos = null;
                                    }
                                }
                            }
                            if (__mod__ (Game.time, 10) == 0 && self.memory.container_pos !== null) {
                                var this_pos_to_check = self.pos.x | self.pos.y << 6;
                                if (this_pos_to_check != self.memory.container_pos) {
                                    var pos = new RoomPosition (self.memory.container_pos & 63, self.memory.container_pos >> 6 & 63, self.pos.roomName);
                                    if (_.find (self.room.look_at (LOOK_CREEPS, pos), (function __lambda__ (c) {
                                        return c.my && c.memory.role == role_miner && c.ticksToLive > 15;
                                    }))) {
                                        self.memory.container_pos = self.pos.x | self.pos.y << 6;
                                    }
                                    else {
                                        self.basic_move_to (pos);
                                    }
                                }
                            }
                            var sources_list = source_flag.pos.lookFor (LOOK_SOURCES);
                            if (!(len (sources_list))) {
                                self.log ('Remote mining source flag {} has no sources under it!', source_flag.name);
                                return false;
                            }
                            var source = sources_list [0];
                            var result = self.creep.harvest (source);
                            if (result != OK && result != ERR_NOT_ENOUGH_RESOURCES) {
                                self.log ('Unknown result from mining-creep.harvest({}): {}', source, result);
                            }
                            if (self.creep.carryCapacity) {
                                if (('link' in self.memory)) {
                                    if (self.memory.link === null) {
                                        return false;
                                    }
                                    else {
                                        var link = Game.getObjectById (self.memory.link);
                                        if (link === null || !(self.pos.isNearTo (link))) {
                                            delete self.memory.link;
                                            return false;
                                        }
                                    }
                                }
                                else {
                                    var all_possible_links = _.filter (self.room.find (FIND_MY_STRUCTURES), (function __lambda__ (s) {
                                        return (s.structureType == STRUCTURE_LINK || s.structureType == STRUCTURE_STORAGE) && abs (s.pos.x - source_flag.pos.x) <= 2 && abs (s.pos.y - source_flag.pos.y) <= 2;
                                    }));
                                    var best_priority = 0;
                                    var best_spot = null;
                                    var link = null;
                                    for (var x = source_flag.pos.x - 1; x < source_flag.pos.x + 2; x++) {
                                        for (var y = source_flag.pos.y - 1; y < source_flag.pos.y + 2; y++) {
                                            if (movement.is_block_empty (self.room, x, y)) {
                                                var link_here = _.find (all_possible_links, (function __lambda__ (s) {
                                                    return abs (s.pos.x - x) <= 1 && abs (s.pos.y - y) <= 1;
                                                }));
                                                if (link_here) {
                                                    if (!(flags.look_for (self.room, new RoomPosition (x, y, self.pos.roomName), UPGRADER_SPOT))) {
                                                        if (_.find (self.room.look_at (LOOK_STRUCTURES, x, y), (function __lambda__ (s) {
                                                            return s.structureType == STRUCTURE_RAMPART;
                                                        }))) {
                                                            var priority_here = 3;
                                                        }
                                                        else {
                                                            var priority_here = 2;
                                                        }
                                                    }
                                                    else {
                                                        var priority_here = 1;
                                                    }
                                                    if (priority_here > best_priority) {
                                                        var best_priority = priority_here;
                                                        var best_spot = x | y << 6;
                                                        var link = link_here;
                                                    }
                                                    if (best_priority >= 3) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (best_priority >= 3) {
                                            break;
                                        }
                                    }
                                    if (link) {
                                        self.memory.link = link.id;
                                        self.memory.container_pos = best_spot;
                                    }
                                    else {
                                        self.memory.link = null;
                                    }
                                    return false;
                                }
                                if (self.creep.carry.energy + self.creep.getActiveBodyparts (WORK) > self.creep.carryCapacity) {
                                    if (link.structureType == STRUCTURE_LINK) {
                                        self.home.links.register_target_deposit (link, self, self.creep.carry.energy, 1);
                                    }
                                    self.creep.transfer (link, RESOURCE_ENERGY);
                                }
                            }
                            return false;
                        });},
                        get should_pickup () {return __get__ (this, function (self, resource_type) {
                            if (typeof resource_type == 'undefined' || (resource_type != null && resource_type .hasOwnProperty ("__kwargtrans__"))) {;
                                var resource_type = null;
                            };
                            return ('container_pos' in self.memory) && RoleBase.should_pickup (resource_type);
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var source = self.targets.get_new_target (self, target_energy_miner_mine);
                            if (!(source)) {
                                return -(1);
                            }
                            var path_length = self.hive.honey.find_path_length (self.home.spawn, source);
                            var moves_every = (len (self.creep.body) - self.creep.getActiveBodyparts (MOVE)) / self.creep.getActiveBodyparts (MOVE);
                            if (self.home.all_paved ()) {
                                moves_every /= 2;
                            }
                            var moves_every = math.ceil (moves_every);
                            return (path_length / moves_every + _.size (self.creep.body) * 3) + 15;
                        });}
                    });
                    var EnergyHauler = __class__ ('EnergyHauler', [TransportPickup, SpawnFill, Refill], {
                        get run_local_refilling () {return __get__ (this, function (self, pickup, fill) {
                            if (!(self.memory.filling)) {
                                if (self.creep.getActiveBodyparts (WORK) && Game.cpu.bucket >= 4000) {
                                    var construction_sites = self.room.find_in_range (FIND_MY_CONSTRUCTION_SITES, 3, self.pos);
                                    if (len (construction_sites)) {
                                        self.creep.build (_.max (construction_sites, 'progress'));
                                    }
                                    else {
                                        var repair_sites = _.filter (self.room.find_in_range (FIND_STRUCTURES, 3, self.pos), (function __lambda__ (s) {
                                            return s.hits < s.hitsMax && s.hits < self.home.get_min_sane_wall_hits;
                                        }));
                                        if (len (repair_sites)) {
                                            self.creep.build (_.min (repair_sites, 'hits'));
                                        }
                                        else {
                                            self.repair_nearby_roads ();
                                        }
                                    }
                                }
                                if (self.memory.running == 'refill') {
                                    return self.refill_creeps ();
                                }
                                else if (self.memory.running == role_spawn_fill) {
                                    return SpawnFill.run (self);
                                }
                                else if (_.find (self.home.find (FIND_MY_STRUCTURES), (function __lambda__ (s) {
                                    return (s.structureType == STRUCTURE_EXTENSION || s.structureType == STRUCTURE_SPAWN) && s.energy < s.energyCapacity;
                                }))) {
                                    self.memory.running = role_spawn_fill;
                                    return SpawnFill.run (self);
                                }
                                else {
                                    self.memory.running = 'refill';
                                    return self.refill_creeps ();
                                }
                            }
                            else if (self.creep.ticksToLive < 200 && self.creep.ticksToLive < self.path_length (fill, pickup) * 2) {
                                if (self.creep.carry.energy > 0) {
                                    self.memory.filling = false;
                                    return self.refill_creeps ();
                                }
                                else {
                                    self.memory.last_role = self.memory.role;
                                    self.memory.role = role_recycling;
                                    return self.recycle_me ();
                                }
                            }
                        });},
                        get run () {return __get__ (this, function (self) {
                            var pickup = self.targets.get_existing_target (self, target_energy_hauler_mine);
                            if (!(pickup)) {
                                self.log ('WARNING: Getting new remote mine for remote hauler!');
                                self.targets.untarget (self, target_closest_energy_site);
                                var pickup = self.targets.get_new_target (self, target_energy_hauler_mine);
                            }
                            if (!(pickup)) {
                                self.memory.role = role_recycling;
                                self.memory.last_role = role_hauler;
                                return ;
                            }
                            if (_.size (self.creep.carry) > 1) {
                                var fill = self.home.room.storage || self.home.spawn;
                            }
                            else {
                                var fill = self.home.mining.closest_deposit_point_to_mine (pickup);
                            }
                            if (fill == undefined) {
                                self.log ('WARNING: Energy hauler in room without storage nor spawn. Repurposing as spawn fill.');
                                self.memory.role = role_spawn_fill;
                                return ;
                            }
                            if (fill.id == self.home.spawn.id) {
                                if (!(self.memory.filling) && self.pos.roomName == fill.pos.roomName) {
                                    return self.run_local_refilling (pickup, fill);
                                }
                                else if (('running' in self.memory)) {
                                    delete self.memory.running;
                                }
                            }
                            return self.transport (pickup, fill, self.home.paving ());
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var source = self.targets.get_new_target (self, target_energy_hauler_mine);
                            if (!(source)) {
                                return -(1);
                            }
                            var path_length = self.hive.honey.find_path_length (self.home.spawn, source);
                            return (path_length * 1.7 + _.size (self.creep.body) * 3) + 15;
                        });}
                    });
                    var RemoteReserve = __class__ ('RemoteReserve', [TransportPickup], {
                        get find_claim_room () {return __get__ (this, function (self) {
                            var claim_room = self.memory.claiming;
                            if (claim_room) {
                                if (__mod__ (Game.time, 100) == 49) {
                                    if (Memory.reserving [claim_room] != self.name) {
                                        if ((Memory.reserving [claim_room] in Game.creeps)) {
                                            var creep = Game.creeps [Memory.reserving [claim_room]];
                                            if (!(creep.spawning)) {
                                                if (self.creep.ticksToLive > creep.ticksToLive) {
                                                    Memory.reserving [claim_room] = self.name;
                                                }
                                                else if (self.pos.roomName != claim_room || creep.pos.getRangeTo (self.creep.room.controller.pos) < 4) {
                                                    self.creep.suicide ();
                                                }
                                            }
                                        }
                                        else {
                                            Memory.reserving [claim_room] = self.name;
                                        }
                                    }
                                }
                                return claim_room;
                            }
                            self.log ('WARNING: Calculating new reserve target for remote mining reserver!');
                            if (!(Memory.reserving)) {
                                Memory.reserving = {};
                            }
                            var lowest_time = Infinity;
                            var best = null;
                            var __iterable0__ = self.home.mining.active_mines;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var op_flag = __iterable0__ [__index0__];
                                var creep = Game.creeps [Memory.reserving [op_flag.pos.roomName]];
                                if (creep && creep.ticksToLive > 200) {
                                    continue;
                                }
                                if (Memory.no_controller && Memory.no_controller [op_flag.pos.roomName]) {
                                    continue;
                                }
                                var room = Game.rooms [op_flag.pos.roomName];
                                if (room && !(room.controller)) {
                                    if (Memory.no_controller) {
                                        Memory.no_controller [op_flag.pos.roomName] = true;
                                    }
                                    else {
                                        Memory.no_controller = {[op_flag.pos.roomName]: true};
                                    }
                                    continue;
                                }
                                var time = room && room.controller.reservation && room.controller.reservation.ticksToEnd || 0;
                                if (creep) {
                                    time += creep.ticksToLive * (creep.getActiveBodyparts (CLAIM) - 1);
                                }
                                if (time >= 4999) {
                                    continue;
                                }
                                if (time < lowest_time) {
                                    var lowest_time = time;
                                    var best = op_flag.pos.roomName;
                                }
                            }
                            if (best) {
                                Memory.reserving [best] = self.name;
                                self.memory.claiming = best;
                            }
                            return best;
                        });},
                        get run () {return __get__ (this, function (self) {
                            var claim_room = self.find_claim_room ();
                            if (!(claim_room)) {
                                self.creep.suicide ();
                                return ;
                            }
                            if (self.pos.roomName != claim_room) {
                                if (Game.rooms [claim_room]) {
                                    var target = Game.rooms [claim_room].controller.pos;
                                }
                                else {
                                    var target = movement.find_an_open_space (claim_room);
                                }
                                self.follow_energy_path (self.home.spawn, target);
                                return ;
                            }
                            var controller = self.room.room.controller;
                            if (!(controller)) {
                                delete self.memory.claiming;
                                return true;
                            }
                            if (controller.reservation && controller.reservation.ticksToEnd > 4999) {
                                if (self.pos.isNearTo (controller)) {
                                    self.creep.suicide ();
                                    return false;
                                }
                                else {
                                    delete self.memory.claiming;
                                    return true;
                                }
                            }
                            if (!(self.pos.isNearTo (controller))) {
                                self.move_to (controller);
                                return false;
                            }
                            if (controller.reservation && controller.reservation.username != self.creep.owner.username) {
                                self.log ('Remote reserve creep target owned by another player! {} has taken our reservation!', controller.reservation.username);
                            }
                            else {
                                self.creep.reserveController (controller);
                                if (controller.reservation) {
                                    controller.room.memory [rmem_key_room_reserved_up_until_tick] = Game.time + controller.reservation.ticksToEnd;
                                }
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var room = self.find_claim_room ();
                            if (!(room)) {
                                return -(1);
                            }
                            if (Game.rooms [room]) {
                                var target_pos = Game.rooms [room].controller.pos;
                            }
                            else {
                                return -(1);
                            }
                            var path_length = self.hive.honey.find_path_length (self.home.spawn, target_pos);
                            return (path_length + _.size (self.creep.body) * 3) + 15;
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.base' +
                        'creeps.behaviors.refill' +
                        'creeps.behaviors.transport' +
                        'creeps.roles.spawn_fill' +
                        'jstools.screeps_constants' +
                        'math' +
                        'position_management.flags' +
                        'utilities.movement' +
                        'utilities.positions' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.EnergyHauler = EnergyHauler;
                        __all__.EnergyMiner = EnergyMiner;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.Refill = Refill;
                        __all__.RemoteReserve = RemoteReserve;
                        __all__.RoleBase = RoleBase;
                        __all__.SpawnFill = SpawnFill;
                        __all__.TransportPickup = TransportPickup;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__.flags = flags;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.positions = positions;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.role_hauler = role_hauler;
                        __all__.role_miner = role_miner;
                        __all__.role_recycling = role_recycling;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.offensive', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var global_cache = __init__ (__world__.cache.global_cache);
                    var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
                    var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
                    var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
                    var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
                    var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
                    var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
                    var role_td_healer = __init__ (__world__.constants).role_td_healer;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var target_single_flag2 = __init__ (__world__.constants).target_single_flag2;
                    var autoactions = __init__ (__world__.creep_management.autoactions);
                    var MilitaryBase = __init__ (__world__.creeps.behaviors.military).MilitaryBase;
                    var TransportPickup = __init__ (__world__.creeps.behaviors.transport).TransportPickup;
                    var EnergyHauler = __init__ (__world__.creeps.roles.mining).EnergyHauler;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var hostile_utils = __init__ (__world__.utilities.hostile_utils);
                    var movement = __init__ (__world__.utilities.movement);
                    var TowerDrainHealer = __class__ ('TowerDrainHealer', [MilitaryBase], {
                        get run () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_single_flag, TD_H_H_STOP);
                            if (!(target)) {
                                if (len (flags.find_flags (self.home, RAID_OVER))) {
                                    self.recycle_me ();
                                }
                                else {
                                    self.log ('TowerDrainHealer has no target!');
                                    self.go_to_depot ();
                                }
                                return ;
                            }
                            if (!(self.pos.isEqualTo (target))) {
                                self.follow_military_path (self.home.spawn, target);
                            }
                            autoactions.instinct_do_heal (self);
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_single_flag, TD_H_H_STOP);
                            if (!(target)) {
                                return -(1);
                            }
                            var path_len = self.get_military_path_length (self.home.spawn, target);
                            if (self.creep.getActiveBodyparts (MOVE) < len (self.creep.body) / 2) {
                                path_len *= 2;
                            }
                            return (path_len + _.size (self.creep.body) * 3) + 10;
                        });}
                    });
                    var TowerDrainer = __class__ ('TowerDrainer', [MilitaryBase], {
                        get should_pickup () {return __get__ (this, function (self, resource_type) {
                            if (typeof resource_type == 'undefined' || (resource_type != null && resource_type .hasOwnProperty ("__kwargtrans__"))) {;
                                var resource_type = null;
                            };
                            return false;
                        });},
                        get run () {return __get__ (this, function (self) {
                            if (!('goading' in self.memory)) {
                                self.memory.goading = false;
                            }
                            if (self.memory.goading && self.creep.hits < self.creep.hitsMax / 2) {
                                self.memory.goading = false;
                                self.targets.untarget_all (self);
                            }
                            if (!(self.memory.goading) && self.creep.hits >= self.creep.hitsMax) {
                                self.memory.goading = true;
                                self.targets.untarget_all (self);
                            }
                            var goad_target = self.targets.get_new_target (self, target_single_flag, TD_D_GOAD);
                            if (!(goad_target)) {
                                if (len (flags.find_flags (self.home, RAID_OVER))) {
                                    self.recycle_me ();
                                }
                                else {
                                    self.log ('TowerDrainer has no target!');
                                    self.recycle_me ();
                                }
                                return ;
                            }
                            if (self.memory.goading) {
                                if (self.pos.isEqualTo (goad_target)) {
                                    // pass;
                                }
                                else if (movement.chebyshev_distance_room_pos (self.pos, goad_target) < 50) {
                                    self.creep.moveTo (goad_target, {'costCallback': (function __lambda__ (room_name, matrix) {
                                        return self.hive.honey.set_max_avoid (room_name, matrix, {'max_avoid': [goad_target.pos.roomName]});
                                    })});
                                }
                                else {
                                    self.follow_military_path (self.home.spawn, goad_target, {'avoid_rooms': [goad_target.pos.roomName]});
                                }
                            }
                            else {
                                var heal_target = self.targets.get_new_target (self, target_single_flag2, TD_H_D_STOP);
                                if (!(heal_target)) {
                                    if (len (flags.find_flags (self.home, RAID_OVER))) {
                                        self.recycle_me ();
                                    }
                                    else {
                                        self.go_to_depot ();
                                    }
                                    return ;
                                }
                                if (self.pos.isEqualTo (heal_target)) {
                                    // pass;
                                }
                                else if (movement.chebyshev_distance_room_pos (self.pos, heal_target) < 50) {
                                    self.creep.moveTo (heal_target, {'costCallback': (function __lambda__ (room_name, matrix) {
                                        return self.hive.honey.set_max_avoid (room_name, matrix, {'max_avoid': [goad_target.pos.roomName]});
                                    })});
                                }
                                else {
                                    self.follow_military_path (self.home.spawn, heal_target, {'avoid_rooms': [goad_target.pos.roomName]});
                                }
                            }
                            autoactions.instinct_do_attack (self);
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_single_flag, TD_D_GOAD);
                            if (!(target)) {
                                return -(1);
                            }
                            var path_len = self.get_military_path_length (self.home.spawn, target, {'avoid_rooms': [target.pos.roomName]});
                            if (self.creep.getActiveBodyparts (MOVE) < len (self.creep.body) / 2) {
                                path_len *= 2;
                            }
                            return (path_len + _.size (self.creep.body) * 3) + 10;
                        });}
                    });
                    var Dismantler = __class__ ('Dismantler', [MilitaryBase], {
                        get run () {return __get__ (this, function (self) {
                            if (self.memory.dismantling && self.creep.hits < self.creep.hitsMax / 2) {
                                self.memory.dismantling = false;
                                self.targets.untarget (self, target_single_flag2);
                            }
                            if (!(self.memory.dismantling) && self.creep.hits >= self.creep.hitsMax) {
                                self.memory.dismantling = true;
                                self.targets.untarget (self, target_single_flag2);
                            }
                            if (self.memory.dismantling) {
                                var target = self.targets.get_new_target (self, target_single_flag, ATTACK_DISMANTLE);
                                if (!(target)) {
                                    if (len (flags.find_flags (self.home, RAID_OVER))) {
                                        if (self.creep.ticksToLive < 300) {
                                            self.creep.suicide ();
                                        }
                                        else {
                                            self.recycle_me ();
                                        }
                                    }
                                    else {
                                        self.log ('Dismantler has no target!');
                                        self.go_to_depot ();
                                    }
                                    return ;
                                }
                                if (self.pos.isNearTo (target)) {
                                    var struct = self.room.look_at (LOOK_STRUCTURES, target.pos) [0];
                                    if (struct) {
                                        self.creep.dismantle (struct);
                                    }
                                    else {
                                        var site = self.room.look_at (LOOK_CONSTRUCTION_SITES, target.pos) [0];
                                        if (site) {
                                            self.basic_move_to (site);
                                        }
                                        else {
                                            global_cache.clear_values_matching (target.pos.roomName + '_cost_matrix_');
                                            if (!('dismantle_all' in target.memory) || target.memory.dismantle_all) {
                                                var new_target_site = self.room.find_closest_by_range (FIND_HOSTILE_CONSTRUCTION_SITES, target.pos);
                                                var new_structure = self.room.find_closest_by_range (FIND_STRUCTURES, target.pos, (function __lambda__ (s) {
                                                    return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER && s.structureType != STRUCTURE_CONTROLLER && s.structureType != STRUCTURE_EXTRACTOR && s.structureType != STRUCTURE_STORAGE && s.structureType != STRUCTURE_TERMINAL;
                                                }));
                                                if (new_structure && (!(new_target_site) || movement.distance_squared_room_pos (target, new_target_site) > movement.distance_squared_room_pos (target, new_structure))) {
                                                    var new_pos = new_structure.pos;
                                                }
                                                else if (new_target_site) {
                                                    var new_pos = new_target_site.pos;
                                                }
                                                else {
                                                    target.remove ();
                                                    return ;
                                                }
                                                target.setPosition (new_pos);
                                                self.move_to (new_pos);
                                            }
                                            else {
                                                target.remove ();
                                            }
                                        }
                                    }
                                }
                                else if (self.pos.roomName == target.pos.roomName) {
                                    self.move_to (target);
                                }
                                else {
                                    if (!('checkpoint' in self.memory) || movement.chebyshev_distance_room_pos (self.memory.checkpoint, self.pos) > 50) {
                                        self.memory.checkpoint = self.pos;
                                    }
                                    if (hostile_utils.enemy_room (self.memory.checkpoint.roomName)) {
                                        self.memory.checkpoint = self.home.spawn || movement.find_an_open_space (self.home.name);
                                    }
                                    self.follow_military_path (_.create (RoomPosition.prototype, self.memory.checkpoint), target);
                                }
                            }
                            else {
                                var target = self.targets.get_new_target (self, target_single_flag2, TD_H_D_STOP);
                                if (!(target)) {
                                    if (len (flags.find_flags (self.home, RAID_OVER))) {
                                        if (self.creep.ticksToLive < 300) {
                                            self.creep.suicide ();
                                        }
                                        else {
                                            self.recycle_me ();
                                        }
                                    }
                                    else {
                                        self.log ('Dismantler has no healer target!');
                                        self.go_to_depot ();
                                    }
                                    return ;
                                }
                                if (self.pos.roomName != target.pos.roomName) {
                                    self.creep.moveTo (target);
                                }
                                else {
                                    var room = self.hive.get_room (target.pos.roomName);
                                    if (room && _.find (room.find (FIND_MY_CREEPS), (function __lambda__ (c) {
                                        return c.memory.role == role_td_healer;
                                    }))) {
                                        if (!(self.pos.isEqualTo (target))) {
                                            self.creep.moveTo (target);
                                            self.follow_military_path (self.home.spawn, target);
                                        }
                                    }
                                    else {
                                        self.go_to_depot ();
                                    }
                                }
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_single_flag, ATTACK_DISMANTLE);
                            if (!(target)) {
                                return -(1);
                            }
                            var path_len = self.get_military_path_length (self.home.spawn, target);
                            if (self.creep.getActiveBodyparts (MOVE) < len (self.creep.body) / 2) {
                                path_len *= 2;
                            }
                            return (path_len + _.size (self.creep.body) * 3) + 10;
                        });}
                    });
                    var EnergyGrab = __class__ ('EnergyGrab', [TransportPickup, EnergyHauler], {
                        get run () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_single_flag, ENERGY_GRAB);
                            if (!(target)) {
                                if (!('recycling_from' in self.memory)) {
                                    var __left0__ = self.pos;
                                    var target = __left0__;
                                    self.memory.recycling_from = __left0__;
                                }
                                else {
                                    var target = _.create (RoomPosition.prototype, self.memory.recycling_from);
                                }
                                if (!(self.pos.isNearTo (self.home.spawn))) {
                                    return self.follow_energy_path (target, self.home.spawn);
                                }
                                else {
                                    return self.recycle_me ();
                                }
                            }
                            var fill = self.home.room.storage || self.home.spawn;
                            if (self.memory.filling && __mod__ (Game.time * 2 + self.creep.ticksToLive, 5) && self.pos.roomName == target.pos.roomName) {
                                var piles = self.room.look_at (LOOK_RESOURCES, target);
                                if (!(len (piles)) && !(_.find (self.room.look_at (LOOK_STRUCTURES, target), (function __lambda__ (s) {
                                    return s.structureType == STRUCTURE_CONTAINER && s.store.energy;
                                })))) {
                                    var new_target = self.room.find_closest_by_range (FIND_STRUCTURES, target.pos, (function __lambda__ (s) {
                                        return s.structureType == STRUCTURE_CONTAINER && s.store.energy;
                                    }));
                                    if (!(new_target)) {
                                        var new_target = self.room.find_closest_by_range (FIND_DROPPED_RESOURCES, target.pos);
                                    }
                                    if (new_target) {
                                        target.setPosition (new_target.pos);
                                        return false;
                                    }
                                    else {
                                        target.remove ();
                                        return false;
                                    }
                                }
                            }
                            else if (fill == self.home.spawn && !(self.memory.filling)) {
                                if (self.pos.roomName == fill.pos.roomName) {
                                    return self.run_local_refilling (target, fill);
                                }
                                else {
                                    delete self.memory.running;
                                }
                            }
                            return self.transport (target, fill);
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_single_flag, ENERGY_GRAB);
                            if (!(target)) {
                                return -(1);
                            }
                            var path_len = self.path_length (self.home.spawn, target);
                            if (self.creep.getActiveBodyparts (MOVE) < len (self.creep.body) / 2) {
                                path_len *= 2;
                            }
                            return (path_len + _.size (self.creep.body) * 3) + 10;
                        });}
                    });
                    var PowerAttack = __class__ ('PowerAttack', [MilitaryBase], {
                        get run () {return __get__ (this, function (self) {
                            if (!(self.memory.healing) && self.creep.hits < max (ATTACK_POWER * self.creep.getActiveBodyparts (ATTACK), self.creep.hitsMax / 2)) {
                                self.memory.healing = true;
                                self.targets.untarget_all (self);
                            }
                            if (self.memory.healing && self.creep.hits >= self.creep.hitsMax) {
                                self.memory.healing = false;
                                self.targets.untarget_all (self);
                            }
                            var target = self.targets.get_new_target (self, target_single_flag, ATTACK_POWER_BANK);
                            if (!(target)) {
                                if (len (flags.find_flags (self.home, RAID_OVER))) {
                                    if (self.creep.ticksToLive < 300) {
                                        self.creep.suicide ();
                                    }
                                    else {
                                        self.recycle_me ();
                                    }
                                }
                                else {
                                    self.log ('PowerAttack has no target!');
                                    self.go_to_depot ();
                                }
                                return ;
                            }
                            var heal_target = self.targets.get_new_target (self, target_single_flag2, TD_H_D_STOP, target.pos);
                            if (self.memory.healing) {
                                if (!(heal_target)) {
                                    if (len (flags.find_flags (self.home, RAID_OVER))) {
                                        if (self.creep.ticksToLive < 300) {
                                            self.creep.suicide ();
                                        }
                                        else {
                                            self.recycle_me ();
                                        }
                                    }
                                    else {
                                        self.log ('PowerAttack has no healer target!');
                                        self.go_to_depot ();
                                    }
                                    return ;
                                }
                                if (self.pos.roomName != heal_target.pos.roomName) {
                                    self.creep.moveTo (heal_target);
                                }
                                else {
                                    var room = self.hive.get_room (heal_target.pos.roomName);
                                    if (room && _.find (room.find (FIND_MY_CREEPS), (function __lambda__ (c) {
                                        return c.memory.role == role_td_healer;
                                    }))) {
                                        if (!(self.pos.isEqualTo (heal_target))) {
                                            self.creep.moveTo (heal_target);
                                            self.follow_military_path (self.home.spawn, heal_target);
                                        }
                                    }
                                    else {
                                        self.go_to_depot ();
                                    }
                                }
                            }
                            else {
                                if (self.pos.isNearTo (target)) {
                                    var struct = self.room.look_at (LOOK_STRUCTURES, target.pos) [0];
                                    if (struct) {
                                        self.creep.attack (struct);
                                    }
                                    else {
                                        var __iterable0__ = flags.find_flags (self.room, TD_H_H_STOP);
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var flag = __iterable0__ [__index0__];
                                            flag.remove ();
                                        }
                                        var __iterable0__ = flags.find_flags (self.room, TD_H_D_STOP);
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var flag = __iterable0__ [__index0__];
                                            flag.remove ();
                                        }
                                        target.remove ();
                                    }
                                }
                                if (!(self.pos.isEqualTo (heal_target))) {
                                    if (self.pos.roomName == target.pos.roomName) {
                                        var result = self.creep.moveTo (heal_target);
                                        if (result != OK && result != ERR_TIRED) {
                                            self.log ('Unknown result from creep.moveTo({}): {}'.format (target, result));
                                        }
                                    }
                                    else {
                                        self.follow_military_path (self.home.spawn, heal_target);
                                    }
                                }
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_single_flag, ATTACK_POWER_BANK);
                            if (!(target)) {
                                return -(1);
                            }
                            var path_len = self.get_military_path_length (self.home.spawn, target);
                            if (self.creep.getActiveBodyparts (MOVE) < len (self.creep.body) / 2) {
                                path_len *= 2;
                            }
                            return (path_len + _.size (self.creep.body) * 3) + 10;
                        });}
                    });
                    var PowerCleanup = __class__ ('PowerCleanup', [MilitaryBase], {
                        get should_pickup () {return __get__ (this, function (self, resource_type) {
                            if (typeof resource_type == 'undefined' || (resource_type != null && resource_type .hasOwnProperty ("__kwargtrans__"))) {;
                                var resource_type = null;
                            };
                            return resource_type === null || resource_type == RESOURCE_POWER;
                        });},
                        get run () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_single_flag, REAP_POWER_BANK);
                            if (!(target)) {
                                if (len (flags.find_flags (self.home, RAID_OVER)) || self.creep.ticksToLive < 100) {
                                    self.recycle_me ();
                                }
                                else {
                                    self.log ('PowerAttack has no target!');
                                    self.go_to_depot ();
                                }
                                return ;
                            }
                            if (self.memory.filling && self.carry_sum () >= self.creep.carryCapacity) {
                                self.memory.filling = false;
                            }
                            if (!(self.memory.filling) && self.carry_sum () <= 0) {
                                self.memory.filling = true;
                            }
                            var storage = self.home.room.storage;
                            if (self.memory.filling) {
                                if (self.pos.roomName != target.pos.roomName) {
                                    self.follow_military_path (self.home.spawn, target);
                                    return ;
                                }
                                var resources = self.room.find (FIND_DROPPED_RESOURCES);
                                if (len (resources)) {
                                    var closest = null;
                                    var closest_distance = Infinity;
                                    var __iterable0__ = resources;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var resource = __iterable0__ [__index0__];
                                        if (len (self.room.find_in_range (FIND_HOSTILE_CREEPS, 3, resource.pos)) == 0) {
                                            if (self.memory.last_energy_target) {
                                                var compressed_pos = resource.pos.x | resource.pos.y << 6;
                                                if (compressed_pos == self.memory.last_energy_target) {
                                                    var closest = resource;
                                                    break;
                                                }
                                            }
                                            if (resource.amount > 50 || len (self.room.find_in_range (FIND_SOURCES, 1, resource.pos)) == 0) {
                                                var distance = movement.distance_squared_room_pos (self, resource);
                                                if (distance < closest_distance) {
                                                    var closest = resource;
                                                    var closest_distance = distance;
                                                }
                                            }
                                        }
                                    }
                                    var pile = closest;
                                }
                                else {
                                    var pile = null;
                                }
                                if (!(pile)) {
                                    delete self.memory.last_energy_target;
                                    if (!(_.find (self.room.find (FIND_STRUCTURES), {'structureType': STRUCTURE_POWER_BANK}))) {
                                        if (self.carry_sum () >= 0) {
                                            self.memory.filling = false;
                                        }
                                        else {
                                            target.remove ();
                                        }
                                    }
                                    else if (self.pos.inRangeTo (target, 7)) {
                                        self.move_around (target);
                                    }
                                    else {
                                        self.move_to (target);
                                    }
                                    return ;
                                }
                                self.memory.last_energy_target = pile.pos.x | pile.pos.y << 6;
                                if (!(self.pos.isNearTo (pile))) {
                                    self.move_to (pile);
                                    return false;
                                }
                                var result = self.creep.pickup (pile);
                                if (result == OK) {
                                    // pass;
                                }
                                else if (result == ERR_FULL) {
                                    self.memory.filling = false;
                                    return true;
                                }
                                else {
                                    self.log ('Unknown result from cleanup-creep.pickup({}): {}', pile, result);
                                }
                            }
                            else {
                                if (!(storage)) {
                                    self.go_to_depot ();
                                    return ;
                                }
                                if (self.pos.roomName != storage.pos.roomName) {
                                    self.follow_military_path (target, storage);
                                    return false;
                                }
                                var target = storage;
                                if (!(self.pos.isNearTo (target))) {
                                    self.move_to (target);
                                    return false;
                                }
                                var resource_type = _.find (Object.keys (self.creep.carry), (function __lambda__ (r) {
                                    return self.creep.carry [r] > 0;
                                }));
                                var result = self.creep.transfer (target, resource_type);
                                if (result == OK) {
                                    // pass;
                                }
                                else if (result == ERR_NOT_ENOUGH_RESOURCES) {
                                    self.memory.filling = true;
                                    return true;
                                }
                                else if (result == ERR_FULL) {
                                    if (target == storage) {
                                        self.log ('Storage in room {} full!', storage.room.name);
                                    }
                                }
                                else {
                                    self.log ('Unknown result from cleanup-creep.transfer({}, {}): {}', target, resource_type, result);
                                }
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var target = self.targets.get_new_target (self, target_single_flag, REAP_POWER_BANK);
                            if (!(target)) {
                                return -(1);
                            }
                            var path_len = self.get_military_path_length (self.home.spawn, target);
                            if (self.creep.getActiveBodyparts (MOVE) < len (self.creep.body) / 2) {
                                path_len *= 2;
                            }
                            return (path_len + _.size (self.creep.body) * 3) + 10;
                        });}
                    });
                    __pragma__ ('<use>' +
                        'cache.global_cache' +
                        'constants' +
                        'creep_management.autoactions' +
                        'creeps.behaviors.military' +
                        'creeps.behaviors.transport' +
                        'creeps.roles.mining' +
                        'jstools.screeps_constants' +
                        'position_management.flags' +
                        'utilities.hostile_utils' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.Dismantler = Dismantler;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.EnergyGrab = EnergyGrab;
                        __all__.EnergyHauler = EnergyHauler;
                        __all__.MilitaryBase = MilitaryBase;
                        __all__.PowerAttack = PowerAttack;
                        __all__.PowerCleanup = PowerCleanup;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.TowerDrainHealer = TowerDrainHealer;
                        __all__.TowerDrainer = TowerDrainer;
                        __all__.TransportPickup = TransportPickup;
                        __all__.autoactions = autoactions;
                        __all__.flags = flags;
                        __all__.global_cache = global_cache;
                        __all__.hostile_utils = hostile_utils;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.role_td_healer = role_td_healer;
                        __all__.target_single_flag = target_single_flag;
                        __all__.target_single_flag2 = target_single_flag2;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.smart_offensive', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var context = __init__ (__world__.cache.context);
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var PYFIND_HURT_CREEPS = __init__ (__world__.constants).PYFIND_HURT_CREEPS;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var MilitaryBase = __init__ (__world__.creeps.behaviors.military).MilitaryBase;
                    var errorlog = __init__ (__world__.jstools.errorlog);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var defense = __init__ (__world__.rooms.defense);
                    var hostile_utils = __init__ (__world__.utilities.hostile_utils);
                    var movement = __init__ (__world__.utilities.movement);
                    var positions = __init__ (__world__.utilities.positions);
                    var kiting_cost_matrix = function (room_name) {
                        var cache = volatile_cache.mem ('kiting_cost_matrix');
                        if (cache.has (room_name)) {
                            return cache.get (room_name);
                        }
                        if (hostile_utils.enemy_room (room_name)) {
                            return false;
                        }
                        var cost_matrix = new PathFinder.CostMatrix ();
                        var set_in_range_xy = function (initial_x, initial_y, distance, value, increase_by_center) {
                            for (var x = initial_x - distance; x < (initial_x + distance) + 1; x++) {
                                for (var y = initial_y - distance; y < (initial_y + distance) + 1; y++) {
                                    if (increase_by_center) {
                                        var value_here = value + increase_by_center * (distance - movement.chebyshev_distance_xy (initial_x, initial_y, x, y));
                                    }
                                    else {
                                        var value_here = value;
                                    }
                                    var existing_cost = cost_matrix.get (x, y);
                                    if (existing_cost == 0) {
                                        var terrain_here = Game.map.getTerrainAt (x, y, room_name);
                                        if (terrain_here [0] == 'p') {
                                            var existing_cost = 1;
                                        }
                                        else if (terrain_here [0] == 's') {
                                            var existing_cost = 25;
                                        }
                                        else if (terrain_here [0] == 'w') {
                                            continue;
                                        }
                                    }
                                    cost_matrix.set (x, y, existing_cost + value_here);
                                }
                            }
                        };
                        var set_in_range = function (pos, distance, value, increase_by_center) {
                            var pos = pos.pos || pos;
                            set_in_range_xy (pos.x, pos.y, distance, value, increase_by_center);
                        };
                        var room = context.hive ().get_room (room_name);
                        if (room) {
                            var __iterable0__ = room.find (FIND_STRUCTURES);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var struct = __iterable0__ [__index0__];
                                if (struct.structureType == STRUCTURE_ROAD) {
                                    cost_matrix.set (struct.pos.x, struct.pos.y, 1);
                                }
                                else if (struct.structureType != STRUCTURE_CONTAINER && (struct.structureType != STRUCTURE_RAMPART || !(struct.my))) {
                                    cost_matrix.set (struct.pos.x, struct.pos.y, 255);
                                }
                            }
                            var __iterable0__ = room.find (FIND_MY_CREEPS);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var creep = __iterable0__ [__index0__];
                                cost_matrix.set (creep.pos.x, creep.pos.y, 255);
                            }
                        }
                        var __iterable0__ = defense.stored_hostiles_in (room_name);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var info = __iterable0__ [__index0__];
                            var __left0__ = positions.deserialize_xy (info.pos);
                            var x = __left0__ [0];
                            var y = __left0__ [1];
                            set_in_range_xy (x, y, 3, 5, 10);
                            cost_matrix.set (x, y, 255);
                        }
                        var __iterable0__ = flags.find_flags (room_name, SK_LAIR_SOURCE_NOTED);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var flag = __iterable0__ [__index0__];
                            set_in_range (flag.pos, 4, 255, 0);
                        }
                        var __iterable0__ = [0, 49];
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var x = __iterable0__ [__index0__];
                            for (var y = 0; y < 49; y++) {
                                var existing = cost_matrix.get (x, y);
                                if (existing == 0) {
                                    var terrain = Game.map.getTerrainAt (x, y, room_name);
                                    if (terrain [0] == 'p') {
                                        var existing = 1;
                                    }
                                    else if (terrain [0] == 's') {
                                        var existing = 25;
                                    }
                                    else {
                                        continue;
                                    }
                                }
                                cost_matrix.set (x, y, existing + 5);
                            }
                        }
                        var __iterable0__ = [0, 49];
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var y = __iterable0__ [__index0__];
                            for (var x = 0; x < 49; x++) {
                                var existing = cost_matrix.get (x, y);
                                if (existing == 0) {
                                    var terrain = Game.map.getTerrainAt (x, y, room_name);
                                    if (terrain [0] == 'p') {
                                        var existing = 1;
                                    }
                                    else if (terrain [0] == 's') {
                                        var existing = 25;
                                    }
                                    else {
                                        continue;
                                    }
                                }
                                cost_matrix.set (x, y, existing + 5);
                            }
                        }
                        cache.set (room_name, cost_matrix);
                        return cost_matrix;
                    };
                    var kiting_away_raw_path = function (origin, targets) {
                        return PathFinder.search (origin, targets, {'roomCallback': kiting_cost_matrix, 'flee': true, 'maxRooms': 8, 'swampCost': 25}).path;
                    };
                    var KitingOffense = __class__ ('KitingOffense', [MilitaryBase], {
                        get boost () {return __get__ (this, function (self) {
                            var labs = _ (self.home.minerals.labs ()).filter ((function __lambda__ (l) {
                                return l.mineralAmount && l.energy;
                            }));
                            if (!(len (labs))) {
                                self.memory.boosted = 2;
                                return false;
                            }
                            if (self.memory.boosted == 0) {
                                var lab = labs.find ((function __lambda__ (l) {
                                    return l.mineralType == 'XKHO2';
                                }));
                                if (lab) {
                                    if (self.pos.isNearTo (lab)) {
                                        var result = lab.boostCreep (self.creep);
                                        if (result == OK || result == ERR_NOT_ENOUGH_RESOURCES) {
                                            self.memory.boosted = 1;
                                        }
                                        else {
                                            self.log ('WARNING: Unknown result from {}.boostCreep({}): {}'.format (lab, self.creep, result));
                                        }
                                    }
                                    else {
                                        self.move_to (lab);
                                    }
                                    return true;
                                }
                                else {
                                    self.memory.boosted = 1;
                                }
                            }
                            if (self.memory.boosted == 1) {
                                var lab = labs.find ((function __lambda__ (l) {
                                    return l.mineralType == 'XLHO2';
                                }));
                                if (lab) {
                                    if (self.pos.isNearTo (lab)) {
                                        var result = lab.boostCreep (self.creep);
                                        if (result == OK || result == ERR_NOT_ENOUGH_RESOURCES) {
                                            self.memory.boosted = 2;
                                        }
                                        else {
                                            self.log ('WARNING: Unknown result from {}.boostCreep({}): {}'.format (lab, self.creep, result));
                                        }
                                    }
                                    else {
                                        self.move_to (lab);
                                    }
                                    return true;
                                }
                                else {
                                    self.memory.boosted = 2;
                                }
                            }
                            return false;
                        });},
                        get get_def_move_opts () {return __get__ (this, function (self, target_room) {
                            return _.create (self._move_options (target_room), {'reusePath': 2});
                        });},
                        get run () {return __get__ (this, function (self) {
                            if (self.creep.ticksToLive > 1450 && !(self.memory.boosted >= 2)) {
                                if (!('boosted' in self.memory)) {
                                    self.memory.boosted = 0;
                                }
                                if (self.boost ()) {
                                    return false;
                                }
                            }
                            var hostiles_nearby = defense.stored_hostiles_near (self.pos.roomName);
                            if (self.creep.hits < self.creep.hitsMax || len (hostiles_nearby) && _.find (hostiles_nearby, (function __lambda__ (h) {
                                return movement.chebyshev_distance_room_pos (self.pos, positions.deserialize_xy_to_pos (h.pos, h.room)) <= 3;
                            }))) {
                                self.creep.heal (self.creep);
                            }
                            var marker_flag = self.targets.get_new_target (self, target_single_flag, RANGED_DEFENSE);
                            if (marker_flag === null) {
                                if (self.pos.roomName == self.home.name && len (flags.find_flags (self.home, RAID_OVER))) {
                                    if (len (hostiles_nearby) || self.creep.hits < self.creep.hitsMax) {
                                        self.creep.heal (self.creep);
                                    }
                                    return false;
                                }
                                else {
                                    var marker_flag = {'pos': self.find_depot ()};
                                }
                            }
                            if (len (hostiles_nearby)) {
                                if (_.find (hostiles_nearby, (function __lambda__ (h) {
                                    return h.offensive && movement.chebyshev_distance_room_pos (self.pos, positions.deserialize_xy_to_pos (h.pos, h.room) <= 5);
                                }))) {
                                    var hostiles_nearby = _.filter (hostiles_nearby, 'offensive');
                                }
                                var nearby = _.filter (hostiles_nearby, (function __lambda__ (h) {
                                    return movement.chebyshev_distance_room_pos (self.pos, positions.deserialize_xy_to_pos (h.pos, h.room)) <= 5;
                                }));
                                var closest = _.min (hostiles_nearby, (function __lambda__ (h) {
                                    return movement.chebyshev_distance_room_pos (self.pos, positions.deserialize_xy_to_pos (h.pos, h.room)) - (h.offensive ? 5 : 0);
                                }));
                                var closest_pos = positions.deserialize_xy_to_pos (closest.pos, closest.room);
                                var harmless = !(_.some (nearby, (function __lambda__ (x) {
                                    return x.attack || x.ranged;
                                })));
                                var ranged = _.some (nearby, (function __lambda__ (x) {
                                    return x.ranged;
                                }));
                                var only_ranged = !(_.some (nearby, (function __lambda__ (h) {
                                    return movement.chebyshev_distance_room_pos (self.pos, positions.deserialize_xy_to_pos (h.pos, h.room)) <= 4 && h.attack;
                                })));
                                var mass_attack = _.some (nearby, (function __lambda__ (h) {
                                    return movement.chebyshev_distance_room_pos (self.pos, positions.deserialize_xy_to_pos (h.pos, h.room)) <= 1 && h.room == self.pos.roomName;
                                }));
                            }
                            else {
                                var enemies = self.room.find (FIND_HOSTILE_CREEPS);
                                if (len (enemies)) {
                                    if (self.pos.roomName != marker_flag.pos.roomName) {
                                        var enemies = _.filter (enemies, (function __lambda__ (h) {
                                            return hostile_utils.is_offensive (h) && hostile_utils.not_sk (h);
                                        }));
                                    }
                                    else {
                                        var any_offensive = _.find (enemies, hostile_utils.is_offensive);
                                        if (any_offensive) {
                                            var enemies = _.filter (enemies, (function __lambda__ (h) {
                                                return hostile_utils.is_offensive (h) && hostile_utils.not_sk (h);
                                            }));
                                        }
                                        else {
                                            var enemies = _.filter (enemies, hostile_utils.not_sk);
                                        }
                                    }
                                }
                                if (len (enemies)) {
                                    var closest = _.min (enemies, (function __lambda__ (h) {
                                        return movement.chebyshev_distance_room_pos (self.pos, h.pos);
                                    }));
                                    var closest_pos = closest.pos;
                                    var nearby = _.filter (enemies, (function __lambda__ (h) {
                                        return movement.chebyshev_distance_room_pos (h, self.pos) <= 5;
                                    }));
                                    var harmless = !(_.some (nearby, (function __lambda__ (h) {
                                        return h.hasActiveBodyparts (ATTACK) || h.hasActiveBodyparts (RANGED_ATTACK);
                                    }))) && self.creep.hits >= self.creep.hitsMax;
                                    var ranged = _.some (nearby, (function __lambda__ (h) {
                                        return h.hasActiveBodyparts (RANGED_ATTACK);
                                    }));
                                    var only_ranged = !(_.some (nearby, (function __lambda__ (h) {
                                        return movement.chebyshev_distance_room_pos (self.pos, h.pos) <= 4 && h.hasBodyparts (ATTACK);
                                    })));
                                    var mass_attack = _.some (nearby, (function __lambda__ (h) {
                                        return self.pos.isNearTo (h.pos) && self.pos.roomName == h.pos.roomName;
                                    }));
                                }
                                else {
                                    var closest = null;
                                    var closest_pos = null;
                                    var harmless = false;
                                    var ranged = false;
                                    var only_ranged = true;
                                    var mass_attack = false;
                                }
                            }
                            if (!(closest) || closest_pos.roomName != self.pos.roomName && movement.chebyshev_distance_room_pos (closest_pos, self.pos) > 10) {
                                delete self.memory.last_enemy_pos;
                                if (self.pos.roomName == marker_flag.pos.roomName && self.creep.hits >= self.creep.hitsMax) {
                                    var hurt = self.room.find (PYFIND_HURT_CREEPS);
                                    if (len (hurt)) {
                                        var damaged = _.min (hurt, (function __lambda__ (p) {
                                            return movement.chebyshev_distance_room_pos (p.pos, self.pos);
                                        }));
                                        if (self.pos.isNearTo (damaged)) {
                                            self.creep.heal (damaged);
                                        }
                                        else {
                                            self.creep.moveTo (damaged, self.get_def_move_opts (damaged.pos.roomName));
                                        }
                                        return false;
                                    }
                                }
                                if (!(self.pos.isEqualTo (marker_flag.pos))) {
                                    var distance = movement.chebyshev_distance_room_pos (self.pos, marker_flag.pos);
                                    if (distance > 50) {
                                        if (!('checkpoint' in self.memory) || movement.chebyshev_distance_room_pos (self.memory.checkpoint, self.pos) > 50) {
                                            self.memory.checkpoint = self.pos;
                                        }
                                        if (self.memory.next_ppos && movement.chebyshev_distance_room_pos (self.pos, self.memory.next_ppos) > 10 && !(hostile_utils.enemy_room (self.pos.roomName))) {
                                            self.memory.checkpoint = self.pos;
                                            delete self.memory.next_ppos;
                                            delete self.memory.off_path_for;
                                            delete self.memory.lost_path_at;
                                            delete self.memory._move;
                                        }
                                        if (hostile_utils.enemy_room (self.memory.checkpoint.roomName)) {
                                            self.memory.checkpoint = self.home.spawn || movement.find_an_open_space (self.home.name);
                                        }
                                        self.follow_military_path (_.create (RoomPosition.prototype, self.memory.checkpoint), marker_flag, {'range': 1});
                                        self.creep.say ('G1');
                                    }
                                    else if (distance >= 1) {
                                        self.creep.moveTo (marker_flag, self.get_def_move_opts (marker_flag.pos.roomName));
                                        self.creep.say ('G2');
                                    }
                                    else {
                                        self.basic_move_to (marker_flag);
                                        self.creep.say ('G3');
                                    }
                                }
                                return false;
                            }
                            var closest_creep = Game.getObjectById (closest.id);
                            var min_distance = movement.chebyshev_distance_room_pos (closest_pos, self.pos);
                            if (__mod__ (Game.time, 2)) {
                                self.creep.say ('{},{}: {}'.format (closest_pos.x, closest_pos.y, min_distance));
                            }
                            else {
                                self.creep.say ('  ', true);
                            }
                            var fatigue = closest_creep && (closest_creep.fatigue || !(closest_creep.hasActiveBodyparts (MOVE)));
                            if (self.memory.healing) {
                                var __left0__ = self.creep.hits < self.creep.hitsMax;
                                self.memory.healing = __left0__;
                                var self_damaged = __left0__;
                            }
                            else {
                                var total_ra = self.creep.getBodyparts (RANGED_ATTACK);
                                var alive_ra = self.creep.getActiveBodyparts (RANGED_ATTACK);
                                var __left0__ = total_ra < 10 && alive_ra < total_ra / 2 || alive_ra < total_ra / 3;
                                self.memory.healing = __left0__;
                                var self_damaged = __left0__;
                            }
                            if (closest_pos.roomName == self.pos.roomName && min_distance <= 3) {
                                if (mass_attack) {
                                    self.creep.rangedMassAttack ();
                                }
                                else {
                                    var closest_creep = Game.getObjectById (closest.id);
                                    self.creep.rangedAttack (closest_creep);
                                }
                            }
                            if (min_distance <= 6 && self.pos.roomName != closest_pos.roomName) {
                                self.memory.countdown = (self.memory.countdown || 10) - 1;
                                if (self.memory.countdown <= 0) {
                                    if (self.memory.countdown == 0) {
                                        self.memory.countdown--;
                                    }
                                    if (self.memory.countdown <= 5) {
                                        delete self.memory.countdown;
                                    }
                                    self.creep.moveTo (marker_flag, self.get_def_move_opts (marker_flag.pos.roomName));
                                }
                                return ;
                            }
                            if (ranged && self_damaged) {
                                var safe_distance = 5;
                            }
                            else if (ranged && only_ranged) {
                                var safe_distance = 0;
                            }
                            else {
                                var safe_distance = 3;
                            }
                            var should_run = !(_.find (self.pos.lookFor (LOOK_STRUCTURES), {'structureType': STRUCTURE_RAMPART, 'my': true})) && !(harmless) && (min_distance < safe_distance || min_distance == safe_distance && !(fatigue));
                            var should_approach = !(should_run) && (harmless || min_distance > safe_distance);
                            if (should_approach) {
                                self.creep.moveTo (_.create (RoomPosition.prototype, closest_pos), self.get_def_move_opts (closest_pos.roomName));
                            }
                            else if (should_run) {
                                var away_path = null;
                                var start = Game.cpu.getUsed ();
                                try {
                                    var away_path = kiting_away_raw_path (self.pos, function () {
                                        var __accu0__ = [];
                                        var __iterable0__ = hostiles_nearby;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var h = __iterable0__ [__index0__];
                                            __accu0__.append ({'pos': positions.deserialize_xy_to_pos (h.pos, h.room), 'range': 10});
                                        }
                                        return __accu0__;
                                    } ());
                                    if (len (away_path)) {
                                        self.creep.move (self.pos.getDirectionTo (away_path [0]));
                                    }
                                }
                                catch (__except0__) {
                                    self.creep.say ('ERROR');
                                    self.go_to_depot ();
                                    errorlog.report_error ('kiting-offense', __except0__, 'Error calculating or moving by kiting path at pos {} (cpu used here: {}):\npath: {}\n'.format (self.pos, Game.cpu.getUsed () - start, away_path));
                                }
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var marker_flag = self.targets.get_new_target (self, target_single_flag, RANGED_DEFENSE);
                            if (!(marker_flag)) {
                                return -(1);
                            }
                            var path_len = self.get_military_path_length (self.home.spawn, marker_flag);
                            return (path_len * 1.05 + _.size (self.creep.body) * 3) + 20;
                        });}
                    });
                    __pragma__ ('<use>' +
                        'cache.context' +
                        'cache.volatile_cache' +
                        'constants' +
                        'creeps.behaviors.military' +
                        'jstools.errorlog' +
                        'jstools.screeps_constants' +
                        'position_management.flags' +
                        'rooms.defense' +
                        'utilities.hostile_utils' +
                        'utilities.movement' +
                        'utilities.positions' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.KitingOffense = KitingOffense;
                        __all__.MilitaryBase = MilitaryBase;
                        __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.context = context;
                        __all__.defense = defense;
                        __all__.errorlog = errorlog;
                        __all__.flags = flags;
                        __all__.hostile_utils = hostile_utils;
                        __all__.kiting_away_raw_path = kiting_away_raw_path;
                        __all__.kiting_cost_matrix = kiting_cost_matrix;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.positions = positions;
                        __all__.target_single_flag = target_single_flag;
                        __all__.volatile_cache = volatile_cache;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.spawn_fill', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_spawn_fill_backup = __init__ (__world__.constants).role_spawn_fill_backup;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var target_spawn_deposit = __init__ (__world__.constants).target_spawn_deposit;
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var Refill = __init__ (__world__.creeps.behaviors.refill).Refill;
                    var building = __init__ (__world__.creeps.roles.building);
                    var upgrading = __init__ (__world__.creeps.roles.upgrading);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var movement = __init__ (__world__.utilities.movement);
                    var SpawnFill = __class__ ('SpawnFill', [building.Builder, Refill], {
                        get run () {return __get__ (this, function (self) {
                            if (self.creep.ticksToLive < recycle_time && !(self.home.under_siege ())) {
                                self.memory.role = role_recycling;
                                self.memory.last_role = role_spawn_fill;
                                return false;
                            }
                            if (self.memory.filling && self.creep.carry.energy >= self.creep.carryCapacity) {
                                self.memory.filling = false;
                                if (self.memory.role == role_spawn_fill || self.memory.role == role_tower_fill) {
                                    self.targets.untarget_all (self);
                                }
                                else {
                                    return true;
                                }
                            }
                            else if (!(self.memory.filling) && (self.creep.carry.energy <= 0 || self.creep.carry.energy <= 20 && self.home.room.storage && movement.chebyshev_distance_room_pos (self.pos, self.home.room.storage) < 5)) {
                                self.memory.filling = true;
                                delete self.memory.running;
                                if (self.memory.role == role_spawn_fill || self.memory.role == role_tower_fill) {
                                    self.targets.untarget_all (self);
                                }
                                else {
                                    return true;
                                }
                            }
                            if (self.memory.filling) {
                                return self.harvest_energy ();
                            }
                            else {
                                if (('running' in self.memory)) {
                                    if (self.memory.running == role_upgrader) {
                                        return upgrading.Upgrader.run (self);
                                    }
                                    else if (self.memory.running == role_builder) {
                                        return building.Builder.run (self);
                                    }
                                    else if (self.memory.running == 'refill') {
                                        return self.refill_creeps ();
                                    }
                                    else if (self.memory.running != role_spawn_fill) {
                                        self.log ('WARNING: Unknown running value: {}', self.memory.running);
                                        delete self.memory.running;
                                    }
                                }
                                else if (self.home.room.energyCapacityAvailable < 550 && self.home.room.energyAvailable < 300 && self.home.next_role === null) {
                                    if (self.creep.hasActiveBodyparts (WORK)) {
                                        self.memory.running = role_builder;
                                        return building.Builder.run (self);
                                    }
                                    else {
                                        self.memory.running = 'refill';
                                        return self.refill_creeps ();
                                    }
                                }
                                var target = self.targets.get_new_target (self, target_spawn_deposit);
                                if (target) {
                                    if (target.color) {
                                        var rwc_cache = volatile_cache.mem ('sfrwc');
                                        if (!(rwc_cache.has (self.pos.roomName))) {
                                            rwc_cache.set (self.pos.roomName, !(!(_.find (self.room.find (FIND_MY_STRUCTURES), (function __lambda__ (s) {
                                                return (s.structureType == STRUCTURE_EXTENSION || s.structureType == STRUCTURE_SPAWN) && s.energy < s.energyCapacity;
                                            })))));
                                        }
                                        if (rwc_cache.get (self.pos.roomName)) {
                                            self.targets.untarget (self, target_spawn_deposit);
                                            return true;
                                        }
                                        if (self.creep.carry.energy < self.creep.carryCapacity) {
                                            self.memory.filling = true;
                                            return true;
                                        }
                                        if (!(self.home.full_storage_use)) {
                                            self.memory.running = 'refill';
                                            return self.refill_creeps ();
                                        }
                                        if (!(self.pos.isEqualTo (target))) {
                                            self.move_to (target);
                                        }
                                        return false;
                                    }
                                    else if (target.energy >= target.energyCapacity) {
                                        self.targets.untarget (self, target_spawn_deposit);
                                        return true;
                                    }
                                    else {
                                        if (!(self.pos.isNearTo (target))) {
                                            self.move_to (target);
                                            return false;
                                        }
                                        delete self.memory.nbm;
                                        var result = self.creep.transfer (target, RESOURCE_ENERGY);
                                        if (result == OK) {
                                            if (self.creep.carry.energy > target.energyCapacity - target.energy) {
                                                volatile_cache.mem ('extensions_filled').set (target.id, true);
                                                if ((self.creep.carry.energy + target.energy) - target.energyCapacity > 0) {
                                                    self.targets.untarget (self, target_spawn_deposit);
                                                    var new_target = self.targets.get_new_target (self, target_spawn_deposit);
                                                    if (new_target && !(self.pos.isNearTo (new_target))) {
                                                        self.move_to (new_target);
                                                    }
                                                }
                                                else {
                                                    self.harvest_energy ();
                                                }
                                            }
                                        }
                                        else if (result == ERR_FULL) {
                                            self.targets.untarget (self, target_spawn_deposit);
                                            return true;
                                        }
                                        else {
                                            self.log ('Unknown result from spawn_fill-creep.transfer({}): {}', target, result);
                                            self.targets.untarget (self, target_spawn_deposit);
                                            return true;
                                        }
                                        return false;
                                    }
                                }
                                if (self.home.full_storage_use && self.memory.role == role_spawn_fill_backup && self.home.carry_mass_of (role_tower_fill) + self.home.carry_mass_of (role_spawn_fill) >= self.home.get_target_total_spawn_fill_mass ()) {
                                    self.memory.role = role_builder;
                                    return building.Builder.run (self);
                                }
                                else if (self.memory.role == role_spawn_fill_backup) {
                                    if (_.find (self.room.building.get_construction_targets (), (function __lambda__ (s) {
                                        return s.structureType == STRUCTURE_EXTENSION;
                                    })) || self.home.upgrading_deprioritized ()) {
                                        self.memory.running = role_builder;
                                        return building.Builder.run (self);
                                    }
                                    else {
                                        self.memory.running = role_upgrader;
                                        return upgrading.Upgrader.run (self);
                                    }
                                }
                                else if (!(self.home.full_storage_use) || self.home.room.storage.storeCapacity <= 0) {
                                    self.memory.running = 'refill';
                                    return self.refill_creeps ();
                                }
                                else if (self.creep.carry.energy < self.creep.carryCapacity) {
                                    self.memory.filling = true;
                                    return self.harvest_energy ();
                                }
                            }
                            return false;
                        });},
                        get should_pickup () {return __get__ (this, function (self, resource_type) {
                            if (typeof resource_type == 'undefined' || (resource_type != null && resource_type .hasOwnProperty ("__kwargtrans__"))) {;
                                var resource_type = null;
                            };
                            if (('running' in self.memory)) {
                                if (self.memory.running == role_upgrader) {
                                    return upgrading.Upgrader.should_pickup (self, resource_type);
                                }
                                else if (self.memory.running == role_builder) {
                                    return building.Builder.should_pickup (self, resource_type);
                                }
                            }
                            return RoleBase.should_pickup (self, resource_type);
                        });}
                    });
                    __pragma__ ('<use>' +
                        'cache.volatile_cache' +
                        'constants' +
                        'creeps.base' +
                        'creeps.behaviors.refill' +
                        'creeps.roles.building' +
                        'creeps.roles.upgrading' +
                        'jstools.screeps_constants' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.Refill = Refill;
                        __all__.RoleBase = RoleBase;
                        __all__.SpawnFill = SpawnFill;
                        __all__.building = building;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.recycle_time = recycle_time;
                        __all__.role_builder = role_builder;
                        __all__.role_recycling = role_recycling;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_spawn_fill_backup = role_spawn_fill_backup;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.target_spawn_deposit = target_spawn_deposit;
                        __all__.upgrading = upgrading;
                        __all__.volatile_cache = volatile_cache;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.tower_fill', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var target_tower_fill = __init__ (__world__.constants).target_tower_fill;
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var spawn_fill = __init__ (__world__.creeps.roles.spawn_fill);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var TowerFill = __class__ ('TowerFill', [spawn_fill.SpawnFill], {
                        get run () {return __get__ (this, function (self) {
                            if (self.creep.ticksToLive < recycle_time) {
                                self.memory.role = role_recycling;
                                self.memory.last_role = role_tower_fill;
                                return false;
                            }
                            if (self.memory.filling) {
                                if (self.creep.carry.energy >= self.creep.carryCapacity) {
                                    self.memory.filling = false;
                                    self.targets.untarget_all (self);
                                }
                            }
                            else if (self.creep.carry.energy <= 0) {
                                self.memory.filling = true;
                                delete self.memory.running;
                                self.targets.untarget_all (self);
                            }
                            if (self.memory.filling) {
                                return self.harvest_energy ();
                            }
                            else {
                                if (__mod__ (Game.time, 5) == 4) {
                                    var target = self.targets.get_new_target (self, target_tower_fill);
                                }
                                else {
                                    var target = self.targets.get_existing_target (self, target_tower_fill);
                                }
                                if (target) {
                                    if (!(self.home.role_count (role_spawn_fill)) && target.energy >= target.energyCapacity / 2) {
                                        return spawn_fill.SpawnFill.run (self);
                                    }
                                    if (!(self.pos.isNearTo (target))) {
                                        self.move_to (target);
                                        return false;
                                    }
                                    var result = self.creep.transfer (target, RESOURCE_ENERGY);
                                    if (result == ERR_FULL) {
                                        self.targets.untarget (self, target_tower_fill);
                                        return true;
                                    }
                                    else if (result != OK) {
                                        self.log ('Unknown result from tower_fill-creep.transfer({}): {}', target, result);
                                        self.targets.untarget (self, target_tower_fill);
                                    }
                                }
                                return spawn_fill.SpawnFill.run (self);
                            }
                        });}
                    });
                    var TowerFillOnce = __class__ ('TowerFillOnce', [RoleBase], {
                        get run () {return __get__ (this, function (self) {
                            if (self.memory.filling) {
                                if (self.creep.carry.energy >= self.creep.carryCapacity) {
                                    self.memory.filling = false;
                                    self.targets.untarget_all (self);
                                }
                            }
                            else if (self.creep.carry.energy <= 0) {
                                self.memory.filling = true;
                                delete self.memory.running;
                                self.targets.untarget_all (self);
                            }
                            if (self.memory.filling) {
                                return self.harvest_energy ();
                            }
                            else {
                                var target = self.targets.get_new_target (self, target_tower_fill);
                                if (target) {
                                    if (!(self.pos.isNearTo (target))) {
                                        self.move_to (target);
                                        return false;
                                    }
                                    var result = self.creep.transfer (target, RESOURCE_ENERGY);
                                    if (result == ERR_FULL) {
                                        self.targets.untarget (self, target_tower_fill);
                                        return true;
                                    }
                                    else if (result != OK) {
                                        self.log ('Unknown result from tower_fill-creep.transfer({}): {}', target, result);
                                        self.targets.untarget (self, target_tower_fill);
                                    }
                                }
                                else {
                                    self.memory.role = self.memory.old_role || role_builder;
                                    delete self.memory.old_role;
                                }
                            }
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.base' +
                        'creeps.roles.spawn_fill' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.RoleBase = RoleBase;
                        __all__.TowerFill = TowerFill;
                        __all__.TowerFillOnce = TowerFillOnce;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.recycle_time = recycle_time;
                        __all__.role_builder = role_builder;
                        __all__.role_recycling = role_recycling;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.spawn_fill = spawn_fill;
                        __all__.target_tower_fill = target_tower_fill;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.upgrading', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var creep_base_worker = __init__ (__world__.constants).creep_base_worker;
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_link_manager = __init__ (__world__.constants).role_link_manager;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_upgrade_fill = __init__ (__world__.constants).role_upgrade_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var target_home_flag = __init__ (__world__.constants).target_home_flag;
                    var spawning = __init__ (__world__.creep_management.spawning);
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var split_pos_str = function (pos_str) {
                        var pos_split = pos_str.py_split (',');
                        var x = int (pos_split [0]);
                        var y = int (pos_split [1]);
                        return [x, y];
                    };
                    var Upgrader = __class__ ('Upgrader', [RoleBase], {
                        get run () {return __get__ (this, function (self) {
                            var link = self.home.get_upgrader_energy_struct ();
                            if (link) {
                                return self.run_dedicated_upgrading (link);
                            }
                            else {
                                return self.run_individual_upgrading ();
                            }
                        });},
                        get run_dedicated_upgrading () {return __get__ (this, function (self, link) {
                            var controller = self.home.room.controller;
                            if (self.memory.set_till > Game.time) {
                                self.upgrade (controller);
                                self.harvest_from (link);
                                return ;
                            }
                            if (!(self.home.upgrading_deprioritized ()) || self.creep.room.controller.ticksToDowngrade <= 5000) {
                                self.upgrade (controller);
                            }
                            else if (__mod__ (Game.time, 15) == 2 || self.memory.set_till == Game.time) {
                                if (!(self.home.get_target_upgrader_work_mass ()) || !(self.home.spawn)) {
                                    if (len (self.creep.body) > 3 && spawning.find_base_type (self) == creep_base_worker) {
                                        self.memory.role = role_builder;
                                        return false;
                                    }
                                    else if (self.home.spawn) {
                                        self.memory.role = role_recycling;
                                        self.memory.last_role = role_upgrader;
                                        return false;
                                    }
                                }
                            }
                            if (__mod__ (Game.time, 15) == 7 || self.memory.set_till == Game.time) {
                                if (self.home.overprioritize_building ()) {
                                    if (len (self.creep.body) > 3 && spawning.find_base_type (self) == creep_base_worker) {
                                        self.memory.role = role_builder;
                                        return false;
                                    }
                                }
                                if (self.home.rcl >= 8 && self.home.role_count (role_upgrader) > 1 && self.home.work_mass_of (role_upgrader) > self.home.get_target_upgrader_work_mass ()) {
                                    var needed = self.home.get_target_upgrader_work_mass ();
                                    var any_big_enough = _.find (self.home.creeps, (function __lambda__ (c) {
                                        return c.memory.role == role_upgrader && c.getBodyparts (WORK) >= needed;
                                    }));
                                    if (any_big_enough) {
                                        var __iterable0__ = self.home.creeps;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var creep = __iterable0__ [__index0__];
                                            if (creep.memory.role == role_upgrader && creep.name != any_big_enough.name) {
                                                creep.suicide ();
                                            }
                                        }
                                        self.home.check_all_creeps_next_tick ();
                                    }
                                }
                            }
                            self.harvest_from (link);
                            var spot = self.targets.get_new_target (self, target_home_flag, UPGRADER_SPOT);
                            if (spot && self.home.role_count (role_upgrader) <= len (flags.find_flags (self.home, UPGRADER_SPOT))) {
                                if (self.pos.isEqualTo (spot.pos)) {
                                    self.memory.set_till = Game.time + 30;
                                }
                                else {
                                    self.move_to (spot);
                                }
                            }
                            else {
                                if (self.creep.ticksToLive < 50) {
                                    self.creep.suicide ();
                                    self.home.check_all_creeps_next_tick ();
                                    return ;
                                }
                                self.log ('WARNING: Not enough set upgrader spots in {}'.format (self.memory.home));
                                var available_positions = self.memory.controller_positions;
                                if (!(available_positions) || __mod__ (Game.time + self.creep.ticksToLive, 25)) {
                                    var available_positions = [];
                                    for (var x = link.pos.x - 1; x < link.pos.x + 2; x++) {
                                        for (var y = link.pos.y - 1; y < link.pos.y + 2; y++) {
                                            if (x != link.pos.x || y != link.pos.y) {
                                                if (abs (x - controller.pos.x) <= 3 && abs (y - controller.pos.y) <= 3 && Game.map.getTerrainAt (x, y, self.pos.roomName) != 'wall') {
                                                    available_positions.append ('{},{}'.format (x, y));
                                                }
                                            }
                                        }
                                    }
                                    self.memory.controller_positions = available_positions;
                                }
                                if (self.memory.get_near_controller) {
                                    if (self.creep.carry.energy > self.creep.carryCapacity * 0.5) {
                                        if (self.pos.isNearTo (link) || !(self.pos.isNearTo (controller))) {
                                            if (self.home.role_count (role_upgrader) < 4) {
                                                var basic_moved = self.basic_move_to (controller);
                                            }
                                            else {
                                                var self_empty = self.creep.carryCapacity - self.carry_sum ();
                                                var basic_moved = self.force_basic_move_to (controller, (function __lambda__ (other) {
                                                    return other.carryCapacity - _.sum (other.carry) > self_empty;
                                                }));
                                            }
                                            if (!(basic_moved)) {
                                                self.move_to (controller);
                                            }
                                        }
                                        return ;
                                    }
                                    else {
                                        delete self.memory.get_near_controller;
                                    }
                                }
                                if (!(self.pos.inRangeTo (controller, 3)) || !(self.pos.isNearTo (link))) {
                                    var a_creep_with_energy = null;
                                    var __break0__ = false;
                                    var __iterable0__ = available_positions;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var pos = __iterable0__ [__index0__];
                                        var __left0__ = split_pos_str (pos);
                                        var x = __left0__ [0];
                                        var y = __left0__ [1];
                                        var that_creep = _.find (self.home.look_at (LOOK_CREEPS, x, y));
                                        if (!(that_creep)) {
                                            self.move_to (new RoomPosition (x, y, self.home.name));
                                            __break0__ = true;
                                            break;
                                        }
                                        else if (that_creep.carry.energy >= that_creep.carryCapacity * 0.5 && that_creep.memory.role == role_upgrader && !(that_creep.memory.get_near_controller)) {
                                            var a_creep_with_energy = that_creep;
                                        }
                                    }
                                    if (!__break0__) {
                                        if (self.creep.carry.energy < self.creep.carryCapacity * 0.25) {
                                            var closest_full = _.find (self.room.look_for_in_area_around (LOOK_CREEPS, self.pos, 1), (function __lambda__ (c) {
                                                return c.creep.memory.role == role_upgrader && c.creep.carry.energy >= c.creep.carryCapacity * 0.75 && c.creep.pos.inRangeTo (link.pos, 1);
                                            }));
                                            if (closest_full) {
                                                closest_full.creep.move (closest_full.creep.pos.getDirectionTo (self.pos));
                                                self.creep.move (self.pos.getDirectionTo (closest_full.creep.pos));
                                            }
                                            else if (a_creep_with_energy) {
                                                a_creep_with_energy.memory.get_near_controller = true;
                                                self.creep.move (self.pos.getDirectionTo (link.pos));
                                            }
                                        }
                                        else if (!(self.pos.inRangeTo (controller, 3))) {
                                            self.move_to (controller);
                                        }
                                    }
                                    return ;
                                }
                                if (!(_.find (self.room.look_for_in_area_around (LOOK_CREEPS, self.pos, 1), (function __lambda__ (c) {
                                    return c.creep.memory.role != role_upgrader && c.creep.memory.role != role_link_manager;
                                })))) {
                                    return ;
                                }
                                if (len (available_positions)) {
                                    var __left0__ = split_pos_str (available_positions [__mod__ (Game.time + 2, len (available_positions))]);
                                    var target_x = __left0__ [0];
                                    var target_y = __left0__ [1];
                                    self.basic_move_to ({'x': target_x, 'y': target_y});
                                }
                            }
                        });},
                        get upgrade () {return __get__ (this, function (self, controller) {
                            var result = self.creep.upgradeController (controller);
                            if (result != OK && result != ERR_NOT_IN_RANGE && result != ERR_NOT_ENOUGH_RESOURCES) {
                                self.log ('Unknown result from creep.upgradeController({}): {}', self.creep.room.controller, result);
                            }
                        });},
                        get harvest_from () {return __get__ (this, function (self, link) {
                            if (self.creep.ticksToLive < 20 || self.creep.carry.energy >= self.creep.getActiveBodyparts (WORK) * 3) {
                                return ;
                            }
                            if (link.structureType == STRUCTURE_LINK) {
                                self.home.links.register_target_withdraw (link, self, self.creep.carryCapacity - self.creep.carry.energy, self.pos.getRangeTo (link));
                            }
                            var result = self.creep.withdraw (link, RESOURCE_ENERGY);
                            if (result != OK && result != ERR_NOT_IN_RANGE && result != ERR_NOT_ENOUGH_RESOURCES) {
                                self.log ('Unknown result from creep.withdraw({}): {}', link, result);
                            }
                        });},
                        get should_pickup () {return __get__ (this, function (self, resource_type) {
                            if (typeof resource_type == 'undefined' || (resource_type != null && resource_type .hasOwnProperty ("__kwargtrans__"))) {;
                                var resource_type = null;
                            };
                            return RoleBase.should_pickup (self, resource_type) && !(self.home.upgrading_paused ());
                        });},
                        get run_individual_upgrading () {return __get__ (this, function (self) {
                            if (self.creep.ticksToLive < recycle_time && self.home.spawn) {
                                self.memory.role = role_recycling;
                                self.memory.last_role = role_upgrader;
                                return false;
                            }
                            if (self.home.overprioritize_building () && self.home.room.controller.ticksToDowngrade >= 500) {
                                self.memory.role = role_builder;
                                return false;
                            }
                            if (self.memory.filling && self.creep.carry.energy >= self.creep.carryCapacity) {
                                self.memory.filling = false;
                                self.finished_energy_harvest ();
                            }
                            else if (!(self.memory.filling) && self.creep.carry.energy <= 0 && self.creep.getBodyparts (CARRY) > self.creep.getBodyparts (WORK)) {
                                self.memory.filling = true;
                                self.finished_energy_harvest ();
                            }
                            if (__mod__ (Game.time, 5) == 0 && !(self.creep.hasActiveBodyparts (WORK) & self.creep.hasActiveBodyparts (CARRY)) && !(self.home.defense.healing_capable ())) {
                                if (self.home.spawn) {
                                    return self.recycle_me ();
                                }
                                else {
                                    self.creep.suicide ();
                                    return ;
                                }
                            }
                            if (self.home.upgrading_deprioritized () && self.creep.room.controller.ticksToDowngrade > 5000) {
                                if (self.home.room.storage && self.empty_to_storage ()) {
                                    return false;
                                }
                                else if (!(self.home.get_target_upgrader_work_mass ()) || !(self.home.spawn)) {
                                    if (len (self.creep.body) > 3 && spawning.find_base_type (self) == creep_base_worker) {
                                        self.memory.role = role_builder;
                                        return false;
                                    }
                                    else if (self.home.spawn) {
                                        self.memory.role = role_recycling;
                                        self.memory.last_role = role_upgrader;
                                        return false;
                                    }
                                }
                            }
                            if (!(self.home.room.controller.my) || self.home.upgrading_paused () && self.creep.room.controller.ticksToDowngrade >= 9900) {
                                if (!(self.empty_to_storage ())) {
                                    self.go_to_depot ();
                                }
                                return false;
                            }
                            if (self.memory.filling && (!(self.home.upgrading_deprioritized ()) || self.creep.room.controller.ticksToDowngrade <= 5000)) {
                                self.targets.untarget (self, target_home_flag);
                                self.build_swamp_roads ();
                                self.harvest_energy ();
                            }
                            else {
                                var spot = self.targets.get_new_target (self, target_home_flag, UPGRADER_SPOT);
                                var target = self.home.room.controller;
                                if (spot) {
                                    if (self.pos.isEqualTo (spot.pos)) {
                                        var result = self.creep.upgradeController (target);
                                        if (result == ERR_NOT_ENOUGH_RESOURCES) {
                                            if (!(self.memory.filling) && self.creep.getActiveBodyparts (CARRY) > self.creep.getActiveBodyparts (WORK)) {
                                                self.memory.filling = true;
                                                return true;
                                            }
                                        }
                                        else if (result != OK) {
                                            self.log ('Unknown result from upgradeController({}): {}', self.creep.room.controller, result);
                                        }
                                    }
                                    else {
                                        self.build_swamp_roads ();
                                        self.move_to (spot);
                                    }
                                }
                                else {
                                    if (!(self.pos.inRangeTo (target, 3))) {
                                        self.build_swamp_roads ();
                                        self.move_to (target);
                                        return false;
                                    }
                                    var result = self.creep.upgradeController (target);
                                    if (result == ERR_NOT_ENOUGH_RESOURCES) {
                                        if (!(self.memory.filling) && self.creep.getActiveBodyparts (CARRY) > self.creep.getActiveBodyparts (WORK)) {
                                            self.memory.filling = true;
                                            return true;
                                        }
                                    }
                                    if (result == OK || result == ERR_NOT_ENOUGH_RESOURCES) {
                                        if (self.home.full_storage_use || self.home.being_bootstrapped ()) {
                                            if (self.home.role_count (role_upgrader) < 4) {
                                                self.basic_move_to (target);
                                            }
                                            else {
                                                var self_empty = self.creep.carryCapacity - self.carry_sum ();
                                                self.force_basic_move_to (target, (function __lambda__ (other) {
                                                    return other.carryCapacity - _.sum (other.carry) > self_empty;
                                                }));
                                            }
                                        }
                                        else {
                                            var self_empty = self.creep.carryCapacity - self.carry_sum ();
                                            var can_move_over = function (other_creep) {
                                                var other_empty = other_creep.carryCapacity - _.sum (other_creep.carry);
                                                if (other_empty > self_empty) {
                                                    self.creep.transfer (other_creep, RESOURCE_ENERGY, math.ceil ((other_empty - self_empty) / 3));
                                                    return true;
                                                }
                                                else if (self_empty < other_empty) {
                                                    other_creep.transfer (self.creep, RESOURCE_ENERGY, math.ceil ((self_empty - other_empty) / 3));
                                                }
                                                return false;
                                            };
                                            self.force_basic_move_to (target, can_move_over);
                                        }
                                    }
                                    else {
                                        self.log ('Unknown result from upgradeController({}): {}', self.creep.room.controller, result);
                                        if (self.creep.carry.energy < self.creep.carryCapacity) {
                                            self.memory.filling = true;
                                        }
                                        else {
                                            self.go_to_depot ();
                                        }
                                    }
                                }
                            }
                        });},
                        get build_swamp_roads () {return __get__ (this, function (self) {
                            if (!(_.get (self.home.room, 'storage.storeCapacity')) && self.creep.carry.energy > 0) {
                                if (Game.map.getTerrainAt (self.pos.x, self.pos.y, self.pos.roomName) == 'swamp') {
                                    var repair = _.find (self.room.look_at (LOOK_STRUCTURES, self.pos), (function __lambda__ (s) {
                                        return s.structureType == STRUCTURE_ROAD && s.hits < s.hitsMax;
                                    }));
                                    if (repair) {
                                        var result = self.creep.repair (repair);
                                        if (result != OK) {
                                            self.log ('Unknown result from passingby-road-repair on {}: {}'.format (repair, result));
                                        }
                                    }
                                    else {
                                        var build = self.room.look_at (LOOK_CONSTRUCTION_SITES, self.pos);
                                        if (len (build)) {
                                            var build = _.find (build, (function __lambda__ (s) {
                                                return s.structureType == STRUCTURE_ROAD;
                                            }));
                                            if (build) {
                                                var result = self.creep.build (build);
                                                if (result != OK) {
                                                    self.log ('Unknown result from passingby-road-build on {}: {}'.format (build, result));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            if (self.home.spawn) {
                                var path_length = self.hive.honey.find_path_length (self.home.spawn, self.home.room.controller);
                                return path_length * 2 + _.size (self.creep.body) * 3;
                            }
                            else {
                                return _.size (self.creep.body) * 3 + 15;
                            }
                        });}
                    });
                    var DedicatedUpgradeFiller = __class__ ('DedicatedUpgradeFiller', [RoleBase], {
                        get run () {return __get__ (this, function (self) {
                            if (self.memory.filling && self.creep.carry.energy >= self.creep.carryCapacity) {
                                self.memory.filling = false;
                            }
                            else if (!(self.memory.filling) && self.creep.carry.energy <= 0) {
                                self.memory.filling = true;
                            }
                            if (!('set' in self.memory) || __mod__ (Game.time, 100) == 92) {
                                if (self.memory.emptying_container) {
                                    var container = Game.getObjectById (self.memory.emptying_container);
                                    if (!(container)) {
                                        delete self.memory.emptying_container;
                                        return true;
                                    }
                                    if (self.memory.filling) {
                                        if (self.pos.isNearTo (container)) {
                                            var resource = _.findKey (container.store);
                                            if (!(resource)) {
                                                container.destroy ();
                                                return false;
                                            }
                                            var result = self.creep.withdraw (container, resource);
                                            if (result != OK) {
                                                self.log ('Unknown result from creep.withdraw({}, {})'.format (container, resource));
                                            }
                                        }
                                        else {
                                            self.move_to (container);
                                        }
                                    }
                                    else if (self.pos.isNearTo (self.home.room.storage)) {
                                        var resource = _.findKey (self.creep.carry);
                                        var result = self.creep.transfer (self.home.room.storage, resource);
                                        if (result != OK) {
                                            self.log ('Unknown result from creep.withdraw({}, {})'.format (self.home.room.storage, resource));
                                        }
                                    }
                                    else {
                                        self.move_to (self.home.room.storage);
                                    }
                                    return false;
                                }
                                if (!(self.home.get_target_upgrade_fill_mass ())) {
                                    var current_target = self.home.get_upgrader_energy_struct ();
                                    if (!(current_target) || current_target.structureType != STRUCTURE_CONTAINER) {
                                        var old_container = _.find (self.home.look_for_in_area_around (LOOK_STRUCTURES, self.home.room.controller, 4), (function __lambda__ (obj) {
                                            return obj.structure.structureType == STRUCTURE_CONTAINER;
                                        }));
                                        if (old_container) {
                                            self.memory.emptying_container = old_container.structure.id;
                                            delete self.memory.set;
                                            return true;
                                        }
                                        else if (!(current_target) || current_target.structureType != STRUCTURE_CONTAINER) {
                                            self.memory.role = role_recycling;
                                            self.memory.last_role = role_upgrade_fill;
                                            return false;
                                        }
                                    }
                                }
                                var mineral_held = _.findKey (self.creep.carry, (function __lambda__ (amount, mineral) {
                                    return amount > 0 && mineral != RESOURCE_ENERGY;
                                }));
                                if (mineral_held) {
                                    if (!(self.empty_to_storage ())) {
                                        var result = self.creep.drop (mineral_held);
                                        if (result != OK) {
                                            self.log ('Unknown result from ufill-creep.drop({}): {}'.format (mineral_held, result));
                                        }
                                    }
                                    return false;
                                }
                                self.memory.set = true;
                            }
                            if (self.memory.filling) {
                                self.harvest_energy ();
                            }
                            else {
                                var target = self.home.get_upgrader_energy_struct ();
                                if (self.pos.isNearTo (target)) {
                                    var result = self.creep.transfer (target, RESOURCE_ENERGY);
                                    if (result != OK && result != ERR_FULL) {
                                        self.log ('Unknown result from ufill-creep.transfer({}, {}): {}'.format (target, RESOURCE_ENERGY, result));
                                    }
                                }
                                else {
                                    self.move_to (target);
                                }
                            }
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creep_management.spawning' +
                        'creeps.base' +
                        'jstools.screeps_constants' +
                        'math' +
                        'position_management.flags' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.DedicatedUpgradeFiller = DedicatedUpgradeFiller;
                        __all__.RoleBase = RoleBase;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__.Upgrader = Upgrader;
                        __all__.creep_base_worker = creep_base_worker;
                        __all__.flags = flags;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.recycle_time = recycle_time;
                        __all__.role_builder = role_builder;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_recycling = role_recycling;
                        __all__.role_upgrade_fill = role_upgrade_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.spawning = spawning;
                        __all__.split_pos_str = split_pos_str;
                        __all__.target_home_flag = target_home_flag;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'creeps.roles.utility', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var role_cleanup = __init__ (__world__.constants).role_cleanup;
                    var role_link_manager = __init__ (__world__.constants).role_link_manager;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var SpawnFill = __init__ (__world__.creeps.roles.spawn_fill).SpawnFill;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var movement = __init__ (__world__.utilities.movement);
                    var LinkManager = __class__ ('LinkManager', [RoleBase], {
                        get run () {return __get__ (this, function (self) {
                            var link = self.home.links.main_link;
                            var storage = self.home.room.storage;
                            if (!(link) || !(storage)) {
                                self.log ("ERROR: Link manager can't find main link or storage in {}.".format (self.home.name));
                                self.go_to_depot ();
                                return false;
                            }
                            if (!('station_pos' in self.memory)) {
                                var best_priority = 0;
                                var best = null;
                                for (var x = link.pos.x - 1; x < link.pos.x + 2; x++) {
                                    for (var y = link.pos.y - 1; y < link.pos.y + 2; y++) {
                                        if ((-(1) <= x - storage.pos.x && x - storage.pos.x <= 1) && (-(1) <= y - storage.pos.y && y - storage.pos.y <= 1) && (storage.pos.x != x || storage.pos.y != y) && (link.pos.x != x || link.pos.y != y)) {
                                            if (!(movement.is_block_empty (self.home, x, y))) {
                                                continue;
                                            }
                                            var creeps = self.home.look_at (LOOK_CREEPS, x, y);
                                            if (len (creeps) != 0) {
                                                var creep = creeps [0];
                                                if (creep.memory.role == role_link_manager) {
                                                    if (self.creep.ticksTolive > creep.ticksToLive) {
                                                        creep.suicide ();
                                                    }
                                                    else {
                                                        self.creep.suicide ();
                                                        return false;
                                                    }
                                                }
                                            }
                                            var pos = new RoomPosition (x, y, self.home.name);
                                            var priority = 1;
                                            if ((link.pos.x == storage.pos.x && storage.pos.x == pos.x)) {
                                                priority += 5;
                                            }
                                            else if ((link.pos.y == storage.pos.y && storage.pos.y == pos.y)) {
                                                priority += 5;
                                            }
                                            if (priority >= best_priority) {
                                                var best = pos;
                                                var best_priority = priority;
                                            }
                                        }
                                    }
                                }
                                if (best === null) {
                                    self.go_to_depot ();
                                    return false;
                                }
                                self.memory.station_pos = best.x | best.y << 6;
                            }
                            var current_pos = self.pos.x | self.pos.y << 6;
                            if (current_pos != self.memory.station_pos) {
                                self.move_to (new RoomPosition (self.memory.station_pos & 63, self.memory.station_pos >> 6 & 63, self.home.name));
                                return false;
                            }
                            if (self.ensure_no_minerals ()) {
                                return false;
                            }
                            if (self.creep.carry.energy != self.creep.carryCapacity / 2) {
                                if (self.creep.carry.energy > self.creep.carryCapacity / 2) {
                                    var result = self.creep.transfer (storage, RESOURCE_ENERGY, self.creep.carry.energy - self.creep.carryCapacity / 2);
                                    if (result == ERR_FULL) {
                                        var result = self.creep.transfer (self.home.links.main_link, RESOURCE_ENERGY, self.creep.carry.energy - self.creep.carryCapacity / 2);
                                    }
                                    self.ensure_ok (result, 'transfer', storage, RESOURCE_ENERGY);
                                }
                                else {
                                    var target = storage;
                                    var result = self.creep.withdraw (target, RESOURCE_ENERGY, self.creep.carryCapacity / 2 - self.creep.carry.energy);
                                    if (result == ERR_NOT_ENOUGH_RESOURCES) {
                                        var target = self.home.links.main_link;
                                        var result = self.creep.withdraw (target, RESOURCE_ENERGY, self.creep.carryCapacity / 2 - self.creep.carry.energy);
                                    }
                                    self.ensure_ok (result, 'withdraw', target, RESOURCE_ENERGY);
                                }
                                return false;
                            }
                            self.home.links.note_link_manager (self);
                            return false;
                        });},
                        get ensure_ok () {return __get__ (this, function (self, result, action, p1, p2) {
                            if (result != OK) {
                                self.log ('ERROR: Unknown result from link creep.{}({},{}): {}!'.format (action, p1, p2, result));
                            }
                        });},
                        get ensure_no_minerals () {return __get__ (this, function (self) {
                            var storage = self.home.room.storage;
                            if (self.carry_sum () > self.creep.carry.energy) {
                                var __iterable0__ = Object.keys (self.creep.carry);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var rtype = __iterable0__ [__index0__];
                                    if (rtype != RESOURCE_ENERGY) {
                                        self.ensure_ok (self.creep.transfer (storage, rtype), 'transfer', storage, rtype);
                                        return true;
                                    }
                                }
                            }
                            return false;
                        });},
                        get send_to_link () {return __get__ (this, function (self, amount) {
                            if (typeof amount == 'undefined' || (amount != null && amount .hasOwnProperty ("__kwargtrans__"))) {;
                                var amount = null;
                            };
                            var storage = self.home.room.storage;
                            var link = self.home.links.main_link;
                            if (!(amount) || amount > self.creep.carryCapacity / 2) {
                                var amount = self.creep.carryCapacity / 2;
                            }
                            if (amount > link.energyCapacity - link.energy) {
                                var amount = link.energyCapacity - link.energy;
                            }
                            if (link.energy == link.energyCapacity) {
                                return ;
                            }
                            self.ensure_ok (self.creep.transfer (link, RESOURCE_ENERGY, amount), 'transfer', link, RESOURCE_ENERGY);
                            self.ensure_ok (self.creep.withdraw (storage, RESOURCE_ENERGY, amount), 'withdraw', link, RESOURCE_ENERGY);
                        });},
                        get send_from_link () {return __get__ (this, function (self, amount) {
                            if (typeof amount == 'undefined' || (amount != null && amount .hasOwnProperty ("__kwargtrans__"))) {;
                                var amount = null;
                            };
                            var storage = self.home.room.storage;
                            var link = self.home.links.main_link;
                            if (!(amount) || amount > self.creep.carryCapacity / 2) {
                                var amount = self.creep.carryCapacity / 2;
                            }
                            if (amount > link.energy) {
                                var amount = link.energy;
                            }
                            if (link.energy == 0) {
                                return ;
                            }
                            self.ensure_ok (self.creep.withdraw (link, RESOURCE_ENERGY, amount), 'withdraw', link, RESOURCE_ENERGY);
                            self.ensure_ok (self.creep.transfer (storage, RESOURCE_ENERGY, amount), 'transfer', link, RESOURCE_ENERGY);
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            var link = self.home.links.main_link;
                            if (!(link)) {
                                return -(1);
                            }
                            var link_pos = link.pos;
                            return self.hive.honey.find_path_length (self.home.spawn, link_pos) * 2 + _.size (self.creep.body) * 3;
                        });}
                    });
                    var Cleanup = __class__ ('Cleanup', [SpawnFill], {
                        get run () {return __get__ (this, function (self) {
                            if (self.creep.ticksToLive < recycle_time) {
                                self.memory.role = role_recycling;
                                self.memory.last_role = role_cleanup;
                                return false;
                            }
                            var storage = self.creep.room.storage;
                            if (self.memory.filling && self.carry_sum () >= self.creep.carryCapacity) {
                                self.memory.filling = false;
                            }
                            if (!(self.memory.filling) && self.carry_sum () <= 0) {
                                self.memory.filling = true;
                            }
                            if (self.memory.filling) {
                                var resources = self.room.find (FIND_DROPPED_RESOURCES);
                                if (len (resources)) {
                                    var closest = null;
                                    var closest_distance = Infinity;
                                    var __iterable0__ = resources;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var resource = __iterable0__ [__index0__];
                                        if (len (self.room.find_in_range (FIND_HOSTILE_CREEPS, 3, resource.pos)) == 0) {
                                            if (len (self.room.find_in_range (FIND_SOURCES, 1, resource.pos)) == 0) {
                                                if (self.memory.last_energy_target) {
                                                    var compressed_pos = resource.pos.x | resource.pos.y << 6;
                                                    if (compressed_pos == self.memory.last_energy_target) {
                                                        var closest = resource;
                                                        break;
                                                    }
                                                }
                                                var distance = movement.distance_squared_room_pos (self.pos, resource);
                                                if (distance < closest_distance) {
                                                    var closest = resource;
                                                    var closest_distance = distance;
                                                }
                                            }
                                        }
                                    }
                                    var pile = closest;
                                }
                                else {
                                    var pile = null;
                                }
                                if (!(pile)) {
                                    delete self.memory.last_energy_target;
                                    self.go_to_depot ();
                                    return ;
                                }
                                self.memory.last_energy_target = pile.pos.x | pile.pos.y << 6;
                                if (!(self.pos.isNearTo (pile))) {
                                    self.move_to (pile);
                                    return false;
                                }
                                var result = self.creep.pickup (pile);
                                if (result == ERR_FULL) {
                                    self.memory.filling = false;
                                    return true;
                                }
                                else if (result != OK) {
                                    self.log ('Unknown result from cleanup-creep.pickup({}): {}', pile, result);
                                }
                            }
                            else {
                                if (!(storage)) {
                                    return SpawnFill.run (self);
                                }
                                if (self.pos.roomName != storage.pos.roomName) {
                                    self.move_to (storage);
                                    return false;
                                }
                                if (self.carry_sum () > self.creep.carry.energy) {
                                    var target = storage;
                                }
                                else {
                                    var target = self.targets.get_new_target (self, target_closest_energy_site);
                                    if (!(target)) {
                                        var target = storage;
                                    }
                                }
                                if (target.structureType == STRUCTURE_LINK) {
                                    self.home.links.register_target_deposit (target, self, self.creep.carry.energy, self.pos.getRangeTo (target));
                                }
                                if (!(self.pos.isNearTo (target))) {
                                    if (self.pos.isNearTo (storage)) {
                                        var target = storage;
                                    }
                                    else {
                                        self.move_to (target);
                                        return false;
                                    }
                                }
                                var resource_type = _.find (Object.keys (self.creep.carry), (function __lambda__ (r) {
                                    return self.creep.carry [r] > 0;
                                }));
                                var result = self.creep.transfer (target, resource_type);
                                if (result == ERR_NOT_ENOUGH_RESOURCES) {
                                    self.memory.filling = true;
                                    return true;
                                }
                                else if (result == ERR_FULL) {
                                    if (target == storage) {
                                        self.log ('Storage in room {} full!', storage.room.name);
                                    }
                                }
                                else if (result != OK) {
                                    self.log ('Unknown result from cleanup-creep.transfer({}, {}): {}', target, resource_type, result);
                                }
                            }
                        });},
                        get _calculate_time_to_replace () {return __get__ (this, function (self) {
                            return 0;
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'creeps.base' +
                        'creeps.roles.spawn_fill' +
                        'jstools.screeps_constants' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.Cleanup = Cleanup;
                        __all__.LinkManager = LinkManager;
                        __all__.RoleBase = RoleBase;
                        __all__.SpawnFill = SpawnFill;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.recycle_time = recycle_time;
                        __all__.role_cleanup = role_cleanup;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_recycling = role_recycling;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'empire.hive', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
                    var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
                    var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
                    var PYFIND_BUILDABLE_ROADS = __init__ (__world__.constants).PYFIND_BUILDABLE_ROADS;
                    var PYFIND_HURT_CREEPS = __init__ (__world__.constants).PYFIND_HURT_CREEPS;
                    var PYFIND_REPAIRABLE_ROADS = __init__ (__world__.constants).PYFIND_REPAIRABLE_ROADS;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var REROUTE = __init__ (__world__.constants).REROUTE;
                    var REROUTE_DESTINATION = __init__ (__world__.constants).REROUTE_DESTINATION;
                    var RESERVE_NOW = __init__ (__world__.constants).RESERVE_NOW;
                    var SCOUT = __init__ (__world__.constants).SCOUT;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var SK_USERNAME = __init__ (__world__.constants).SK_USERNAME;
                    var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
                    var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
                    var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
                    var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
                    var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var creep_base_1500miner = __init__ (__world__.constants).creep_base_1500miner;
                    var creep_base_3000miner = __init__ (__world__.constants).creep_base_3000miner;
                    var creep_base_3h = __init__ (__world__.constants).creep_base_3h;
                    var creep_base_4000miner = __init__ (__world__.constants).creep_base_4000miner;
                    var creep_base_carry3000miner = __init__ (__world__.constants).creep_base_carry3000miner;
                    var creep_base_claim_attack = __init__ (__world__.constants).creep_base_claim_attack;
                    var creep_base_claiming = __init__ (__world__.constants).creep_base_claiming;
                    var creep_base_defender = __init__ (__world__.constants).creep_base_defender;
                    var creep_base_dismantler = __init__ (__world__.constants).creep_base_dismantler;
                    var creep_base_full_move_dismantler = __init__ (__world__.constants).creep_base_full_move_dismantler;
                    var creep_base_full_move_goader = __init__ (__world__.constants).creep_base_full_move_goader;
                    var creep_base_full_move_healer = __init__ (__world__.constants).creep_base_full_move_healer;
                    var creep_base_full_move_power_attack = __init__ (__world__.constants).creep_base_full_move_power_attack;
                    var creep_base_full_upgrader = __init__ (__world__.constants).creep_base_full_upgrader;
                    var creep_base_goader = __init__ (__world__.constants).creep_base_goader;
                    var creep_base_half_move_hauler = __init__ (__world__.constants).creep_base_half_move_hauler;
                    var creep_base_half_move_healer = __init__ (__world__.constants).creep_base_half_move_healer;
                    var creep_base_hauler = __init__ (__world__.constants).creep_base_hauler;
                    var creep_base_mammoth_miner = __init__ (__world__.constants).creep_base_mammoth_miner;
                    var creep_base_power_attack = __init__ (__world__.constants).creep_base_power_attack;
                    var creep_base_rampart_defense = __init__ (__world__.constants).creep_base_rampart_defense;
                    var creep_base_ranged_offense = __init__ (__world__.constants).creep_base_ranged_offense;
                    var creep_base_reserving = __init__ (__world__.constants).creep_base_reserving;
                    var creep_base_scout = __init__ (__world__.constants).creep_base_scout;
                    var creep_base_work_full_move_hauler = __init__ (__world__.constants).creep_base_work_full_move_hauler;
                    var creep_base_work_half_move_hauler = __init__ (__world__.constants).creep_base_work_half_move_hauler;
                    var creep_base_worker = __init__ (__world__.constants).creep_base_worker;
                    var default_roles = __init__ (__world__.constants).default_roles;
                    var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
                    var gmem_key_last_room_state_refresh = __init__ (__world__.constants).gmem_key_last_room_state_refresh;
                    var gmem_key_room_mining_paths = __init__ (__world__.constants).gmem_key_room_mining_paths;
                    var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
                    var max_repave_mine_roads_every = __init__ (__world__.constants).max_repave_mine_roads_every;
                    var min_repath_mine_roads_every = __init__ (__world__.constants).min_repath_mine_roads_every;
                    var min_repave_mine_roads_every = __init__ (__world__.constants).min_repave_mine_roads_every;
                    var old_role_names = __init__ (__world__.constants).old_role_names;
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var request_priority_economy = __init__ (__world__.constants).request_priority_economy;
                    var request_priority_helping_party = __init__ (__world__.constants).request_priority_helping_party;
                    var request_priority_imminent_threat_defense = __init__ (__world__.constants).request_priority_imminent_threat_defense;
                    var request_priority_low = __init__ (__world__.constants).request_priority_low;
                    var rmem_key_building_paused = __init__ (__world__.constants).rmem_key_building_paused;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
                    var rmem_key_cache = __init__ (__world__.constants).rmem_key_cache;
                    var rmem_key_carry_parts_by_role = __init__ (__world__.constants).rmem_key_carry_parts_by_role;
                    var rmem_key_creeps_by_role = __init__ (__world__.constants).rmem_key_creeps_by_role;
                    var rmem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants).rmem_key_creeps_by_role_and_replacement_time;
                    var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
                    var rmem_key_defense_mind_storage = __init__ (__world__.constants).rmem_key_defense_mind_storage;
                    var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants).rmem_key_empty_all_resources_into_room;
                    var rmem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants).rmem_key_flag_for_testing_spawning_in_simulation;
                    var rmem_key_focusing_home = __init__ (__world__.constants).rmem_key_focusing_home;
                    var rmem_key_linking_mind_storage = __init__ (__world__.constants).rmem_key_linking_mind_storage;
                    var rmem_key_metadata = __init__ (__world__.constants).rmem_key_metadata;
                    var rmem_key_mineral_mind_storage = __init__ (__world__.constants).rmem_key_mineral_mind_storage;
                    var rmem_key_now_supporting = __init__ (__world__.constants).rmem_key_now_supporting;
                    var rmem_key_pause_all_room_operations = __init__ (__world__.constants).rmem_key_pause_all_room_operations;
                    var rmem_key_planned_role_to_spawn = __init__ (__world__.constants).rmem_key_planned_role_to_spawn;
                    var rmem_key_prepping_defenses = __init__ (__world__.constants).rmem_key_prepping_defenses;
                    var rmem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants).rmem_key_remotes_explicitly_marked_under_attack;
                    var rmem_key_remotes_safe_when_under_siege = __init__ (__world__.constants).rmem_key_remotes_safe_when_under_siege;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
                    var rmem_key_spawn_requests = __init__ (__world__.constants).rmem_key_spawn_requests;
                    var rmem_key_sponsor = __init__ (__world__.constants).rmem_key_sponsor;
                    var rmem_key_storage_use_enabled = __init__ (__world__.constants).rmem_key_storage_use_enabled;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
                    var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants).rmem_key_there_might_be_energy_lying_around;
                    var rmem_key_total_open_source_spaces = __init__ (__world__.constants).rmem_key_total_open_source_spaces;
                    var rmem_key_upgrading_paused = __init__ (__world__.constants).rmem_key_upgrading_paused;
                    var rmem_key_work_parts_by_role = __init__ (__world__.constants).rmem_key_work_parts_by_role;
                    var role_bases = __init__ (__world__.constants).role_bases;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_cleanup = __init__ (__world__.constants).role_cleanup;
                    var role_colonist = __init__ (__world__.constants).role_colonist;
                    var role_defender = __init__ (__world__.constants).role_defender;
                    var role_energy_grab = __init__ (__world__.constants).role_energy_grab;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_link_manager = __init__ (__world__.constants).role_link_manager;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
                    var role_mineral_miner = __init__ (__world__.constants).role_mineral_miner;
                    var role_mineral_steal = __init__ (__world__.constants).role_mineral_steal;
                    var role_power_attack = __init__ (__world__.constants).role_power_attack;
                    var role_power_cleanup = __init__ (__world__.constants).role_power_cleanup;
                    var role_ranged_offense = __init__ (__world__.constants).role_ranged_offense;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_remote_mining_reserve = __init__ (__world__.constants).role_remote_mining_reserve;
                    var role_room_reserve = __init__ (__world__.constants).role_room_reserve;
                    var role_scout = __init__ (__world__.constants).role_scout;
                    var role_simple_claim = __init__ (__world__.constants).role_simple_claim;
                    var role_simple_dismantle = __init__ (__world__.constants).role_simple_dismantle;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_spawn_fill_backup = __init__ (__world__.constants).role_spawn_fill_backup;
                    var role_td_goad = __init__ (__world__.constants).role_td_goad;
                    var role_td_healer = __init__ (__world__.constants).role_td_healer;
                    var role_temporary_replacing = __init__ (__world__.constants).role_temporary_replacing;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var role_tower_fill_once = __init__ (__world__.constants).role_tower_fill_once;
                    var role_upgrade_fill = __init__ (__world__.constants).role_upgrade_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var role_wall_defender = __init__ (__world__.constants).role_wall_defender;
                    var target_big_big_repair = __init__ (__world__.constants).target_big_big_repair;
                    var target_big_repair = __init__ (__world__.constants).target_big_repair;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var target_construction = __init__ (__world__.constants).target_construction;
                    var target_destruction_site = __init__ (__world__.constants).target_destruction_site;
                    var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
                    var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
                    var target_home_flag = __init__ (__world__.constants).target_home_flag;
                    var target_rampart_defense = __init__ (__world__.constants).target_rampart_defense;
                    var target_refill = __init__ (__world__.constants).target_refill;
                    var target_repair = __init__ (__world__.constants).target_repair;
                    var target_reserve_now = __init__ (__world__.constants).target_reserve_now;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var target_single_flag2 = __init__ (__world__.constants).target_single_flag2;
                    var target_source = __init__ (__world__.constants).target_source;
                    var target_spawn_deposit = __init__ (__world__.constants).target_spawn_deposit;
                    var target_tower_fill = __init__ (__world__.constants).target_tower_fill;
                    var creep_wrappers = __init__ (__world__.creep_management.creep_wrappers);
                    var HoneyTrails = __init__ (__world__.empire.honey).HoneyTrails;
                    var StateCalc = __init__ (__world__.empire.states).StateCalc;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var room_spending_state_visual = __init__ (__world__.rooms.room_constants).room_spending_state_visual;
                    var RoomMind = __init__ (__world__.rooms.room_mind).RoomMind;
                    var movement = __init__ (__world__.utilities.movement);
                    var HiveMind = __class__ ('HiveMind', [object], {
                        get __init__ () {return __get__ (this, function (self, targets) {
                            self.targets = targets;
                            self.honey = HoneyTrails (self);
                            self.states = StateCalc (self);
                            self._my_rooms = null;
                            self._all_rooms = null;
                            self._room_to_mind = {};
                            self.has_polled_for_creeps = false;
                        });},
                        get find_my_rooms () {return __get__ (this, function (self) {
                            if (!('enemy_rooms' in Memory)) {
                                Memory.enemy_rooms = [];
                            }
                            if (!(self._my_rooms)) {
                                var my_rooms = [];
                                var all_rooms = [];
                                var sponsoring = {};
                                var __iterable0__ = Object.keys (Game.rooms);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var name = __iterable0__ [__index0__];
                                    var room_mind = RoomMind (self, Game.rooms [name]);
                                    all_rooms.append (room_mind);
                                    if (room_mind.my) {
                                        my_rooms.append (room_mind);
                                        if (!(room_mind.spawn) && room_mind.sponsor_name) {
                                            if (sponsoring [room_mind.sponsor_name]) {
                                                sponsoring [room_mind.sponsor_name].push (room_mind);
                                            }
                                            else {
                                                sponsoring [room_mind.sponsor_name] = [room_mind];
                                            }
                                        }
                                    }
                                    self._room_to_mind [name] = room_mind;
                                }
                                var __iterable0__ = Object.keys (sponsoring);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var sponsor_name = __iterable0__ [__index0__];
                                    var sponsor = self._room_to_mind [sponsor_name];
                                    if (sponsor) {
                                        var __iterable1__ = sponsoring [sponsor_name];
                                        for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                            var subsidiary = __iterable1__ [__index1__];
                                            sponsor.subsidiaries.push (subsidiary);
                                        }
                                    }
                                }
                                self._my_rooms = my_rooms;
                                self._all_rooms = _.sortBy (all_rooms, 'room_name');
                            }
                            return self._my_rooms;
                        });},
                        get find_visible_rooms () {return __get__ (this, function (self) {
                            if (!(self._all_rooms)) {
                                self.find_my_rooms ();
                            }
                            return self._all_rooms;
                        });},
                        get get_room () {return __get__ (this, function (self, room_name) {
                            if (self._all_rooms === null) {
                                self.find_visible_rooms ();
                            }
                            return self._room_to_mind [room_name];
                        }, 'get_room');},
                        get poll_remote_mining_flags () {return __get__ (this, function (self) {
                            var flag_list = flags.find_flags_global (REMOTE_MINE);
                            var room_to_flags = {};
                            var __iterable0__ = flag_list;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                var room = self.get_room (flag.pos.roomName);
                                if (room && room.my) {
                                    print ('[{}] Removing remote mining flag {}, now that room is owned.'.format (room.name, flag.name));
                                    flag.remove ();
                                }
                                else {
                                    if (!(flag.memory.active)) {
                                        continue;
                                    }
                                    if (('sponsor' in flag.memory)) {
                                        var sponsor = self.get_room (flag.memory.sponsor);
                                    }
                                    else {
                                        var sponsor = self.get_room (flag.name.py_split ('_') [0]);
                                    }
                                    if (!(sponsor)) {
                                        print ("[hive] Couldn't find sponsor for mining flag {}! (sponsor name set: {})".format (flag.name, flag.memory.sponsor));
                                        continue;
                                    }
                                    if (room_to_flags [sponsor.name]) {
                                        room_to_flags [sponsor.name].push (flag);
                                    }
                                    else {
                                        room_to_flags [sponsor.name] = [flag];
                                    }
                                }
                            }
                            var __iterable0__ = self.my_rooms;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var room = __iterable0__ [__index0__];
                                if ((room.name in room_to_flags)) {
                                    room._remote_mining_operations = room_to_flags [room.name];
                                }
                                else {
                                    room._remote_mining_operations = [];
                                }
                            }
                        });},
                        get get_closest_owned_room () {return __get__ (this, function (self, current_room_name) {
                            var current_room = self.get_room (current_room_name);
                            if (current_room && current_room.my) {
                                return current_room;
                            }
                            var mining_flags = flags.find_flags (current_room_name, REMOTE_MINE);
                            var __iterable0__ = mining_flags;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                if (('sponsor' in flag.memory)) {
                                    var sponsor = self.get_room (flag.memory.sponsor);
                                }
                                else {
                                    var sponsor = self.get_room (flag.name.py_split ('_') [0]);
                                }
                                if (sponsor) {
                                    return sponsor;
                                }
                            }
                            var current_pos = movement.parse_room_to_xy (current_room_name);
                            if (!(current_pos)) {
                                print ("[{}] Couldn't parse room name!".format (current_room_name));
                                return null;
                            }
                            var closest_squared_distance = Infinity;
                            var closest_room = null;
                            var __iterable0__ = self.my_rooms;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var room = __iterable0__ [__index0__];
                                var distance = movement.squared_distance (current_pos, room.position);
                                if (distance < closest_squared_distance) {
                                    var closest_squared_distance = distance;
                                    var closest_room = room;
                                }
                            }
                            if (!(closest_room)) {
                                print ('[{}] ERROR: could not find closest owned room!'.format (current_room_name));
                            }
                            return closest_room;
                        }, 'get_closest_owned_room');},
                        get poll_all_creeps () {return __get__ (this, function (self) {
                            var new_creep_lists = {};
                            var __iterable0__ = Object.keys (Game.creeps);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var name = __iterable0__ [__index0__];
                                var creep = Game.creeps [name];
                                var home = creep.memory.home;
                                if (!(creep.memory.home)) {
                                    var home = self.get_closest_owned_room (creep.pos.roomName);
                                    print ('[{}][{}] Giving a {} a new home.'.format (home.name, creep.name, creep.memory.role));
                                    creep.memory.home = home.name;
                                }
                                if ((home in new_creep_lists)) {
                                    new_creep_lists [home].append (creep);
                                }
                                else {
                                    new_creep_lists [home] = [creep];
                                }
                            }
                            var __iterable0__ = Object.keys (new_creep_lists);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var name = __iterable0__ [__index0__];
                                var room = self.get_room (name);
                                if (!(room)) {
                                    print ("[hive] One or more creeps has {} as its home, but {} isn't even visible!".format (name, name));
                                    if (!(Memory.meta.unowned_room_alerted)) {
                                        Game.notify ("[hive] One or more creeps has {} as its home, but {} isn't even visible!".format (name, name));
                                        Memory.meta.unowned_room_alerted = true;
                                    }
                                }
                                else if (!(room.my)) {
                                    print ("[hive] One or more creeps has {} as its home, but {} isn't owned!".format (name, name));
                                    if (!(Memory.meta.unowned_room_alerted)) {
                                        Game.notify ("[hive] One or more creeps has {} as its home, but {} isn't owned!".format (name, name));
                                        Memory.meta.unowned_room_alerted = true;
                                    }
                                }
                                else {
                                    room._creeps = new_creep_lists [name];
                                }
                            }
                            self.has_polled_for_creeps = true;
                        });},
                        get send_everything () {return __get__ (this, function (self, target_room) {
                            var target_room = target_room.name || target_room;
                            var __iterable0__ = self.my_rooms;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var room = __iterable0__ [__index0__];
                                if (room.name != target_room && !(room.minerals.has_no_terminal_or_storage ())) {
                                    delete room.minerals.fulfilling [RESOURCE_ENERGY];
                                    room.minerals.send_minerals (target_room, RESOURCE_ENERGY, 200 * 1000);
                                }
                            }
                        });},
                        get mineral_report () {return __get__ (this, function (self) {
                            var result = ['Hive Mineral Report:'];
                            var tally = {};
                            var __iterable0__ = self.my_rooms;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var room = __iterable0__ [__index0__];
                                if (room.minerals && !(room.minerals.has_no_terminal_or_storage ())) {
                                    result.append (room.minerals.mineral_report ());
                                    var __iterable1__ = _.pairs (room.minerals.get_total_room_resource_counts ());
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var __left0__ = __iterable1__ [__index1__];
                                        var mineral = __left0__ [0];
                                        var amount = __left0__ [1];
                                        if ((mineral in tally)) {
                                            tally [mineral] += amount;
                                        }
                                        else {
                                            tally [mineral] = amount;
                                        }
                                    }
                                }
                            }
                            result.push ('totals:\t{}'.format ('\t'.join (function () {
                                var __accu0__ = [];
                                var __iterable0__ = _.pairs (tally);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var __left0__ = __iterable0__ [__index0__];
                                    var mineral = __left0__ [0];
                                    var amount = __left0__ [1];
                                    __accu0__.append ('{} {}'.format (amount, mineral));
                                }
                                return __accu0__;
                            } ())));
                            return '\n'.join (result);
                        });},
                        get status () {return __get__ (this, function (self) {
                            var result = ['Hive Status Report:'];
                            var __iterable0__ = self.my_rooms;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var room = __iterable0__ [__index0__];
                                var room_result = [];
                                if (room.mem [rmem_key_currently_under_siege]) {
                                    room_result.push ('under attack');
                                }
                                if (room.mem.pause) {
                                    room_result.push ('paused');
                                }
                                if (room.mem [rmem_key_now_supporting]) {
                                    room_result.push ('supporting {}'.format (room.mem [rmem_key_now_supporting]));
                                }
                                if (room.mem [rmem_key_prepping_defenses]) {
                                    room_result.push ('prepping defenses');
                                }
                                room_result.push ('spending on {}.'.format (room_spending_state_visual [room.main_spending_expenditure ()]));
                                result.push ('{}: {}'.format (room.name, ', '.join (room_result)));
                            }
                            return '\n'.join (result);
                        });},
                        get sing () {return __get__ (this, function (self) {
                            if (!('_ly' in Memory)) {
                                Memory ['_ly'] = {};
                            }
                            var creeps_by_room = _.groupBy (Game.creeps, 'pos.roomName');
                            var __iterable0__ = Object.keys (creeps_by_room);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var room_name = __iterable0__ [__index0__];
                                var room = self.get_room (room_name);
                                if (room) {
                                    room.sing (creeps_by_room [room_name]);
                                }
                                else {
                                    print ('[hive] WARNING: No room found with name {}, which {} creeps were supposedly in!'.format (room_name, len (creeps_by_room [room])));
                                }
                            }
                            if (__mod__ (Game.time, 30) == 0) {
                                var __iterable0__ = Object.keys (Memory ['_ly']);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var name = __iterable0__ [__index0__];
                                    if (!(name in Game.rooms)) {
                                        delete Memory ['_ly'] [name];
                                    }
                                }
                            }
                        });},
                        get wrap_creep () {return __get__ (this, function (self, creep) {
                            var home = self.get_room (creep.memory.home);
                            if (home) {
                                return creep_wrappers.wrap_creep (self, self.targets, home, creep);
                            }
                            else {
                                var __except0__ = ValueError ('[hive]Invalid value to wrap_creep: {} with memory {}'.format (creep, JSON.stringify (creep.memory)));
                                __except0__.__cause__ = null;
                                throw __except0__;
                            }
                        });},
                        get toString () {return __get__ (this, function (self) {
                            return 'HiveMind[rooms: {}]'.format (JSON.stringify (function () {
                                var __accu0__ = [];
                                var __iterable0__ = self.my_rooms;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var room = __iterable0__ [__index0__];
                                    __accu0__.append (room.name);
                                }
                                return __accu0__;
                            } ()));
                        });}
                    });
                    Object.defineProperty (HiveMind, 'my_rooms', property.call (HiveMind, HiveMind.find_my_rooms));;
                    Object.defineProperty (HiveMind, 'visible_rooms', property.call (HiveMind, HiveMind.find_visible_rooms));;
                    __pragma__ ('<use>' +
                        'constants' +
                        'creep_management.creep_wrappers' +
                        'empire.honey' +
                        'empire.states' +
                        'jstools.screeps_constants' +
                        'position_management.flags' +
                        'rooms.room_constants' +
                        'rooms.room_mind' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.DEPOT = DEPOT;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.HiveMind = HiveMind;
                        __all__.HoneyTrails = HoneyTrails;
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.PYFIND_BUILDABLE_ROADS = PYFIND_BUILDABLE_ROADS;
                        __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
                        __all__.PYFIND_REPAIRABLE_ROADS = PYFIND_REPAIRABLE_ROADS;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.REROUTE = REROUTE;
                        __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
                        __all__.RESERVE_NOW = RESERVE_NOW;
                        __all__.RoomMind = RoomMind;
                        __all__.SCOUT = SCOUT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SK_USERNAME = SK_USERNAME;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.StateCalc = StateCalc;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__.creep_base_1500miner = creep_base_1500miner;
                        __all__.creep_base_3000miner = creep_base_3000miner;
                        __all__.creep_base_3h = creep_base_3h;
                        __all__.creep_base_4000miner = creep_base_4000miner;
                        __all__.creep_base_carry3000miner = creep_base_carry3000miner;
                        __all__.creep_base_claim_attack = creep_base_claim_attack;
                        __all__.creep_base_claiming = creep_base_claiming;
                        __all__.creep_base_defender = creep_base_defender;
                        __all__.creep_base_dismantler = creep_base_dismantler;
                        __all__.creep_base_full_move_dismantler = creep_base_full_move_dismantler;
                        __all__.creep_base_full_move_goader = creep_base_full_move_goader;
                        __all__.creep_base_full_move_healer = creep_base_full_move_healer;
                        __all__.creep_base_full_move_power_attack = creep_base_full_move_power_attack;
                        __all__.creep_base_full_upgrader = creep_base_full_upgrader;
                        __all__.creep_base_goader = creep_base_goader;
                        __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
                        __all__.creep_base_half_move_healer = creep_base_half_move_healer;
                        __all__.creep_base_hauler = creep_base_hauler;
                        __all__.creep_base_mammoth_miner = creep_base_mammoth_miner;
                        __all__.creep_base_power_attack = creep_base_power_attack;
                        __all__.creep_base_rampart_defense = creep_base_rampart_defense;
                        __all__.creep_base_ranged_offense = creep_base_ranged_offense;
                        __all__.creep_base_reserving = creep_base_reserving;
                        __all__.creep_base_scout = creep_base_scout;
                        __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
                        __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
                        __all__.creep_base_worker = creep_base_worker;
                        __all__.creep_wrappers = creep_wrappers;
                        __all__.default_roles = default_roles;
                        __all__.flags = flags;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.gmem_key_last_room_state_refresh = gmem_key_last_room_state_refresh;
                        __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
                        __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
                        __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.old_role_names = old_role_names;
                        __all__.recycle_time = recycle_time;
                        __all__.request_priority_economy = request_priority_economy;
                        __all__.request_priority_helping_party = request_priority_helping_party;
                        __all__.request_priority_imminent_threat_defense = request_priority_imminent_threat_defense;
                        __all__.request_priority_low = request_priority_low;
                        __all__.rmem_key_building_paused = rmem_key_building_paused;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.rmem_key_cache = rmem_key_cache;
                        __all__.rmem_key_carry_parts_by_role = rmem_key_carry_parts_by_role;
                        __all__.rmem_key_creeps_by_role = rmem_key_creeps_by_role;
                        __all__.rmem_key_creeps_by_role_and_replacement_time = rmem_key_creeps_by_role_and_replacement_time;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                        __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
                        __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
                        __all__.rmem_key_flag_for_testing_spawning_in_simulation = rmem_key_flag_for_testing_spawning_in_simulation;
                        __all__.rmem_key_focusing_home = rmem_key_focusing_home;
                        __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
                        __all__.rmem_key_metadata = rmem_key_metadata;
                        __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
                        __all__.rmem_key_now_supporting = rmem_key_now_supporting;
                        __all__.rmem_key_pause_all_room_operations = rmem_key_pause_all_room_operations;
                        __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
                        __all__.rmem_key_prepping_defenses = rmem_key_prepping_defenses;
                        __all__.rmem_key_remotes_explicitly_marked_under_attack = rmem_key_remotes_explicitly_marked_under_attack;
                        __all__.rmem_key_remotes_safe_when_under_siege = rmem_key_remotes_safe_when_under_siege;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.rmem_key_spawn_requests = rmem_key_spawn_requests;
                        __all__.rmem_key_sponsor = rmem_key_sponsor;
                        __all__.rmem_key_storage_use_enabled = rmem_key_storage_use_enabled;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
                        __all__.rmem_key_total_open_source_spaces = rmem_key_total_open_source_spaces;
                        __all__.rmem_key_upgrading_paused = rmem_key_upgrading_paused;
                        __all__.rmem_key_work_parts_by_role = rmem_key_work_parts_by_role;
                        __all__.role_bases = role_bases;
                        __all__.role_builder = role_builder;
                        __all__.role_cleanup = role_cleanup;
                        __all__.role_colonist = role_colonist;
                        __all__.role_defender = role_defender;
                        __all__.role_energy_grab = role_energy_grab;
                        __all__.role_hauler = role_hauler;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_miner = role_miner;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.role_mineral_miner = role_mineral_miner;
                        __all__.role_mineral_steal = role_mineral_steal;
                        __all__.role_power_attack = role_power_attack;
                        __all__.role_power_cleanup = role_power_cleanup;
                        __all__.role_ranged_offense = role_ranged_offense;
                        __all__.role_recycling = role_recycling;
                        __all__.role_remote_mining_reserve = role_remote_mining_reserve;
                        __all__.role_room_reserve = role_room_reserve;
                        __all__.role_scout = role_scout;
                        __all__.role_simple_claim = role_simple_claim;
                        __all__.role_simple_dismantle = role_simple_dismantle;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_spawn_fill_backup = role_spawn_fill_backup;
                        __all__.role_td_goad = role_td_goad;
                        __all__.role_td_healer = role_td_healer;
                        __all__.role_temporary_replacing = role_temporary_replacing;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.role_tower_fill_once = role_tower_fill_once;
                        __all__.role_upgrade_fill = role_upgrade_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.role_wall_defender = role_wall_defender;
                        __all__.room_spending_state_visual = room_spending_state_visual;
                        __all__.target_big_big_repair = target_big_big_repair;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_construction = target_construction;
                        __all__.target_destruction_site = target_destruction_site;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                        __all__.target_home_flag = target_home_flag;
                        __all__.target_rampart_defense = target_rampart_defense;
                        __all__.target_refill = target_refill;
                        __all__.target_repair = target_repair;
                        __all__.target_reserve_now = target_reserve_now;
                        __all__.target_single_flag = target_single_flag;
                        __all__.target_single_flag2 = target_single_flag2;
                        __all__.target_source = target_source;
                        __all__.target_spawn_deposit = target_spawn_deposit;
                        __all__.target_tower_fill = target_tower_fill;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'empire.honey', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var global_cache = __init__ (__world__.cache.global_cache);
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
                    var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
                    var mining_paths = __init__ (__world__.creep_management.mining_paths);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var hostile_utils = __init__ (__world__.utilities.hostile_utils);
                    var movement = __init__ (__world__.utilities.movement);
                    var dxdy_to_direction = __init__ (__world__.utilities.movement).dxdy_to_direction;
                    var _path_cached_data_key_metadata = 'm';
                    var _path_cached_data_key_full_path = 'full';
                    var _path_cached_data_key_room_order = 'o';
                    var _path_cached_data_key_length = 'l';
                    var pathfinder_path_to_room_to_path_obj = function (origin, input_path) {
                        var result_obj = {};
                        var list_of_rooms = [];
                        var last_room = null;
                        var current_path = null;
                        var __left0__ = [origin.x, origin.y];
                        var last_x = __left0__ [0];
                        var last_y = __left0__ [1];
                        var __left0__ = [null, null];
                        var reroute_end_dx = __left0__ [0];
                        var reroute_end_dy = __left0__ [1];
                        var __iterable0__ = input_path;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var pos = __iterable0__ [__index0__];
                            if (last_room != pos.roomName) {
                                if ((pos.roomName in result_obj)) {
                                    var msg = '[honey] WARNING: Visiting same room ({}) twice in path from {} to {}! This is not fully supported, please be advised!'.format (pos.roomName, origin, input_path [len (input_path) - 1]);
                                    console.log (msg);
                                    Game.notify (msg);
                                    var current_path = result_obj [pos.roomName];
                                    while (true) {
                                        var last_pos = current_path [len (current_path) - 1];
                                        var x_diff = last_pos.x - pos.x;
                                        var y_diff = last_pos.y - pos.y;
                                        if (x_diff < -(1)) {
                                            var dx = 1;
                                            if (y_diff < -(1)) {
                                                var dy = 1;
                                            }
                                            else if (y_diff > 1) {
                                                var dy = -(1);
                                            }
                                            else {
                                                var dy = 1;
                                            }
                                        }
                                        else if (x_diff > 1) {
                                            var dx = -(1);
                                            if (y_diff < -(1)) {
                                                var dy = 1;
                                            }
                                            else if (y_diff > 1) {
                                                var dy = -(1);
                                            }
                                            else {
                                                var dy = 0;
                                            }
                                        }
                                        else {
                                            var dx = 0;
                                            if (y_diff < -(1)) {
                                                var dy = 1;
                                            }
                                            else if (y_diff > 1) {
                                                var dy = -(1);
                                            }
                                            else {
                                                break;
                                            }
                                        }
                                        current_path.push ({'x': last_pos.x + dx, 'y': last_pos.y + dy, 'dx': dx, 'dy': dy, 'direction': dxdy_to_direction (dx, dy)});
                                    }
                                }
                                else {
                                    var current_path = [];
                                    result_obj [pos.roomName] = current_path;
                                    var last_room = pos.roomName;
                                    list_of_rooms.push (pos.roomName);
                                }
                            }
                            if (reroute_end_dx !== null) {
                                var dx = reroute_end_dx;
                                var dy = reroute_end_dy;
                                var __left0__ = [null, null];
                                var reroute_end_dx = __left0__ [0];
                                var reroute_end_dy = __left0__ [1];
                            }
                            else {
                                var dx = pos.x - last_x;
                                var dy = pos.y - last_y;
                                if (dx == -(49)) {
                                    var dx = 1;
                                }
                                else if (dx == 49) {
                                    var dx = -(1);
                                }
                                if (dy == -(49)) {
                                    var dy = 1;
                                }
                                else if (dy == 49) {
                                    var dy = -(1);
                                }
                                if (pos.endOfReroute) {
                                    var reroute_end_dx = dx;
                                    var reroute_end_dy = dy;
                                }
                            }
                            if (dx < -(1) || dx > 1) {
                                print ('[honey][pathfinder_to_regular_path] dx found from {} to {}: {}'.format (last_x, pos.x, dx));
                            }
                            if (dy < -(1) || dy > 1) {
                                print ('[honey][pathfinder_to_regular_path] dy found from {} to {}: {}'.format (last_y, pos.y, dy));
                            }
                            var direction = dxdy_to_direction (dx, dy);
                            if (direction === null) {
                                print ('[honey][pathfinder_to_regular_path] Unknown direction for pos: {},{}, last: {},{}'.format (pos.x, pos.y, last_x, last_y));
                                return null;
                            }
                            var last_x = pos.x;
                            var last_y = pos.y;
                            var item = {'x': pos.x, 'y': pos.y, 'dx': dx, 'dy': dy, 'direction': direction};
                            current_path.append (item);
                        }
                        var total_length = (len (input_path) - len (list_of_rooms)) + 1;
                        result_obj [_path_cached_data_key_metadata] = ','.join ([total_length].concat (list_of_rooms));
                        return result_obj;
                    };
                    var clear_serialized_cost_matrix = function (room_name) {
                        for (var i = 0; i < 10; i++) {
                            var key = '{}_cost_matrix_{}'.format (room_name, i);
                            if (global_cache.has (key)) {
                                global_cache.rem (key);
                            }
                        }
                    };
                    var get_global_cache_key = function (origin, destination, opts) {
                        if (opts) {
                            if (opts ['ignore_swamp']) {
                                return '_'.join (['path', origin.roomName, origin.x, origin.y, destination.roomName, destination.x, destination.y, 'swl']);
                            }
                            else if (opts ['paved_for']) {
                                return '_'.join (['path', origin.roomName, origin.x, origin.y, destination.roomName, destination.x, destination.y, global_cache_mining_roads_suffix]);
                            }
                        }
                        return '_'.join (['path', origin.roomName, origin.x, origin.y, destination.roomName, destination.x, destination.y]);
                    };
                    var HoneyTrails = __class__ ('HoneyTrails', [object], {
                        get __init__ () {return __get__ (this, function (self, hive) {
                            self.hive = hive;
                        }, '__init__');},
                        get mark_exit_tiles () {return __get__ (this, function (self, room_name, matrix, opts) {
                            var plain_cost = opts ['plain_cost'];
                            var __left0__ = movement.parse_room_to_xy (room_name);
                            var room_x = __left0__ [0];
                            var room_y = __left0__ [1];
                            var rrx = __mod__ ((room_x < 0 ? -(room_x) - 1 : room_x), 10);
                            var rry = __mod__ ((room_y < 0 ? -(room_y) - 1 : room_y), 10);
                            if (rrx == 0 || rry == 0) {
                                var __iterable0__ = [0, 49];
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var x = __iterable0__ [__index0__];
                                    for (var y = 0; y < 50; y++) {
                                        if (Game.map.getTerrainAt (x, y, room_name) != 'wall') {
                                            matrix.set (x, y, 1 * plain_cost);
                                        }
                                    }
                                }
                                var __iterable0__ = [0, 49];
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var y = __iterable0__ [__index0__];
                                    for (var x = 0; x < 50; x++) {
                                        if (Game.map.getTerrainAt (x, y, room_name) != 'wall') {
                                            matrix.set (x, y, 1 * plain_cost);
                                        }
                                    }
                                }
                            }
                            else {
                                var __iterable0__ = [0, 49];
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var x = __iterable0__ [__index0__];
                                    for (var y = 0; y < 50; y++) {
                                        if (Game.map.getTerrainAt (x, y, room_name) != 'wall') {
                                            matrix.set (x, y, 2 * plain_cost);
                                        }
                                    }
                                }
                                var __iterable0__ = [0, 49];
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var y = __iterable0__ [__index0__];
                                    for (var x = 0; x < 50; x++) {
                                        if (Game.map.getTerrainAt (x, y, room_name) != 'wall') {
                                            matrix.set (x, y, 2 * plain_cost);
                                        }
                                    }
                                }
                            }
                        }, 'mark_exit_tiles');},
                        get mark_flags () {return __get__ (this, function (self, room_name, matrix, opts) {
                            var __iterable0__ = flags.find_flags (room_name, SK_LAIR_SOURCE_NOTED);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                for (var x = flag.pos.x - 4; x < flag.pos.x + 5; x++) {
                                    for (var y = flag.pos.y - 4; y < flag.pos.y + 5; y++) {
                                        matrix.set (x, y, 255);
                                    }
                                }
                            }
                            var slightly_avoid = flags.find_flags (room_name, SLIGHTLY_AVOID).concat (flags.find_flags (room_name, UPGRADER_SPOT));
                            if (len (slightly_avoid)) {
                                var cost = 2 * opts ['plain_cost'];
                                var __iterable0__ = slightly_avoid;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var flag = __iterable0__ [__index0__];
                                    if (Game.map.getTerrainAt (flag.pos.x, flag.pos.y, room_name) != 'wall' && matrix.get (flag.pos.x, flag.pos.y) < cost) {
                                        matrix.set (flag.pos.x, flag.pos.y, cost);
                                    }
                                }
                            }
                        }, 'mark_flags');},
                        get set_max_avoid () {return __get__ (this, function (self, room_name, matrix, opts) {
                            if (opts ['max_avoid']) {
                                var plain_cost = opts ['plain_cost'];
                                if ((room_name in opts ['max_avoid'])) {
                                    print ('Setting max_avoid in room {}'.format (room_name));
                                    for (var x = 0; x < 49; x++) {
                                        for (var y = 0; y < 49; y++) {
                                            if (Game.map.getTerrainAt (x, y, room_name) != 'wall') {
                                                matrix.set (x, y, plain_cost * 20);
                                            }
                                        }
                                    }
                                    return true;
                                }
                                var __iterable0__ = _.pairs (Game.map.describeExits (room_name));
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var __left0__ = __iterable0__ [__index0__];
                                    var direction = __left0__ [0];
                                    var other_room = __left0__ [1];
                                    if ((other_room in opts ['max_avoid'])) {
                                        print ('Setting max_avoid on the {} of room {}'.format ({[TOP]: 'top', [BOTTOM]: 'bottom', [LEFT]: 'left', [RIGHT]: 'right'} [direction], room_name));
                                        if (direction == TOP) {
                                            for (var x = 0; x < 49; x++) {
                                                if (Game.map.getTerrainAt (x, 0, room_name) != 'wall') {
                                                    matrix.set (x, 0, 20 * plain_cost);
                                                }
                                            }
                                        }
                                        else if (direction == BOTTOM) {
                                            for (var x = 0; x < 49; x++) {
                                                if (Game.map.getTerrainAt (x, 49, room_name) != 'wall') {
                                                    matrix.set (x, 49, 20 * plain_cost);
                                                }
                                            }
                                        }
                                        else if (direction == LEFT) {
                                            for (var y = 0; y < 49; y++) {
                                                if (Game.map.getTerrainAt (0, y, room_name) != 'wall') {
                                                    matrix.set (0, y, 20 * plain_cost);
                                                }
                                            }
                                        }
                                        else if (direction == RIGHT) {
                                            for (var y = 0; y < 49; y++) {
                                                if (Game.map.getTerrainAt (49, y, room_name) != 'wall') {
                                                    matrix.set (49, y, 20 * plain_cost);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }, 'set_max_avoid');},
                        get generate_serialized_cost_matrix () {return __get__ (this, function (self, room_name) {
                            if (!(global_cache.has ('{}_cost_matrix_{}'.format (room_name, 1)))) {
                                self.get_generic_cost_matrix (room_name, {'roads': false});
                            }
                            if (!(global_cache.has ('{}_cost_matrix_{}'.format (room_name, 2)))) {
                                self.get_generic_cost_matrix (room_name, {'roads': true});
                            }
                        }, 'generate_serialized_cost_matrix');},
                        get get_generic_cost_matrix () {return __get__ (this, function (self, room_name, opts) {
                            var plain_cost = opts ['plain_cost'];
                            var swamp_cost = opts ['swamp_cost'];
                            var serialization_key = '{}_cost_matrix_{}'.format (room_name, plain_cost);
                            var serialized = global_cache.get (serialization_key);
                            if (serialized) {
                                var cost_matrix = PathFinder.CostMatrix.deserialize (JSON.parse (serialized));
                                self.set_max_avoid (room_name, cost_matrix, opts);
                                return cost_matrix;
                            }
                            var room = self.hive.get_room (room_name);
                            if (!(room)) {
                                return null;
                            }
                            var wall_at = function (x, y) {
                                return Game.map.getTerrainAt (x, y, room_name) == 'wall';
                            };
                            var increase_by = function (x, y, added) {
                                var existing = cost_matrix.get (x, y);
                                if (existing == 0) {
                                    var terrain = Game.map.getTerrainAt (x, y, room_name);
                                    if (terrain [0] === 'p') {
                                        var existing = plain_cost;
                                    }
                                    else if (terrain [0] === 's') {
                                        var existing = swamp_cost;
                                    }
                                    else {
                                        return ;
                                    }
                                }
                                cost_matrix.set (x, y, existing + added);
                            };
                            if (room.my) {
                                var spawn_fill_wait_flags = flags.find_flags (room, SPAWN_FILL_WAIT);
                                if (len (spawn_fill_wait_flags)) {
                                    var avoid_extensions = false;
                                }
                                else {
                                    var avoid_extensions = true;
                                }
                            }
                            else {
                                var avoid_extensions = false;
                                var spawn_fill_wait_flags = [];
                            }
                            if (room.my) {
                                var upgrader_wait_flags = flags.find_flags (room, UPGRADER_SPOT);
                                if (len (upgrader_wait_flags)) {
                                    var avoid_controller = false;
                                }
                                else {
                                    var avoid_controller = true;
                                }
                            }
                            else {
                                var avoid_controller = false;
                                var upgrader_wait_flags = [];
                            }
                            var cost_matrix = new PathFinder.CostMatrix ();
                            self.mark_exit_tiles (room_name, cost_matrix, opts);
                            self.mark_flags (room_name, cost_matrix, opts);
                            var set_matrix = function (stype, pos, my) {
                                if (stype == STRUCTURE_ROAD || stype == STRUCTURE_RAMPART && my || stype == STRUCTURE_CONTAINER) {
                                    if (stype == STRUCTURE_ROAD) {
                                        var existing = cost_matrix.get (pos.x, pos.y);
                                        if (existing < 255 && !(wall_at (pos.x, pos.y))) {
                                            if (existing != 0 && existing > plain_cost) {
                                                cost_matrix.set (pos.x, pos.y, existing - 2);
                                            }
                                            else {
                                                cost_matrix.set (pos.x, pos.y, 1);
                                            }
                                        }
                                    }
                                    return ;
                                }
                                cost_matrix.set (pos.x, pos.y, 255);
                                if (my) {
                                    if (avoid_extensions && (stype == STRUCTURE_SPAWN || stype == STRUCTURE_EXTENSION)) {
                                        for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                            for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                increase_by (x, y, 9 * plain_cost);
                                            }
                                        }
                                    }
                                    else if (stype == STRUCTURE_STORAGE || stype == STRUCTURE_LINK) {
                                        for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                            for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                increase_by (x, y, 6 * plain_cost);
                                            }
                                        }
                                    }
                                    else if (avoid_controller && stype == STRUCTURE_CONTROLLER) {
                                        for (var x = pos.x - 3; x < pos.x + 4; x++) {
                                            for (var y = pos.y - 3; y < pos.y + 4; y++) {
                                                increase_by (x, y, 4 * plain_cost);
                                            }
                                        }
                                        for (var x = pos.x - 2; x < pos.x + 3; x++) {
                                            for (var y = pos.y - 2; y < pos.y + 3; y++) {
                                                increase_by (x, y, 2 * plain_cost);
                                            }
                                        }
                                        for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                            for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                increase_by (x, y, 13 * plain_cost);
                                            }
                                        }
                                    }
                                    else if (stype == '--source') {
                                        for (var x = pos.x - 3; x < pos.x + 4; x++) {
                                            for (var y = pos.y - 3; y < pos.y + 4; y++) {
                                                increase_by (x, y, 4 * plain_cost);
                                            }
                                        }
                                        for (var x = pos.x - 2; x < pos.x + 3; x++) {
                                            for (var y = pos.y - 2; y < pos.y + 3; y++) {
                                                increase_by (x, y, 2 * plain_cost);
                                            }
                                        }
                                        for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                            for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                increase_by (x, y, 11 * plain_cost);
                                            }
                                        }
                                    }
                                    else if (stype == '--linked-source') {
                                        for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                            for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                increase_by (x, y, 10 * plain_cost);
                                            }
                                        }
                                    }
                                }
                                cost_matrix.set (pos.x, pos.y, 255);
                            };
                            var __iterable0__ = room.find (FIND_STRUCTURES);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var struct = __iterable0__ [__index0__];
                                set_matrix (struct.structureType, struct.pos, struct.my || !(struct.owner));
                            }
                            var __iterable0__ = room.find (FIND_CONSTRUCTION_SITES);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var site = __iterable0__ [__index0__];
                                set_matrix (site.structureType, site.pos, site.my);
                            }
                            var __iterable0__ = flags.find_by_main_with_sub (room, flags.MAIN_BUILD);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var flag = __left0__ [0];
                                var stype = __left0__ [1];
                                set_matrix (flags.flag_sub_to_structure_type [stype], flag.pos, true);
                            }
                            var __iterable0__ = room.find (FIND_SOURCES);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var source = __iterable0__ [__index0__];
                                if (room.my && room.mining.is_mine_linked (source)) {
                                    set_matrix ('--linked-source', source.pos, true);
                                }
                                else {
                                    set_matrix ('--source', source.pos, true);
                                }
                            }
                            var __iterable0__ = spawn_fill_wait_flags;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                cost_matrix.set (flag.pos.x, flag.pos.y, 255);
                            }
                            var __iterable0__ = upgrader_wait_flags;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                cost_matrix.set (flag.pos.x, flag.pos.y, 255);
                            }
                            if (room.my && room.room.storage && room.links.main_link) {
                                var ml = room.links.main_link;
                                var storage = room.room.storage;
                                if (ml.pos.x == storage.pos.x && abs (ml.pos.y - storage.pos.y) == 2 && movement.is_block_empty (room, ml.pos.x, (ml.pos.y + storage.pos.y) / 2)) {
                                    cost_matrix.set (ml.pos.x, (ml.pos.y + storage.pos.y) / 2, 255);
                                }
                                else if (ml.pos.y == storage.pos.y && abs (ml.pos.x - storage.pos.x) == 2 && movement.is_block_empty (room, (ml.pos.x + storage.pos.x) / 2, ml.pos.y)) {
                                    cost_matrix.set ((ml.pos.x + storage.pos.x) / 2, ml.pos.y, 255);
                                }
                                else {
                                    for (var x = ml.pos.x - 1; x < ml.pos.x + 2; x++) {
                                        for (var y = ml.pos.y - 1; y < ml.pos.y + 2; y++) {
                                            if (abs (storage.pos.x - x) <= 1 && abs (storage.pos.y - y) <= 1) {
                                                cost_matrix.set (x, y, 255);
                                            }
                                        }
                                    }
                                }
                            }
                            var serialized = JSON.stringify (cost_matrix.serialize ());
                            var cache_for = (room.my ? 100 : 10000);
                            global_cache.set (serialization_key, serialized, cache_for);
                            self.set_max_avoid (room_name, cost_matrix, opts);
                            return cost_matrix;
                        }, 'get_generic_cost_matrix');},
                        get _new_cost_matrix () {return __get__ (this, function (self, room_name, origin, destination, opts) {
                            var paved_for = opts ['paved_for'];
                            if (hostile_utils.enemy_room (room_name)) {
                                if (room_name != origin.roomName && room_name != destination.roomName) {
                                    return false;
                                }
                                else {
                                    print ('[honey] Warning: path {}-{} ends up in an enemy room ({})!'.format (origin, destination, room_name));
                                }
                            }
                            var if_roads_multiplier = opts ['plain_cost'];
                            var plain_cost = opts ['plain_cost'];
                            var swamp_cost = opts ['swamp_cost'];
                            var room = self.hive.get_room (room_name);
                            if (room_name != origin.roomName && room_name != destination.roomName && !(paved_for) || !(room)) {
                                if (paved_for) {
                                    var serialized = global_cache.get ('{}_cost_matrix_{}'.format (room_name, if_roads_multiplier));
                                    if (serialized) {
                                        var matrix = PathFinder.CostMatrix.deserialize (JSON.parse (serialized));
                                        self.set_max_avoid (room_name, matrix, opts);
                                        mining_paths.set_decreasing_cost_matrix_costs (room_name, paved_for, matrix, opts ['plain_cost'], opts ['swamp_cost'], 3);
                                    }
                                }
                                else {
                                    var matrix = self.get_generic_cost_matrix (room_name, opts);
                                    if (matrix) {
                                        return matrix;
                                    }
                                }
                                var matrix = new PathFinder.CostMatrix ();
                                self.mark_exit_tiles (room_name, matrix, opts);
                                self.mark_flags (room_name, matrix, opts);
                                self.set_max_avoid (room_name, matrix, opts);
                                return matrix;
                            }
                            if (room.my) {
                                var spawn_fill_wait_flags = flags.find_flags (room, SPAWN_FILL_WAIT);
                                if (len (spawn_fill_wait_flags)) {
                                    var avoid_extensions = false;
                                }
                                else {
                                    var avoid_extensions = true;
                                    if (destination.roomName == room_name) {
                                        var __iterable0__ = room.look_at (LOOK_STRUCTURES, destination);
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var s = __iterable0__ [__index0__];
                                            if (s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_EXTENSION) {
                                                var avoid_extensions = false;
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                var avoid_extensions = false;
                                var spawn_fill_wait_flags = [];
                            }
                            if (room.my) {
                                var upgrader_wait_flags = flags.find_flags (room, UPGRADER_SPOT);
                                if (len (upgrader_wait_flags)) {
                                    var avoid_controller = false;
                                }
                                else {
                                    var avoid_controller = true;
                                }
                            }
                            else {
                                var avoid_controller = false;
                                var upgrader_wait_flags = [];
                            }
                            var cost_matrix = new PathFinder.CostMatrix ();
                            self.mark_exit_tiles (room_name, cost_matrix, opts);
                            self.mark_flags (room_name, cost_matrix, opts);
                            if (self.set_max_avoid (room_name, cost_matrix, opts)) {
                                return cost_matrix;
                            }
                            var increase_by = function (x, y, added) {
                                var existing = cost_matrix.get (x, y);
                                if (existing == 0) {
                                    var terrain = Game.map.getTerrainAt (x, y, room_name);
                                    if (terrain [0] === 'p') {
                                        var existing = plain_cost;
                                    }
                                    else if (terrain [0] === 's') {
                                        var existing = swamp_cost;
                                    }
                                    else {
                                        return ;
                                    }
                                }
                                cost_matrix.set (x, y, existing + added);
                            };
                            var set_matrix = function (stype, pos, planned, my) {
                                if (stype == STRUCTURE_ROAD || stype == STRUCTURE_RAMPART && my || stype == STRUCTURE_CONTAINER) {
                                    if (stype == STRUCTURE_ROAD) {
                                        if (paved_for && !(planned)) {
                                            var existing = cost_matrix.get (pos.x, pos.y);
                                            if (existing == 0) {
                                                var terrain = Game.map.getTerrainAt (pos.x, pos.y, room_name);
                                                if (terrain [0] === 'p') {
                                                    var existing = plain_cost;
                                                }
                                                else if (terrain [0] === 's') {
                                                    var existing = swamp_cost;
                                                }
                                                else {
                                                    return ;
                                                }
                                            }
                                            if ((1 < existing && existing < 255)) {
                                                cost_matrix.set (pos.x, pos.y, existing - 1);
                                            }
                                        }
                                        else {
                                            var existing = cost_matrix.get (pos.x, pos.y);
                                            if (existing != 0 && existing > plain_cost) {
                                                cost_matrix.set (pos.x, pos.y, existing - 2);
                                            }
                                            else {
                                                cost_matrix.set (pos.x, pos.y, 1);
                                            }
                                        }
                                    }
                                    return ;
                                }
                                if (pos.x == destination.x && pos.y == destination.y) {
                                    return ;
                                }
                                if (pos.x == origin.x && pos.y == origin.y) {
                                    return ;
                                }
                                cost_matrix.set (pos.x, pos.y, 255);
                                if (abs (pos.x - origin.x) <= 1 && abs (pos.y - origin.y) <= 1) {
                                    return ;
                                }
                                if (abs (pos.x - destination.x) <= 1 && abs (pos.y - destination.y) <= 1) {
                                    return ;
                                }
                                if (my) {
                                    if (avoid_extensions && (stype == STRUCTURE_SPAWN || stype == STRUCTURE_EXTENSION)) {
                                        for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                            for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                increase_by (x, y, 9 * plain_cost);
                                            }
                                        }
                                    }
                                    else if (stype == STRUCTURE_STORAGE || stype == STRUCTURE_LINK) {
                                        for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                            for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                increase_by (x, y, 6 * plain_cost);
                                            }
                                        }
                                    }
                                    else if (avoid_controller && stype == STRUCTURE_CONTROLLER) {
                                        for (var x = pos.x - 3; x < pos.x + 4; x++) {
                                            for (var y = pos.y - 3; y < pos.y + 4; y++) {
                                                increase_by (x, y, 4 * plain_cost);
                                            }
                                        }
                                        for (var x = pos.x - 2; x < pos.x + 3; x++) {
                                            for (var y = pos.y - 2; y < pos.y + 3; y++) {
                                                increase_by (x, y, 2 * plain_cost);
                                            }
                                        }
                                        for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                            for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                increase_by (x, y, 13 * plain_cost);
                                            }
                                        }
                                    }
                                    else if (stype == '--source') {
                                        if (paved_for) {
                                            if (room.my) {
                                                for (var x = pos.x - 2; x < pos.x + 3; x++) {
                                                    for (var y = pos.y - 2; y < pos.y + 3; y++) {
                                                        increase_by (x, y, 3 * plain_cost);
                                                    }
                                                }
                                                for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                                    for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                        increase_by (x, y, 11 * plain_cost);
                                                    }
                                                }
                                            }
                                            else {
                                                for (var x = pos.x - 3; x < pos.x + 4; x++) {
                                                    for (var y = pos.y - 3; y < pos.y + 4; y++) {
                                                        increase_by (x, y, 6 * plain_cost);
                                                    }
                                                }
                                                for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                                    for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                        increase_by (x, y, 6 * plain_cost);
                                                    }
                                                }
                                            }
                                        }
                                        else {
                                            for (var x = pos.x - 3; x < pos.x + 4; x++) {
                                                for (var y = pos.y - 3; y < pos.y + 4; y++) {
                                                    increase_by (x, y, 4 * plain_cost);
                                                }
                                            }
                                            for (var x = pos.x - 2; x < pos.x + 3; x++) {
                                                for (var y = pos.y - 2; y < pos.y + 3; y++) {
                                                    increase_by (x, y, 2 * plain_cost);
                                                }
                                            }
                                            for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                                for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                    increase_by (x, y, 11 * plain_cost);
                                                }
                                            }
                                        }
                                    }
                                    else if (stype == '--linked-source') {
                                        for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                            for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                                increase_by (x, y, 10 * plain_cost);
                                            }
                                        }
                                    }
                                }
                                cost_matrix.set (pos.x, pos.y, 255);
                            };
                            var __iterable0__ = room.find (FIND_STRUCTURES);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var struct = __iterable0__ [__index0__];
                                if (struct.structureType != STRUCTURE_CONTROLLER || struct.my) {
                                    set_matrix (struct.structureType, struct.pos, false, struct.my || !(struct.owner));
                                }
                            }
                            var __iterable0__ = room.find (FIND_CONSTRUCTION_SITES);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var site = __iterable0__ [__index0__];
                                set_matrix (site.structureType, site.pos, true, site.my);
                            }
                            var __iterable0__ = flags.find_by_main_with_sub (room, flags.MAIN_BUILD);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var flag = __left0__ [0];
                                var stype = __left0__ [1];
                                set_matrix (flags.flag_sub_to_structure_type [stype], flag.pos, true, true);
                            }
                            var __iterable0__ = room.find (FIND_SOURCES);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var source = __iterable0__ [__index0__];
                                if (room.my && room.mining.is_mine_linked (source)) {
                                    set_matrix ('--linked-source', source.pos, false, true);
                                }
                                else {
                                    set_matrix ('--source', source.pos, false, true);
                                }
                            }
                            var __iterable0__ = spawn_fill_wait_flags;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                cost_matrix.set (flag.pos.x, flag.pos.y, 255);
                            }
                            var __iterable0__ = upgrader_wait_flags;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                cost_matrix.set (flag.pos.x, flag.pos.y, 255);
                            }
                            if (room.my && room.room.storage && room.links.main_link) {
                                var ml = room.links.main_link;
                                var storage = room.room.storage;
                                if (ml.pos.x == storage.pos.x && abs (ml.pos.y - storage.pos.y) == 2 && movement.is_block_empty (room, ml.pos.x, (ml.pos.y + storage.pos.y) / 2)) {
                                    cost_matrix.set (ml.pos.x, (ml.pos.y + storage.pos.y) / 2, 255);
                                }
                                else if (ml.pos.y == storage.pos.y && abs (ml.pos.x - storage.pos.x) == 2 && movement.is_block_empty (room, (ml.pos.x + storage.pos.x) / 2, ml.pos.y)) {
                                    cost_matrix.set ((ml.pos.x + storage.pos.x) / 2, ml.pos.y, 255);
                                }
                                else {
                                    for (var x = ml.pos.x - 1; x < ml.pos.x + 2; x++) {
                                        for (var y = ml.pos.y - 1; y < ml.pos.y + 2; y++) {
                                            if (abs (storage.pos.x - x) <= 1 && abs (storage.pos.y - y) <= 1) {
                                                cost_matrix.set (x, y, 255);
                                            }
                                        }
                                    }
                                }
                            }
                            if (paved_for) {
                                mining_paths.set_decreasing_cost_matrix_costs (room_name, paved_for, cost_matrix, plain_cost, swamp_cost, 2);
                            }
                            return cost_matrix;
                        }, '_new_cost_matrix');},
                        get _get_callback () {return __get__ (this, function (self, origin, destination, opts) {
                            return (function __lambda__ (room_name) {
                                return self._new_cost_matrix (room_name, origin, destination, opts);
                            });
                        }, '_get_callback');},
                        get get_default_max_ops () {return __get__ (this, function (self, origin, destination, opts) {
                            var linear_distance = movement.chebyshev_distance_room_pos (origin, destination);
                            var ops = linear_distance * 200;
                            if (opts ['paved_for']) {
                                ops *= 5;
                            }
                            else if (!('use_roads' in opts) || opts ['use_roads']) {
                                ops *= 2;
                            }
                            return ops;
                        }, 'get_default_max_ops');},
                        get _get_raw_path () {return __get__ (this, function (self, origin, destination, opts) {
                            if (typeof opts == 'undefined' || (opts != null && opts .hasOwnProperty ("__kwargtrans__"))) {;
                                var opts = null;
                            };
                            if (origin.pos) {
                                var origin = origin.pos;
                            }
                            if (destination.pos) {
                                var destination = destination.pos;
                            }
                            if (opts) {
                                var roads_better = (('use_roads' in opts) ? opts ['use_roads'] : true);
                                var ignore_swamp = (('ignore_swamp' in opts) ? opts ['ignore_swamp'] : false);
                                var pf_range = (('range' in opts) ? opts ['range'] : 1);
                                var paved_for = (('paved_for' in opts) ? opts ['paved_for'] : null);
                                var max_ops = (('max_ops' in opts) ? opts ['max_ops'] : self.get_default_max_ops (origin, destination, opts));
                                var max_rooms = (('max_rooms' in opts) ? opts ['max_rooms'] : 16);
                                var max_avoid = (('avoid_rooms' in opts) ? opts ['avoid_rooms'] : null);
                            }
                            else {
                                var roads_better = true;
                                var ignore_swamp = false;
                                var pf_range = 1;
                                var max_rooms = 16;
                                var paved_for = null;
                                var max_ops = self.get_default_max_ops (origin, destination, {'use_roads': roads_better});
                                var max_avoid = null;
                            }
                            if (('reroute' in Game.flags) && ('reroute_destination' in Game.flags)) {
                                var reroute_start = Game.flags ['reroute'];
                                var reroute_destination = Game.flags ['reroute_destination'];
                                if (movement.chebyshev_distance_room_pos (origin, reroute_start) + movement.chebyshev_distance_room_pos (reroute_destination, destination) < movement.chebyshev_distance_room_pos (origin, destination)) {
                                    var path1 = self._get_raw_path (origin, reroute_start);
                                    if (!(len (path1)) || path1 [len (path1) - 1].isNearTo (reroute_start.pos) && !(path1 [len (path1) - 1].isEqualTo (reroute_start.pos))) {
                                        var pos = new RoomPosition (reroute_start.pos.x, reroute_start.pos.y, reroute_start.pos.roomName);
                                        pos.endOfReroute = true;
                                        path1.push (pos);
                                    }
                                    var path2 = self._get_raw_path (reroute_destination, destination);
                                    return path1.concat (path2);
                                }
                            }
                            if (paved_for) {
                                var plain_cost = 5;
                                var swamp_cost = 10;
                            }
                            else if (ignore_swamp) {
                                var plain_cost = 1;
                                var swamp_cost = 1;
                            }
                            else if (roads_better) {
                                var plain_cost = 2;
                                var swamp_cost = 10;
                            }
                            else {
                                var plain_cost = 1;
                                var swamp_cost = 5;
                            }
                            var result = PathFinder.search (origin, {'pos': destination, 'range': pf_range}, {'plainCost': plain_cost, 'swampCost': swamp_cost, 'roomCallback': self._get_callback (origin, destination, {'roads': roads_better, 'paved_for': paved_for, 'max_avoid': max_avoid, 'plain_cost': plain_cost, 'swamp_cost': swamp_cost}), 'maxRooms': max_rooms, 'maxOps': max_ops});
                            print ('[honey] Calculated new path from {} to {} in {} ops.'.format (origin, destination, result.ops));
                            var path = result.path;
                            if (result.incomplete) {
                                print ('[honey] WARNING: Calculated incomplete path. Chebyshev distance: {}. Path distance found: {}. Ops used: {}. Max ops: {}. Max rooms: {}.'.format (movement.chebyshev_distance_room_pos (origin, destination), len (result.path), result.ops, max_ops, max_rooms));
                                if (roads_better) {
                                    print ('[honey] Trying recalculation without preferring roads.');
                                    return self._get_raw_path (origin, destination, _.create (opts, {'use_roads': false}));
                                }
                                if (len (result.path) > 15) {
                                    var path_start = path.slice (0, -(10));
                                    var midpoint = path_start [len (path_start) - 1];
                                    print ('[honey] OK, trying to build the rest of the path from {} to {}, starting at {}'.format (origin, destination, midpoint));
                                    var second_path_result = PathFinder.search (midpoint, {'pos': destination, 'range': pf_range}, {'plainCost': plain_cost, 'swampCost': swamp_cost, 'roomCallback': self._get_callback (origin, destination, {'roads': roads_better, 'paved_for': paved_for, 'max_avoid': max_avoid, 'plain_cost': plain_cost, 'swamp_cost': swamp_cost}), 'maxRooms': max_rooms, 'maxOps': max_ops});
                                    if (second_path_result.incomplete) {
                                        print ('[honey] Second path result incomplete, not appending.');
                                    }
                                    else {
                                        print ('[honey] Second path result complete! Concatenating paths!');
                                        var path = path_start.concat (second_path_result.path);
                                    }
                                }
                            }
                            if (paved_for) {
                                if (paved_for.name) {
                                    var mine_name = paved_for.name;
                                    var spawn_id = 'none';
                                }
                                else {
                                    var mine_name = paved_for [0].name;
                                    var spawn_id = paved_for [1].id;
                                }
                                print ('[honey] Registering new paved path for mine {}, spawn {}.'.format (mine_name, spawn_id));
                                mining_paths.register_new_mining_path (paved_for, path);
                            }
                            return path;
                        }, '_get_raw_path');},
                        get get_serialized_path_obj () {return __get__ (this, function (self, origin, destination, opts) {
                            if (typeof opts == 'undefined' || (opts != null && opts .hasOwnProperty ("__kwargtrans__"))) {;
                                var opts = null;
                            };
                            if (origin.pos) {
                                var origin = origin.pos;
                            }
                            if (destination.pos) {
                                var destination = destination.pos;
                            }
                            if (opts && ('keep_for' in opts)) {
                                var keep_for = opts ['keep_for'];
                            }
                            else {
                                var keep_for = 0;
                            }
                            var cache_key = get_global_cache_key (origin, destination, opts);
                            var serialized_path_obj = global_cache.get (cache_key);
                            if (serialized_path_obj !== null) {
                                return serialized_path_obj;
                            }
                            var path = self._get_raw_path (origin, destination, opts);
                            var room_to_path_obj = pathfinder_path_to_room_to_path_obj (origin, path);
                            if (room_to_path_obj === null) {
                                return null;
                            }
                            if (!(keep_for > 0)) {
                                var all_viewed = true;
                                var all_owned = true;
                                var __iterable0__ = path;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var pos = __iterable0__ [__index0__];
                                    var room = self.hive.get_room (pos.roomName);
                                    if (!(room)) {
                                        var all_owned = false;
                                        var all_viewed = false;
                                        break;
                                    }
                                    if (!(room.my)) {
                                        var all_owned = false;
                                    }
                                }
                                if (all_viewed) {
                                    var keep_for = 80 * 1000;
                                    if (all_owned) {
                                        keep_for *= 2;
                                    }
                                }
                                else if (len (Object.keys (room_to_path_obj)) < 3) {
                                    var keep_for = 4 * 1000;
                                }
                                else if (len (Object.keys (room_to_path_obj)) < 4) {
                                    var keep_for = 10 * 1000;
                                }
                                else {
                                    var keep_for = 40 * 1000;
                                }
                            }
                            var serialized_path_obj = {};
                            var __iterable0__ = Object.keys (room_to_path_obj);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var room_name = __iterable0__ [__index0__];
                                if (room_name == _path_cached_data_key_metadata) {
                                    serialized_path_obj [room_name] = room_to_path_obj [room_name];
                                }
                                else {
                                    serialized_path_obj [room_name] = Room.serializePath (room_to_path_obj [room_name]);
                                }
                            }
                            global_cache.set (cache_key, serialized_path_obj, keep_for);
                            return serialized_path_obj;
                        }, 'get_serialized_path_obj');},
                        get completely_repath_and_get_raw_path () {return __get__ (this, function (self, origin, destination, opts) {
                            if (origin.pos) {
                                var origin = origin.pos;
                            }
                            if (destination.pos) {
                                var destination = destination.pos;
                            }
                            if (('keep_for' in opts)) {
                                var keep_for = opts ['keep_for'];
                            }
                            else {
                                var __except0__ = ValueError ('force_complete_repath_and_get_raw_path requires an options object with a keep_for property');
                                __except0__.__cause__ = null;
                                throw __except0__;
                            }
                            var cache_key = get_global_cache_key (origin, destination, opts);
                            var path = self._get_raw_path (origin, destination, opts);
                            var room_to_path_obj = pathfinder_path_to_room_to_path_obj (origin, path);
                            if (room_to_path_obj !== null) {
                                var serialized_path_obj = {};
                                var __iterable0__ = Object.keys (room_to_path_obj);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var room_name = __iterable0__ [__index0__];
                                    if (room_name == _path_cached_data_key_metadata) {
                                        serialized_path_obj [room_name] = room_to_path_obj [room_name];
                                    }
                                    else {
                                        serialized_path_obj [room_name] = Room.serializePath (room_to_path_obj [room_name]);
                                    }
                                }
                                global_cache.set (cache_key, serialized_path_obj, keep_for);
                            }
                            return path;
                        }, 'completely_repath_and_get_raw_path');},
                        get find_serialized_path () {return __get__ (this, function (self, origin, destination, opts) {
                            if (opts && ('current_room' in opts)) {
                                var current_room = opts ['current_room'];
                                if (current_room) {
                                    var current_room = current_room.name || current_room;
                                }
                                else {
                                    var __except0__ = ValueError ('find_serialized_path requires a current_room argument.');
                                    __except0__.__cause__ = null;
                                    throw __except0__;
                                }
                            }
                            else {
                                var __except0__ = ValueError ('find_serialized_path requires a current_room argument.');
                                __except0__.__cause__ = null;
                                throw __except0__;
                            }
                            var serialized_path_obj = self.get_serialized_path_obj (origin, destination, opts);
                            if ((current_room in serialized_path_obj)) {
                                return serialized_path_obj [current_room];
                            }
                            else {
                                return '';
                            }
                        }, 'find_serialized_path');},
                        get find_path () {return __get__ (this, function (self, origin, destination, opts) {
                            if (opts && ('current_room' in opts)) {
                                var current_room = opts ['current_room'];
                                if (current_room) {
                                    var current_room = current_room.name || current_room;
                                }
                                else {
                                    var __except0__ = ValueError ('find_path requires a current_room argument.');
                                    __except0__.__cause__ = null;
                                    throw __except0__;
                                }
                            }
                            else {
                                var __except0__ = ValueError ('find_path requires a current_room argument.');
                                __except0__.__cause__ = null;
                                throw __except0__;
                            }
                            var serialized_path_obj = self.get_serialized_path_obj (origin, destination, opts);
                            if (serialized_path_obj === null || !(current_room in serialized_path_obj)) {
                                return [];
                            }
                            try {
                                var path = Room.deserializePath (serialized_path_obj [current_room]);
                            }
                            catch (__except0__) {
                                print ('[honey] Serialized path from {} to {} with current-room {} was invalid.'.format (origin, destination, current_room));
                                self.clear_cached_path (origin, destination, opts);
                                var new_path_obj = self.get_serialized_path_obj (origin, destination, opts);
                                if ((current_room in new_path_obj)) {
                                    var path = Room.deserializePath (new_path_obj [current_room]);
                                }
                                else {
                                    return [];
                                }
                            }
                            return path;
                        }, 'find_path');},
                        get clear_cached_path () {return __get__ (this, function (self, origin, destination, opts) {
                            if (typeof opts == 'undefined' || (opts != null && opts .hasOwnProperty ("__kwargtrans__"))) {;
                                var opts = null;
                            };
                            if (opts) {
                                var ignore_swamp = (('ignore_swamp' in opts) ? opts ['ignore_swamp'] : false);
                            }
                            else {
                                var ignore_swamp = false;
                            }
                            if (origin.pos) {
                                var origin = origin.pos;
                            }
                            if (destination.pos) {
                                var destination = destination.pos;
                            }
                            if (ignore_swamp) {
                                var key = 'path_{}_{}_{}_{}_{}_{}_swl'.format (origin.roomName, origin.x, origin.y, destination.roomName, destination.x, destination.y);
                            }
                            else {
                                var key = 'path_{}_{}_{}_{}_{}_{}'.format (origin.roomName, origin.x, origin.y, destination.roomName, destination.x, destination.y);
                            }
                            global_cache.rem (key);
                        }, 'clear_cached_path');},
                        get list_of_room_positions_in_path () {return __get__ (this, function (self, origin, destination, opts) {
                            if (typeof opts == 'undefined' || (opts != null && opts .hasOwnProperty ("__kwargtrans__"))) {;
                                var opts = null;
                            };
                            if (origin.pos) {
                                var origin = origin.pos;
                            }
                            if (destination.pos) {
                                var destination = destination.pos;
                            }
                            var path_obj = self.get_serialized_path_obj (origin, destination, opts);
                            var final_list = [];
                            if ((_path_cached_data_key_room_order in path_obj)) {
                                var list_of_names = path_obj [_path_cached_data_key_room_order];
                            }
                            else if ((_path_cached_data_key_metadata in path_obj)) {
                                var list_of_names = path_obj [_path_cached_data_key_metadata].split (',').slice (1);
                            }
                            else {
                                var list_of_names = Object.keys (path_obj);
                            }
                            var __iterable0__ = list_of_names;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var room_name = __iterable0__ [__index0__];
                                if (!(movement.is_valid_room_name (room_name))) {
                                    continue;
                                }
                                var path = Room.deserializePath (path_obj [room_name]);
                                var __iterable1__ = path;
                                for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                    var pos = __iterable1__ [__index1__];
                                    if ((0 < pos.x && pos.x < 50) && (0 < pos.y && pos.y < 50)) {
                                        final_list.append (new RoomPosition (pos.x, pos.y, room_name));
                                    }
                                }
                            }
                            return final_list;
                        }, 'list_of_room_positions_in_path');},
                        get find_path_length () {return __get__ (this, function (self, origin, destination, opts) {
                            if (typeof opts == 'undefined' || (opts != null && opts .hasOwnProperty ("__kwargtrans__"))) {;
                                var opts = null;
                            };
                            var serialized_path_obj = self.get_serialized_path_obj (origin, destination, opts);
                            if ((_path_cached_data_key_metadata in serialized_path_obj)) {
                                return int (serialized_path_obj [_path_cached_data_key_metadata].split (',') [0]);
                            }
                            if ((_path_cached_data_key_full_path in serialized_path_obj)) {
                                return (len (serialized_path_obj [_path_cached_data_key_full_path]) - _.sum (Object.keys (serialized_path_obj), (function __lambda__ (n) {
                                    return movement.is_valid_room_name (n);
                                }))) - 2;
                            }
                            else if ((_path_cached_data_key_length in serialized_path_obj)) {
                                return serialized_path_obj [_path_cached_data_key_length];
                            }
                            else {
                                var total = 1;
                                var __iterable0__ = Object.keys (serialized_path_obj);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var room_name = __iterable0__ [__index0__];
                                    if (movement.is_valid_room_name (room_name)) {
                                        total += len (serialized_path_obj [room_name]) - 4;
                                    }
                                }
                                return total;
                            }
                        }, 'find_path_length');}
                    });
                    __pragma__ ('<use>' +
                        'cache.global_cache' +
                        'constants' +
                        'creep_management.mining_paths' +
                        'jstools.screeps_constants' +
                        'position_management.flags' +
                        'utilities.hostile_utils' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.HoneyTrails = HoneyTrails;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__._path_cached_data_key_full_path = _path_cached_data_key_full_path;
                        __all__._path_cached_data_key_length = _path_cached_data_key_length;
                        __all__._path_cached_data_key_metadata = _path_cached_data_key_metadata;
                        __all__._path_cached_data_key_room_order = _path_cached_data_key_room_order;
                        __all__.clear_serialized_cost_matrix = clear_serialized_cost_matrix;
                        __all__.dxdy_to_direction = dxdy_to_direction;
                        __all__.flags = flags;
                        __all__.get_global_cache_key = get_global_cache_key;
                        __all__.global_cache = global_cache;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.hostile_utils = hostile_utils;
                        __all__.mining_paths = mining_paths;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.pathfinder_path_to_room_to_path_obj = pathfinder_path_to_room_to_path_obj;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'empire.states', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var _min_wall_hit_difference_to_balance = WALL_HITS_MAX / 300;
                    var StateCalc = __class__ ('StateCalc', [object], {
                        get __init__ () {return __get__ (this, function (self, hive) {
                            self.hive = hive;
                        });},
                        get calculate_room_states () {return __get__ (this, function (self) {
                            var under_siege = [];
                            var not_under_siege = [];
                            var __iterable0__ = self.hive.my_rooms;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var room = __iterable0__ [__index0__];
                                if (room.minerals.fully_setup ()) {
                                    if (room.mem [rmem_key_currently_under_siege]) {
                                        under_siege.append (room);
                                    }
                                    else {
                                        not_under_siege.append (room);
                                    }
                                }
                            }
                            if (len (under_siege) > 0) {
                                if (len (not_under_siege) > 0) {
                                    if (len (under_siege) > 1) {
                                        var under_siege = _.sortBy (under_siege, (function __lambda__ (x) {
                                            return x.calculate_smallest_wall ();
                                        }));
                                        while (len (under_siege) < len (not_under_siege)) {
                                            var under_siege = under_siege.concat (under_siege);
                                        }
                                        var __iterable0__ = under_siege;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var room = __iterable0__ [__index0__];
                                            if (!(len (not_under_siege))) {
                                                break;
                                            }
                                            var closest = null;
                                            var closest_index = null;
                                            var closest_distance = Infinity;
                                            for (var i = 0; i < len (not_under_siege); i++) {
                                                var room_to_check = not_under_siege [i];
                                                var distance = Game.map.getLinearRoomDistance (room.name, room_to_check.name, true);
                                                if (distance < closest_distance) {
                                                    var closest = room_to_check;
                                                    var closest_distance = distance;
                                                    var closest_index = i;
                                                }
                                            }
                                            not_under_siege.splice (closest_index, 1);
                                            closest.set_supporting_room (room.name);
                                        }
                                    }
                                    else {
                                        var __iterable0__ = not_under_siege;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var room = __iterable0__ [__index0__];
                                            room.set_supporting_room (under_siege [0].name);
                                        }
                                    }
                                }
                                else {
                                    var __iterable0__ = under_siege;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var room = __iterable0__ [__index0__];
                                        room.set_supporting_room (null);
                                    }
                                }
                            }
                            else if (len (not_under_siege) > 0) {
                                if (len (not_under_siege) > 1) {
                                    var smallest_room = null;
                                    var smallest_room_smallest_wall = Infinity;
                                    var biggest_room_smallest_wall = -(Infinity);
                                    var __iterable0__ = not_under_siege;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var room = __iterable0__ [__index0__];
                                        var hits = room.calculate_smallest_wall ();
                                        if (hits < smallest_room_smallest_wall) {
                                            var smallest_room_smallest_wall = hits;
                                            var smallest_room = room.name;
                                        }
                                        else if (hits > biggest_room_smallest_wall) {
                                            var biggest_room_smallest_wall = hits;
                                        }
                                    }
                                    if (biggest_room_smallest_wall - smallest_room_smallest_wall > _min_wall_hit_difference_to_balance) {
                                        var any_above_should_support = (biggest_room_smallest_wall + smallest_room_smallest_wall) / 2;
                                        var __iterable0__ = not_under_siege;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var room = __iterable0__ [__index0__];
                                            if (room.rcl >= 8) {
                                                var hits = room.calculate_smallest_wall ();
                                                if (hits >= any_above_should_support) {
                                                    room.set_supporting_room (smallest_room);
                                                }
                                                else {
                                                    room.set_supporting_room (null);
                                                }
                                            }
                                            else {
                                                room.set_supporting_room (null);
                                            }
                                        }
                                    }
                                    else {
                                        var __iterable0__ = not_under_siege;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var room = __iterable0__ [__index0__];
                                            room.set_supporting_room (null);
                                        }
                                    }
                                }
                                else {
                                    not_under_siege [0].set_supporting_room (null);
                                }
                            }
                        });}
                    });
                    __pragma__ ('<use>' +
                        'constants' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.StateCalc = StateCalc;
                        __all__._min_wall_hit_difference_to_balance = _min_wall_hit_difference_to_balance;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'empire.targets', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
                    var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
                    var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
                    var PYFIND_BUILDABLE_ROADS = __init__ (__world__.constants).PYFIND_BUILDABLE_ROADS;
                    var PYFIND_HURT_CREEPS = __init__ (__world__.constants).PYFIND_HURT_CREEPS;
                    var PYFIND_REPAIRABLE_ROADS = __init__ (__world__.constants).PYFIND_REPAIRABLE_ROADS;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var REROUTE = __init__ (__world__.constants).REROUTE;
                    var REROUTE_DESTINATION = __init__ (__world__.constants).REROUTE_DESTINATION;
                    var RESERVE_NOW = __init__ (__world__.constants).RESERVE_NOW;
                    var SCOUT = __init__ (__world__.constants).SCOUT;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var SK_USERNAME = __init__ (__world__.constants).SK_USERNAME;
                    var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
                    var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
                    var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
                    var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
                    var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var creep_base_1500miner = __init__ (__world__.constants).creep_base_1500miner;
                    var creep_base_3000miner = __init__ (__world__.constants).creep_base_3000miner;
                    var creep_base_3h = __init__ (__world__.constants).creep_base_3h;
                    var creep_base_4000miner = __init__ (__world__.constants).creep_base_4000miner;
                    var creep_base_carry3000miner = __init__ (__world__.constants).creep_base_carry3000miner;
                    var creep_base_claim_attack = __init__ (__world__.constants).creep_base_claim_attack;
                    var creep_base_claiming = __init__ (__world__.constants).creep_base_claiming;
                    var creep_base_defender = __init__ (__world__.constants).creep_base_defender;
                    var creep_base_dismantler = __init__ (__world__.constants).creep_base_dismantler;
                    var creep_base_full_move_dismantler = __init__ (__world__.constants).creep_base_full_move_dismantler;
                    var creep_base_full_move_goader = __init__ (__world__.constants).creep_base_full_move_goader;
                    var creep_base_full_move_healer = __init__ (__world__.constants).creep_base_full_move_healer;
                    var creep_base_full_move_power_attack = __init__ (__world__.constants).creep_base_full_move_power_attack;
                    var creep_base_full_upgrader = __init__ (__world__.constants).creep_base_full_upgrader;
                    var creep_base_goader = __init__ (__world__.constants).creep_base_goader;
                    var creep_base_half_move_hauler = __init__ (__world__.constants).creep_base_half_move_hauler;
                    var creep_base_half_move_healer = __init__ (__world__.constants).creep_base_half_move_healer;
                    var creep_base_hauler = __init__ (__world__.constants).creep_base_hauler;
                    var creep_base_mammoth_miner = __init__ (__world__.constants).creep_base_mammoth_miner;
                    var creep_base_power_attack = __init__ (__world__.constants).creep_base_power_attack;
                    var creep_base_rampart_defense = __init__ (__world__.constants).creep_base_rampart_defense;
                    var creep_base_ranged_offense = __init__ (__world__.constants).creep_base_ranged_offense;
                    var creep_base_reserving = __init__ (__world__.constants).creep_base_reserving;
                    var creep_base_scout = __init__ (__world__.constants).creep_base_scout;
                    var creep_base_work_full_move_hauler = __init__ (__world__.constants).creep_base_work_full_move_hauler;
                    var creep_base_work_half_move_hauler = __init__ (__world__.constants).creep_base_work_half_move_hauler;
                    var creep_base_worker = __init__ (__world__.constants).creep_base_worker;
                    var default_roles = __init__ (__world__.constants).default_roles;
                    var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
                    var gmem_key_last_room_state_refresh = __init__ (__world__.constants).gmem_key_last_room_state_refresh;
                    var gmem_key_room_mining_paths = __init__ (__world__.constants).gmem_key_room_mining_paths;
                    var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
                    var max_repave_mine_roads_every = __init__ (__world__.constants).max_repave_mine_roads_every;
                    var min_repath_mine_roads_every = __init__ (__world__.constants).min_repath_mine_roads_every;
                    var min_repave_mine_roads_every = __init__ (__world__.constants).min_repave_mine_roads_every;
                    var old_role_names = __init__ (__world__.constants).old_role_names;
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var request_priority_economy = __init__ (__world__.constants).request_priority_economy;
                    var request_priority_helping_party = __init__ (__world__.constants).request_priority_helping_party;
                    var request_priority_imminent_threat_defense = __init__ (__world__.constants).request_priority_imminent_threat_defense;
                    var request_priority_low = __init__ (__world__.constants).request_priority_low;
                    var rmem_key_building_paused = __init__ (__world__.constants).rmem_key_building_paused;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
                    var rmem_key_cache = __init__ (__world__.constants).rmem_key_cache;
                    var rmem_key_carry_parts_by_role = __init__ (__world__.constants).rmem_key_carry_parts_by_role;
                    var rmem_key_creeps_by_role = __init__ (__world__.constants).rmem_key_creeps_by_role;
                    var rmem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants).rmem_key_creeps_by_role_and_replacement_time;
                    var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
                    var rmem_key_defense_mind_storage = __init__ (__world__.constants).rmem_key_defense_mind_storage;
                    var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants).rmem_key_empty_all_resources_into_room;
                    var rmem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants).rmem_key_flag_for_testing_spawning_in_simulation;
                    var rmem_key_focusing_home = __init__ (__world__.constants).rmem_key_focusing_home;
                    var rmem_key_linking_mind_storage = __init__ (__world__.constants).rmem_key_linking_mind_storage;
                    var rmem_key_metadata = __init__ (__world__.constants).rmem_key_metadata;
                    var rmem_key_mineral_mind_storage = __init__ (__world__.constants).rmem_key_mineral_mind_storage;
                    var rmem_key_now_supporting = __init__ (__world__.constants).rmem_key_now_supporting;
                    var rmem_key_pause_all_room_operations = __init__ (__world__.constants).rmem_key_pause_all_room_operations;
                    var rmem_key_planned_role_to_spawn = __init__ (__world__.constants).rmem_key_planned_role_to_spawn;
                    var rmem_key_prepping_defenses = __init__ (__world__.constants).rmem_key_prepping_defenses;
                    var rmem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants).rmem_key_remotes_explicitly_marked_under_attack;
                    var rmem_key_remotes_safe_when_under_siege = __init__ (__world__.constants).rmem_key_remotes_safe_when_under_siege;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
                    var rmem_key_spawn_requests = __init__ (__world__.constants).rmem_key_spawn_requests;
                    var rmem_key_sponsor = __init__ (__world__.constants).rmem_key_sponsor;
                    var rmem_key_storage_use_enabled = __init__ (__world__.constants).rmem_key_storage_use_enabled;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
                    var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants).rmem_key_there_might_be_energy_lying_around;
                    var rmem_key_total_open_source_spaces = __init__ (__world__.constants).rmem_key_total_open_source_spaces;
                    var rmem_key_upgrading_paused = __init__ (__world__.constants).rmem_key_upgrading_paused;
                    var rmem_key_work_parts_by_role = __init__ (__world__.constants).rmem_key_work_parts_by_role;
                    var role_bases = __init__ (__world__.constants).role_bases;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_cleanup = __init__ (__world__.constants).role_cleanup;
                    var role_colonist = __init__ (__world__.constants).role_colonist;
                    var role_defender = __init__ (__world__.constants).role_defender;
                    var role_energy_grab = __init__ (__world__.constants).role_energy_grab;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_link_manager = __init__ (__world__.constants).role_link_manager;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
                    var role_mineral_miner = __init__ (__world__.constants).role_mineral_miner;
                    var role_mineral_steal = __init__ (__world__.constants).role_mineral_steal;
                    var role_power_attack = __init__ (__world__.constants).role_power_attack;
                    var role_power_cleanup = __init__ (__world__.constants).role_power_cleanup;
                    var role_ranged_offense = __init__ (__world__.constants).role_ranged_offense;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_remote_mining_reserve = __init__ (__world__.constants).role_remote_mining_reserve;
                    var role_room_reserve = __init__ (__world__.constants).role_room_reserve;
                    var role_scout = __init__ (__world__.constants).role_scout;
                    var role_simple_claim = __init__ (__world__.constants).role_simple_claim;
                    var role_simple_dismantle = __init__ (__world__.constants).role_simple_dismantle;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_spawn_fill_backup = __init__ (__world__.constants).role_spawn_fill_backup;
                    var role_td_goad = __init__ (__world__.constants).role_td_goad;
                    var role_td_healer = __init__ (__world__.constants).role_td_healer;
                    var role_temporary_replacing = __init__ (__world__.constants).role_temporary_replacing;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var role_tower_fill_once = __init__ (__world__.constants).role_tower_fill_once;
                    var role_upgrade_fill = __init__ (__world__.constants).role_upgrade_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var role_wall_defender = __init__ (__world__.constants).role_wall_defender;
                    var target_big_big_repair = __init__ (__world__.constants).target_big_big_repair;
                    var target_big_repair = __init__ (__world__.constants).target_big_repair;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var target_construction = __init__ (__world__.constants).target_construction;
                    var target_destruction_site = __init__ (__world__.constants).target_destruction_site;
                    var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
                    var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
                    var target_home_flag = __init__ (__world__.constants).target_home_flag;
                    var target_rampart_defense = __init__ (__world__.constants).target_rampart_defense;
                    var target_refill = __init__ (__world__.constants).target_refill;
                    var target_repair = __init__ (__world__.constants).target_repair;
                    var target_reserve_now = __init__ (__world__.constants).target_reserve_now;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var target_single_flag2 = __init__ (__world__.constants).target_single_flag2;
                    var target_source = __init__ (__world__.constants).target_source;
                    var target_spawn_deposit = __init__ (__world__.constants).target_spawn_deposit;
                    var target_tower_fill = __init__ (__world__.constants).target_tower_fill;
                    var spawning = __init__ (__world__.creep_management.spawning);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var locations = __init__ (__world__.position_management.locations);
                    var movement = __init__ (__world__.utilities.movement);
                    var _MAX_BUILDERS = 4;
                    var _MAX_REPAIR_WORKFORCE = 10;
                    var _mass_count = function (name) {
                        if ((name in Memory.creeps) && (Memory.creeps [name].carry || Memory.creeps [name].work)) {
                            var carry = Memory.creeps [name].carry || 0;
                            var work = Memory.creeps [name].work || 0;
                        }
                        else if ((name in Game.creeps)) {
                            var creep = Game.creeps [name];
                            var carry = spawning.carry_count (creep);
                            var work = spawning.work_count (creep);
                        }
                        else {
                            return 1;
                        }
                        return max (work, carry);
                    };
                    var update_targeters_memory_0_to_1 = function (targeters) {
                        var string_target_names_to_numbers = {'source': 0, 'generic_deposit': 1, 'sccf': 2, 'sccf2': 3, 'hf': 4, 'refill': 5, 'construction_site': 10, 'repair_site': 11, 'extra_repair_site': 12, 'ders': 13, 'destruction_site': 14, 'spawn_deposit_site': 20, 'fillable_tower': 21, 'remote_miner_mine': 30, 'remote_mine_hauler': 31, 'top_priority_reserve': 32, 'rampart_def': 40};
                        var new_targeters = {};
                        var __iterable0__ = Object.keys (targeters);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var targeter_id = __iterable0__ [__index0__];
                            var new_targeter_map = {};
                            new_targeters [targeter_id] = new_targeter_map;
                            var __iterable1__ = Object.keys (targeters [targeter_id]);
                            for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                var ttype = __iterable1__ [__index1__];
                                var target_id = targeters [targeter_id] [ttype];
                                if (_.isString (ttype)) {
                                    if ((ttype in string_target_names_to_numbers)) {
                                        var ttype = string_target_names_to_numbers [ttype];
                                    }
                                    else {
                                        var msg = "WARNING: Error updating old targetmind memory. Couldn't find ttype {} in conversion map!".format (ttype);
                                        console.log (msg);
                                        Game.notify (msg);
                                        var __except0__ = ValueError;
                                        __except0__.__cause__ = null;
                                        throw __except0__;
                                    }
                                }
                                else if (!(_.isNumber (ttype))) {
                                    var msg = 'WARNING: Error updating old TargetMind memory. Unknown type of ttype (not string nor int): {}!'.format (ttype);
                                    console.log (msg);
                                    Game.notify (msg);
                                    var __except0__ = ValueError;
                                    __except0__.__cause__ = null;
                                    throw __except0__;
                                }
                                new_targeter_map [ttype] = target_id;
                            }
                        }
                        return new_targeters;
                    };
                    var TargetMind = __class__ ('TargetMind', [object], {
                        get __init__ () {return __get__ (this, function (self) {
                            if (!(Memory.targets)) {
                                Memory.targets = {'targets_used': {}, 'targeters_using': {}, 'last_clear': Game.time, 'version': 1};
                            }
                            self.mem = Memory.targets;
                            if (!('version' in self.mem) || self.mem.version < 1) {
                                var targeters = self.mem.targeters_using || {};
                                self.mem.targeters_using = update_targeters_memory_0_to_1 (targeters);
                                self._recreate_all_from_targeters ();
                                self.mem.version = 1;
                                self.mem.last_clear = Game.time;
                            }
                            if (!(self.mem.targets_used)) {
                                self.mem.targets_used = {};
                            }
                            if (!(self.mem.targets_workforce)) {
                                self.mem.targets_workforce = {};
                            }
                            if (!(self.mem.targeters_using)) {
                                self.mem.targeters_using = {};
                            }
                            if (!(self.mem.targets_stealable)) {
                                self.mem.targets_stealable = {};
                            }
                            if ((self.mem.last_clear || 0) + 1000 < Game.time) {
                                self._recreate_all_from_targeters ();
                                self.mem.last_clear = Game.time;
                            }
                            self.find_functions = {[target_source]: self._find_new_source, [target_construction]: self._find_new_construction_site, [target_repair]: self._find_new_repair_site, [target_big_repair]: self._find_new_big_repair_site, [target_big_big_repair]: self._find_new_big_big_repair_site, [target_destruction_site]: self._find_new_destruction_site, [target_spawn_deposit]: self._find_new_spawn_fill_site, [target_tower_fill]: self._find_new_tower, [target_energy_miner_mine]: self._find_new_energy_miner_mine, [target_energy_hauler_mine]: self._find_new_energy_hauler_mine, [target_reserve_now]: self._find_top_priority_reservable_room, [target_closest_energy_site]: self._find_closest_deposit_site, [target_single_flag]: self._find_closest_flag, [target_single_flag2]: self._find_closest_flag2, [target_home_flag]: self._find_closest_home_flag, [target_refill]: self._find_refill_target, [target_rampart_defense]: self._find_new_defendable_wall};
                        }, '__init__');},
                        get __get_targets () {return __get__ (this, function (self) {
                            return self.mem.targets_used;
                        }, '__get_targets');},
                        get __set_targets () {return __get__ (this, function (self, value) {
                            self.mem.targets_used = value;
                        }, '__set_targets');},
                        get __get_targeters () {return __get__ (this, function (self) {
                            return self.mem.targeters_using;
                        }, '__get_targeters');},
                        get __set_targeters () {return __get__ (this, function (self, value) {
                            self.mem.targeters_using = value;
                        }, '__set_targeters');},
                        get __get_targets_workforce () {return __get__ (this, function (self) {
                            return self.mem.targets_workforce;
                        }, '__get_targets_workforce');},
                        get __set_targets_workforce () {return __get__ (this, function (self, value) {
                            self.mem.targets_workforce = value;
                        }, '__set_targets_workforce');},
                        get __get_reverse_targets () {return __get__ (this, function (self) {
                            return self.mem.targets_stealable;
                        }, '__get_reverse_targets');},
                        get __set_reverse_targets () {return __get__ (this, function (self, value) {
                            self.mem.targets_stealable = value;
                        }, '__set_reverse_targets');},
                        get workforce_of () {return __get__ (this, function (self, ttype, target) {
                            return self.targets [ttype] && self.targets [ttype] [target] && self.targets_workforce [ttype] && self.targets_workforce [ttype] [target] || 0;
                        }, 'workforce_of');},
                        get creeps_now_targeting () {return __get__ (this, function (self, ttype, target_id) {
                            return (ttype in self.reverse_targets) && self.reverse_targets [ttype] [target_id] || [];
                        }, 'creeps_now_targeting');},
                        get _register_new_targeter () {return __get__ (this, function (self, ttype, targeter_id, target_id) {
                            if (!(targeter_id in self.targeters)) {
                                self.targeters [targeter_id] = {[ttype]: target_id};
                            }
                            else if (!(ttype in self.targeters [targeter_id])) {
                                self.targeters [targeter_id] [ttype] = target_id;
                            }
                            else {
                                var old_target_id = self.targeters [targeter_id] [ttype];
                                self.targeters [targeter_id] [ttype] = target_id;
                                if (old_target_id == target_id) {
                                    return ;
                                }
                                self.targets [ttype] [old_target_id]--;
                                if (len (self.targets [ttype] [old_target_id]) <= 0) {
                                    delete self.targets [ttype] [old_target_id];
                                }
                            }
                            if (!(ttype in self.targets)) {
                                self.targets [ttype] = {[target_id]: 1};
                            }
                            else if (!(self.targets [ttype] [target_id])) {
                                self.targets [ttype] [target_id] = 1;
                            }
                            else {
                                self.targets [ttype] [target_id]++;
                            }
                            if (!(ttype in self.targets_workforce)) {
                                self.targets_workforce [ttype] = {[target_id]: _mass_count (targeter_id)};
                            }
                            else if (!(target_id in self.targets_workforce [ttype])) {
                                self.targets_workforce [ttype] [target_id] = _mass_count (targeter_id);
                            }
                            else {
                                self.targets_workforce [ttype] [target_id] += _mass_count (targeter_id);
                            }
                            if (!(ttype in self.reverse_targets)) {
                                self.reverse_targets [ttype] = {[target_id]: [targeter_id]};
                            }
                            else if (!(target_id in self.reverse_targets [ttype])) {
                                self.reverse_targets [ttype] [target_id] = [targeter_id];
                            }
                            else {
                                self.reverse_targets [ttype] [target_id].push (targeter_id);
                            }
                        }, '_register_new_targeter');},
                        get _recreate_all_from_targeters () {return __get__ (this, function (self) {
                            var new_targets = {};
                            var new_workforce = {};
                            var new_reverse = {};
                            var __iterable0__ = Object.keys (self.targeters);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var targeter_id = __iterable0__ [__index0__];
                                var mass = _mass_count (targeter_id);
                                var __iterable1__ = Object.keys (self.targeters [targeter_id]);
                                for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                    var ttype = __iterable1__ [__index1__];
                                    var target_id = self.targeters [targeter_id] [ttype];
                                    if ((ttype in new_targets)) {
                                        if ((target_id in new_targets [ttype])) {
                                            new_targets [ttype] [target_id]++;
                                        }
                                        else {
                                            new_targets [ttype] [target_id] = 1;
                                        }
                                    }
                                    else {
                                        new_targets [ttype] = {[target_id]: 1};
                                    }
                                    if ((ttype in new_workforce)) {
                                        if ((target_id in new_workforce [ttype])) {
                                            new_workforce [ttype] [target_id] += mass;
                                        }
                                        else {
                                            new_workforce [ttype] [target_id] = mass;
                                        }
                                    }
                                    else {
                                        new_workforce [ttype] = {[target_id]: mass};
                                    }
                                    if ((ttype in new_reverse)) {
                                        if ((target_id in new_reverse [ttype])) {
                                            new_reverse [ttype] [target_id].push (targeter_id);
                                        }
                                        else {
                                            new_reverse [ttype] [target_id] = [targeter_id];
                                        }
                                    }
                                    else {
                                        new_reverse [ttype] = {[target_id]: [targeter_id]};
                                    }
                                }
                            }
                            self.targets = new_targets;
                            self.targets_workforce = new_workforce;
                            self.reverse_targets = new_reverse;
                        }, '_recreate_all_from_targeters');},
                        get _unregister_targeter () {return __get__ (this, function (self, ttype, targeter_id) {
                            var existing_target = self._get_existing_target_id (ttype, targeter_id);
                            if (existing_target) {
                                if ((ttype in self.targets) && (existing_target in self.targets [ttype])) {
                                    self.targets [ttype] [existing_target]--;
                                }
                                if ((ttype in self.targets_workforce) && (existing_target in self.targets_workforce [ttype])) {
                                    self.targets_workforce [ttype] [existing_target] -= _mass_count (targeter_id);
                                }
                                if ((ttype in self.reverse_targets) && (existing_target in self.reverse_targets [ttype])) {
                                    var index = self.reverse_targets [ttype] [existing_target].indexOf (targeter_id);
                                    if (index > -(1)) {
                                        self.reverse_targets [ttype] [existing_target].splice (index, 1);
                                    }
                                }
                                delete self.targeters [targeter_id] [ttype];
                            }
                        }, '_unregister_targeter');},
                        get _unregister_all () {return __get__ (this, function (self, targeter_id) {
                            if (self.targeters [targeter_id]) {
                                var mass = _mass_count (targeter_id);
                                var __iterable0__ = Object.keys (self.targeters [targeter_id]);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var ttype = __iterable0__ [__index0__];
                                    var target = self.targeters [targeter_id] [ttype];
                                    if ((ttype in self.targets) && (target in self.targets [ttype])) {
                                        self.targets [ttype] [target]--;
                                    }
                                    if ((ttype in self.targets_workforce) && (target in self.targets_workforce [ttype])) {
                                        self.targets_workforce [ttype] [target] -= mass;
                                    }
                                    if ((ttype in self.reverse_targets) && (target in self.reverse_targets [ttype])) {
                                        var index = self.reverse_targets [ttype] [target].indexOf (targeter_id);
                                        if (index > -(1)) {
                                            self.reverse_targets [ttype] [target].splice (index, 1);
                                        }
                                    }
                                }
                            }
                            delete self.targeters [targeter_id];
                        }, '_unregister_all');},
                        get _move_targets () {return __get__ (this, function (self, old_targeter_id, new_targeter_id) {
                            if (self.targeters [old_targeter_id]) {
                                self.targeters [new_targeter_id] = self.targeters [old_targeter_id];
                                var old_mass = _mass_count (old_targeter_id);
                                var new_mass = _mass_count (new_targeter_id);
                                var __iterable0__ = Object.keys (self.targeters [new_targeter_id]);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var ttype = __iterable0__ [__index0__];
                                    var target = self.targeters [new_targeter_id] [ttype];
                                    if ((ttype in self.targets_workforce)) {
                                        if ((target in self.targets_workforce)) {
                                            self.targets_workforce [ttype] [target] += new_mass - old_mass;
                                        }
                                        else {
                                            self.targets_workforce [ttype] [target] = new_mass;
                                        }
                                    }
                                    else {
                                        self.targets_workforce [ttype] = {[target]: new_mass};
                                    }
                                    if ((ttype in self.reverse_targets) && (target in self.reverse_targets [ttype])) {
                                        var index = self.reverse_targets [ttype] [target].indexOf (old_targeter_id);
                                        if (index > -(1)) {
                                            self.reverse_targets [ttype] [target].splice (index, 1, new_targeter_id);
                                        }
                                    }
                                }
                                delete self.targeters [old_targeter_id];
                            }
                        }, '_move_targets');},
                        get _find_new_target () {return __get__ (this, function (self, ttype, creep, extra_var) {
                            if (!(ttype in self.targets)) {
                                self.targets [ttype] = {};
                            }
                            if (!(ttype in self.targets_workforce)) {
                                self.targets_workforce [ttype] = {};
                            }
                            if (!(ttype in self.reverse_targets)) {
                                self.reverse_targets [ttype] = {};
                            }
                            var func = self.find_functions [ttype];
                            if (func) {
                                return func (creep, extra_var);
                            }
                            else {
                                var __except0__ = Error ("Couldn't find find_function for '{}'!".format (ttype));
                                __except0__.__cause__ = null;
                                throw __except0__;
                            }
                        }, '_find_new_target');},
                        get _get_existing_target_id () {return __get__ (this, function (self, ttype, targeter_id) {
                            if ((targeter_id in self.targeters) && (ttype in self.targeters [targeter_id])) {
                                return self.targeters [targeter_id] [ttype];
                            }
                            return null;
                        }, '_get_existing_target_id');},
                        get _get_new_target_id () {return __get__ (this, function (self, ttype, targeter_id, creep, extra_var) {
                            if ((targeter_id in self.targeters) && (ttype in self.targeters [targeter_id])) {
                                return self.targeters [targeter_id] [ttype];
                            }
                            var new_target = self._find_new_target (ttype, creep, extra_var);
                            if (!(new_target)) {
                                return null;
                            }
                            self._register_new_targeter (ttype, targeter_id, new_target);
                            return new_target;
                        }, '_get_new_target_id');},
                        get get_new_target () {return __get__ (this, function (self, creep, ttype, extra_var, second_time) {
                            if (typeof extra_var == 'undefined' || (extra_var != null && extra_var .hasOwnProperty ("__kwargtrans__"))) {;
                                var extra_var = null;
                            };
                            if (typeof second_time == 'undefined' || (second_time != null && second_time .hasOwnProperty ("__kwargtrans__"))) {;
                                var second_time = false;
                            };
                            var target_id = self._get_new_target_id (ttype, creep.name, creep, extra_var);
                            if (!(target_id)) {
                                return null;
                            }
                            var target = Game.getObjectById (target_id);
                            if (target === null) {
                                var target = locations.get (target_id);
                                if (target === null && target_id.startswith && target_id.startswith ('flag-')) {
                                    var target = Game.flags [target_id.__getslice__ (5, null, 1)];
                                }
                            }
                            if (!(target)) {
                                self._unregister_targeter (ttype, creep.name);
                                if (!(second_time)) {
                                    return self.get_new_target (creep, ttype, extra_var, true);
                                }
                            }
                            return target;
                        }, 'get_new_target');},
                        get get_existing_target () {return __get__ (this, function (self, creep, ttype) {
                            var target_id = self._get_existing_target_id (ttype, creep.name);
                            if (!(target_id)) {
                                return null;
                            }
                            var target = Game.getObjectById (target_id);
                            if (target === null) {
                                var target = locations.get (target_id);
                                if (target === null && target_id.startswith && target_id.startswith ('flag-')) {
                                    var target = Game.flags [target_id.__getslice__ (5, null, 1)];
                                }
                            }
                            if (!(target)) {
                                self._unregister_targeter (ttype, creep.name);
                            }
                            return target;
                        }, 'get_existing_target');},
                        get manually_register () {return __get__ (this, function (self, creep, ttype, target_id) {
                            self._register_new_targeter (ttype, creep.name, target_id);
                        }, 'manually_register');},
                        get untarget () {return __get__ (this, function (self, creep, ttype) {
                            self._unregister_targeter (ttype, creep.name);
                        }, 'untarget');},
                        get untarget_all () {return __get__ (this, function (self, creep) {
                            self._unregister_all (creep.name);
                        }, 'untarget_all');},
                        get assume_identity () {return __get__ (this, function (self, old_name, new_name) {
                            self._move_targets (old_name, new_name);
                        }, 'assume_identity');},
                        get _find_new_source () {return __get__ (this, function (self, creep) {
                            var has_work = !(!(creep.creep.hasActiveBodyparts (WORK)));
                            var any_miners = !(!(creep.home.role_count (role_miner)));
                            var highest_priority = -(Infinity);
                            var best_source = null;
                            var __iterable0__ = creep.home.sources;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var source = __iterable0__ [__index0__];
                                if (!(has_work) && !(_.some (creep.home.find_in_range (FIND_MY_CREEPS, 1, source.pos), (function __lambda__ (c) {
                                    return c.memory.role == role_miner;
                                })))) {
                                    continue;
                                }
                                var distance = movement.chebyshev_distance_room_pos (source.pos, creep.pos);
                                var current_work_force = self.workforce_of (target_source, source.id);
                                if (any_miners) {
                                    var energy = _.sum (creep.home.find_in_range (FIND_DROPPED_ENERGY, 1, source.pos), 'amount');
                                    var priority = (energy - current_work_force * 100) - distance * 2;
                                }
                                else {
                                    var oss = creep.home.get_open_source_spaces_around (source);
                                    var priority = (oss * 10 - (100 * current_work_force) / oss) - distance;
                                }
                                if (source.energy <= 0) {
                                    priority -= 200;
                                }
                                if (!(priority)) {
                                    print ('[targets] Strange priority result for source {}: {}'.format (source, priority));
                                }
                                if (priority > highest_priority) {
                                    var best_source = source.id;
                                    var highest_priority = priority;
                                }
                            }
                            return best_source;
                        }, '_find_new_source');},
                        get _find_new_spawn_fill_site () {return __get__ (this, function (self, creep) {
                            var closest_distance = Infinity;
                            var best_id = null;
                            var stealing_from = null;
                            var structures = _.filter (creep.home.find (FIND_MY_STRUCTURES), (function __lambda__ (s) {
                                return (s.structureType == STRUCTURE_EXTENSION || s.structureType == STRUCTURE_SPAWN) && s.energy < s.energyCapacity;
                            }));
                            if (len (structures)) {
                                var __iterable0__ = structures;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var structure = __iterable0__ [__index0__];
                                    var structure_id = structure.id;
                                    if (volatile_cache.mem ('extensions_filled').has (structure_id)) {
                                        continue;
                                    }
                                    var current_carry = self.workforce_of (target_spawn_deposit, structure_id);
                                    var distance = movement.distance_squared_room_pos (structure.pos, creep.creep.pos);
                                    if (distance < closest_distance) {
                                        var max = structure.energyCapacity / 50.0;
                                        if (!(current_carry) || current_carry < max) {
                                            var closest_distance = distance;
                                            var best_id = structure_id;
                                            var stealing_from = null;
                                        }
                                        else {
                                            var targeting = self.reverse_targets [target_spawn_deposit] [structure_id];
                                            if (len (targeting)) {
                                                var __iterable1__ = targeting;
                                                for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                                    var name = __iterable1__ [__index1__];
                                                    if (!(Game.creeps [name]) || movement.distance_squared_room_pos (Game.creeps [name].pos, structure.pos) > distance * 2.25) {
                                                        var closest_distance = distance;
                                                        var best_id = structure_id;
                                                        var stealing_from = name;
                                                        break;
                                                    }
                                                }
                                            }
                                            else {
                                                var closest_distance = distance;
                                                var best_id = structure_id;
                                                var stealing_from = null;
                                            }
                                        }
                                    }
                                }
                                if (stealing_from !== null) {
                                    self._unregister_targeter (target_spawn_deposit, stealing_from);
                                }
                            }
                            else if (creep.home.full_storage_use) {
                                var flag_list = flags.find_flags (creep.home, SPAWN_FILL_WAIT);
                                if (len (flag_list)) {
                                    var best_id = _ (flag_list).map ((function __lambda__ (f) {
                                        return 'flag-{}'.format (f.name);
                                    })).min ((function __lambda__ (fid) {
                                        return self.reverse_targets [target_spawn_deposit] [fid] || 0;
                                    }));
                                    if (best_id === Infinity) {
                                        var best_id = null;
                                    }
                                }
                            }
                            return best_id;
                        }, '_find_new_spawn_fill_site');},
                        get _find_new_construction_site () {return __get__ (this, function (self, creep, walls_only) {
                            if (typeof walls_only == 'undefined' || (walls_only != null && walls_only .hasOwnProperty ("__kwargtrans__"))) {;
                                var walls_only = false;
                            };
                            var smallest_work_force = Infinity;
                            var best_id = null;
                            if (walls_only) {
                                var sites = creep.home.building.get_high_value_construction_targets ();
                            }
                            else {
                                var sites = creep.home.building.get_construction_targets ();
                            }
                            var __iterable0__ = sites;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var site_id = __iterable0__ [__index0__];
                                if (site_id.startsWith ('flag-')) {
                                    var max_work = _MAX_BUILDERS;
                                }
                                else {
                                    var site = Game.getObjectById (site_id);
                                    if (!(site)) {
                                        continue;
                                    }
                                    var max_work = min (_MAX_BUILDERS, math.ceil ((site.progressTotal - site.progress) / 50));
                                }
                                var current_work = self.workforce_of (target_construction, site_id);
                                if (!(current_work) || current_work < max_work) {
                                    var best_id = site_id;
                                    break;
                                }
                                else if (current_work < smallest_work_force) {
                                    var best_id = site_id;
                                    var smallest_work_force = current_work;
                                }
                            }
                            if (!(best_id) && len (sites)) {
                                creep.home.building.refresh_building_targets (true);
                                return self._find_new_construction_site (creep, walls_only);
                            }
                            return best_id;
                        }, '_find_new_construction_site');},
                        get _find_new_repair_site () {return __get__ (this, function (self, creep, max_hits, max_work) {
                            if (typeof max_work == 'undefined' || (max_work != null && max_work .hasOwnProperty ("__kwargtrans__"))) {;
                                var max_work = _MAX_REPAIR_WORKFORCE;
                            };
                            var repair_targets = creep.home.building.get_repair_targets ();
                            if (!(len (repair_targets))) {
                                return null;
                            }
                            if (len (repair_targets) <= 1 && !(len (creep.home.building.get_construction_targets ()))) {
                                var max_work = Infinity;
                            }
                            var __iterable0__ = repair_targets;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var struct_id = __iterable0__ [__index0__];
                                var structure = Game.getObjectById (struct_id);
                                if (!(structure)) {
                                    continue;
                                }
                                var this_hits_max = min (structure.hitsMax, max_hits);
                                if (structure && structure.hits < this_hits_max * 0.9) {
                                    if (max_work === Infinity) {
                                        var current_max = Infinity;
                                    }
                                    else {
                                        var current_max = min (max_work, math.ceil ((this_hits_max - structure.hits) / 50));
                                    }
                                    var current_workforce = self.workforce_of (target_repair, struct_id);
                                    if (!(current_workforce) || current_workforce < current_max) {
                                        return struct_id;
                                    }
                                }
                            }
                            return null;
                        }, '_find_new_repair_site');},
                        get _find_new_big_repair_site () {return __get__ (this, function (self, creep, max_hits) {
                            var best_id = null;
                            var smallest_num = Infinity;
                            var smallest_hits = Infinity;
                            var __iterable0__ = creep.home.building.get_big_repair_targets ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var struct_id = __iterable0__ [__index0__];
                                var struct = Game.getObjectById (struct_id);
                                if (struct && struct.hits < struct.hitsMax && struct.hits < max_hits) {
                                    var struct_num = self.workforce_of (target_big_repair, struct_id);
                                    if (struct_num < smallest_num || struct_num == smallest_num && struct.hits < smallest_hits) {
                                        var smallest_num = struct_num;
                                        var smallest_hits = struct.hits;
                                        var best_id = struct_id;
                                    }
                                }
                            }
                            return best_id;
                        }, '_find_new_big_repair_site');},
                        get _find_new_big_big_repair_site () {return __get__ (this, function (self, creep) {
                            var best_id = null;
                            var smallest_num = Infinity;
                            var smallest_hits = Infinity;
                            var __iterable0__ = creep.home.building.get_big_repair_targets ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var struct_id = __iterable0__ [__index0__];
                                var struct = Game.getObjectById (struct_id);
                                if (struct && struct.hits < struct.hitsMax && (struct.structureType == STRUCTURE_WALL || struct.structureType == STRUCTURE_RAMPART)) {
                                    var struct_num = self.workforce_of (target_big_big_repair, struct_id);
                                    if (struct_num < smallest_num || struct_num == smallest_num && struct.hits < smallest_hits) {
                                        var smallest_num = struct_num;
                                        var smallest_hits = struct.hits;
                                        var best_id = struct_id;
                                    }
                                }
                            }
                            return best_id;
                        }, '_find_new_big_big_repair_site');},
                        get _find_new_destruction_site () {return __get__ (this, function (self, creep) {
                            var construct_count = {};
                            var __iterable0__ = creep.home.building.get_destruction_targets ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var struct_id = __iterable0__ [__index0__];
                                var struct = Game.getObjectById (struct_id);
                                if (struct) {
                                    var current_num = self.targets [target_destruction_site] [struct_id];
                                    if (!(current_num) || current_num < _MAX_BUILDERS) {
                                        if (!(struct.structureType in construct_count)) {
                                            construct_count [struct.structureType] = _.sum (creep.home.find (FIND_MY_CONSTRUCTION_SITES), (function __lambda__ (s) {
                                                return s.structureType == struct.structureType;
                                            }));
                                        }
                                        if (construct_count [struct.structureType] < 2) {
                                            return struct_id;
                                        }
                                    }
                                }
                            }
                        }, '_find_new_destruction_site');},
                        get _find_new_tower () {return __get__ (this, function (self, creep) {
                            var most_lacking = 0;
                            var best_id = null;
                            var __iterable0__ = creep.room.defense.towers ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var tower = __iterable0__ [__index0__];
                                if (tower.energy >= tower.energyCapacity * 0.9) {
                                    continue;
                                }
                                var carry_targeting = self.workforce_of (target_tower_fill, tower.id) * 25;
                                var tower_lacking = (tower.energyCapacity - tower.energy) - carry_targeting;
                                if (tower_lacking > most_lacking) {
                                    var most_lacking = tower_lacking;
                                    var best_id = tower.id;
                                }
                            }
                            return best_id;
                        }, '_find_new_tower');},
                        get _find_new_energy_miner_mine () {return __get__ (this, function (self, creep) {
                            var best_id = null;
                            var closest_flag = Infinity;
                            var __iterable0__ = creep.home.mining.available_mines;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                var flag_id = 'flag-{}'.format (flag.name);
                                var miners = self.targets [target_energy_miner_mine] [flag_id];
                                if (!(miners) || miners < 1) {
                                    var distance = movement.distance_squared_room_pos (flag.pos, creep.creep.pos);
                                    if (distance < closest_flag) {
                                        var closest_flag = distance;
                                        var best_id = flag_id;
                                    }
                                }
                            }
                            return best_id;
                        }, '_find_new_energy_miner_mine');},
                        get _find_new_energy_hauler_mine () {return __get__ (this, function (self, creep) {
                            var best_id = null;
                            var smallest_percentage = 1;
                            var __iterable0__ = creep.home.mining.active_mines;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                var flag_id = 'flag-{}'.format (flag.name);
                                if (!(creep.home.mining.haulers_can_target_mine (flag))) {
                                    continue;
                                }
                                var hauler_mass = self.workforce_of (target_energy_hauler_mine, flag_id);
                                var hauler_percentage = float (hauler_mass) / creep.home.mining.calculate_current_target_mass_for_mine (flag);
                                var too_long = creep.creep.ticksToLive < 2.2 * creep.home.mining.distance_to_mine (flag);
                                if (too_long) {
                                    if (hauler_percentage < 0.5) {
                                        hauler_percentage *= 2;
                                    }
                                    else {
                                        var hauler_percentage = 0.99;
                                    }
                                }
                                if (!(hauler_mass) || hauler_percentage < smallest_percentage) {
                                    var smallest_percentage = hauler_percentage;
                                    var best_id = flag_id;
                                }
                            }
                            return best_id;
                        }, '_find_new_energy_hauler_mine');},
                        get _find_closest_deposit_site () {return __get__ (this, function (self, creep, pos) {
                            if (!(pos)) {
                                var pos = creep.pos;
                            }
                            if (creep.home.full_storage_use) {
                                var best = creep.home.room.storage;
                                var best_priority = movement.chebyshev_distance_room_pos (pos, best.pos) - 13;
                                if (creep.home.links.enabled) {
                                    var __iterable0__ = creep.home.links.links;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var struct = __iterable0__ [__index0__];
                                        var priority = movement.chebyshev_distance_room_pos (pos, struct.pos);
                                        if (priority < best_priority) {
                                            var best = struct;
                                            var best_priority = priority;
                                        }
                                    }
                                }
                                return best.id;
                            }
                            else {
                                return null;
                            }
                        }, '_find_closest_deposit_site');},
                        get _find_top_priority_reservable_room () {return __get__ (this, function (self, creep) {
                            var closest_flag = null;
                            var closest_distance = Infinity;
                            var __iterable0__ = flags.find_flags_global (RESERVE_NOW);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                var room_name = flag.pos.roomName;
                                var room = Game.rooms [room_name];
                                if (!(room) || room.controller && !(room.controller.my) && !(room.controller.owner)) {
                                    var flag_id = 'flag-{}'.format (flag.name);
                                    var current_targets = self.targets [target_reserve_now] [flag_id];
                                    if (!(current_targets) || current_targets < 1) {
                                        var distance = movement.distance_squared_room_pos (creep.creep.pos, new RoomPosition (25, 25, room_name));
                                        if (distance < closest_distance) {
                                            var closest_distance = distance;
                                            var closest_flag = flag_id;
                                        }
                                    }
                                }
                            }
                            return closest_flag;
                        }, '_find_top_priority_reservable_room');},
                        get _find_new_defendable_wall () {return __get__ (this, function (self, creep) {
                            var __left0__ = creep.home.defense.get_current_defender_spots ();
                            var hot_spots = __left0__ [0];
                            var cold_spots = __left0__ [1];
                            var nearest = null;
                            var nearest_distance = Infinity;
                            var __iterable0__ = hot_spots;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var location = __iterable0__ [__index0__];
                                if (!(self.targets [target_rampart_defense] [location.name])) {
                                    var distance = movement.chebyshev_distance_room_pos (location, creep);
                                    if (distance < nearest_distance) {
                                        var nearest = location;
                                        var nearest_distance = distance;
                                    }
                                }
                            }
                            if (nearest === null) {
                                var __iterable0__ = cold_spots;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var location = __iterable0__ [__index0__];
                                    if (!(self.targets [target_rampart_defense] [location.name])) {
                                        var distance = movement.chebyshev_distance_room_pos (location, creep);
                                        if (distance < nearest_distance) {
                                            var nearest = location;
                                            var nearest_distance = distance;
                                        }
                                    }
                                }
                                if (nearest === null) {
                                    var __iterable0__ = creep.home.defense.get_old_defender_spots ();
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var location = __iterable0__ [__index0__];
                                        if (!(self.targets [target_rampart_defense] [location.name])) {
                                            var distance = movement.chebyshev_distance_room_pos (location, creep);
                                            if (distance < nearest_distance) {
                                                var nearest = location;
                                                var nearest_distance = distance;
                                            }
                                        }
                                    }
                                }
                            }
                            if (nearest) {
                                return nearest.name;
                            }
                            else {
                                return null;
                            }
                        }, '_find_new_defendable_wall');},
                        get _find_closest_flag () {return __get__ (this, function (self, creep, flag_type, pos) {
                            if (!(pos)) {
                                var pos = creep.pos;
                            }
                            else if (pos.pos) {
                                var pos = pos.pos;
                            }
                            var closest_flag = null;
                            var closest_distance = Infinity;
                            var __iterable0__ = flags.find_flags_global (flag_type);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                var flag_id = 'flag-{}'.format (flag.name);
                                var current = self.targets [target_single_flag] [flag_id];
                                if (!(current) || current < 1) {
                                    var distance = movement.distance_squared_room_pos (pos, flag.pos);
                                    if (distance < closest_distance) {
                                        var closest_distance = distance;
                                        var closest_flag = flag_id;
                                    }
                                }
                            }
                            return closest_flag;
                        }, '_find_closest_flag');},
                        get _find_closest_flag2 () {return __get__ (this, function (self, creep, flag_type, pos) {
                            if (!(pos)) {
                                var pos = creep.pos;
                            }
                            else if (pos.pos) {
                                var pos = pos.pos;
                            }
                            var closest_flag = null;
                            var closest_distance = Infinity;
                            var __iterable0__ = flags.find_flags_global (flag_type);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                var flag_id = 'flag-{}'.format (flag.name);
                                var current = self.targets [target_single_flag2] [flag_id];
                                if (!(current) || current < 1) {
                                    var distance = movement.distance_squared_room_pos (pos, flag.pos);
                                    if (distance < closest_distance) {
                                        var closest_distance = distance;
                                        var closest_flag = flag_id;
                                    }
                                }
                            }
                            return closest_flag;
                        }, '_find_closest_flag2');},
                        get _find_closest_home_flag () {return __get__ (this, function (self, creep, flag_type, pos) {
                            if (!(pos)) {
                                var pos = creep.pos;
                            }
                            else if (pos.pos) {
                                var pos = pos.pos;
                            }
                            var closest_flag = null;
                            var closest_distance = Infinity;
                            var __iterable0__ = flags.find_flags (creep.home, flag_type);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                var flag_id = 'flag-{}'.format (flag.name);
                                var current = self.targets [target_home_flag] [flag_id];
                                if (!(current) || current < 1) {
                                    var distance = movement.distance_squared_room_pos (pos, flag.pos);
                                    if (distance < closest_distance) {
                                        var closest_distance = distance;
                                        var closest_flag = flag_id;
                                    }
                                }
                            }
                            return closest_flag;
                        }, '_find_closest_home_flag');},
                        get _find_refill_target () {return __get__ (this, function (self, creep) {
                            var best_priority = Infinity;
                            var best_id = null;
                            var stealing_from = null;
                            var structures = _.filter (creep.home.find (FIND_MY_STRUCTURES), (function __lambda__ (s) {
                                return (s.structureType == STRUCTURE_EXTENSION || s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_CONTAINER || s.structureType == STRUCTURE_TOWER) && s.energy < s.energyCapacity;
                            }));
                            var creeps = _.filter (creep.home.creeps, (function __lambda__ (c) {
                                return (c.memory.role == role_upgrader || c.memory.role == role_builder) && c.carry.energy < c.carryCapacity;
                            }));
                            var extra = creep.home.get_extra_fill_targets ();
                            var __iterable0__ = structures.concat (extra).concat (creeps);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var structure = __iterable0__ [__index0__];
                                var structure_id = structure.id;
                                if (volatile_cache.mem ('extensions_filled').has (structure_id)) {
                                    continue;
                                }
                                var current_carry = self.workforce_of (target_spawn_deposit, structure_id) + self.workforce_of (target_refill, structure_id);
                                var empty = (structure.energyCapacity || structure.carryCapacity || structure.storeCapacity) - (structure.store && _.sum (structure.store.energy) || structure.carry && _.sum (structure.carry.energy) || structure.energy || 0);
                                var empty_percent = (empty / (structure.energyCapacity || structure.carryCapacity || structure.storeCapacity)) * 30;
                                if (empty <= 0 || empty <= 2 && !(structure.structureType)) {
                                    continue;
                                }
                                var distance = movement.chebyshev_distance_room_pos (structure.pos, creep.creep.pos);
                                var priority = distance - empty_percent;
                                if (structure.memory && !(structure.memory.filling)) {
                                    priority -= 15;
                                }
                                else if (structure.structureType == STRUCTURE_CONTAINER) {
                                    priority -= 40;
                                }
                                else if (structure.structureType) {
                                    priority -= 25;
                                }
                                if (priority < best_priority) {
                                    var max_work_mass = empty / 50;
                                    if (!(current_carry) || current_carry < max_work_mass) {
                                        var best_priority = priority;
                                        var best_id = structure_id;
                                        var stealing_from = null;
                                    }
                                    else {
                                        var targeting = self.reverse_targets [target_refill] [structure_id];
                                        if (len (targeting)) {
                                            var __iterable1__ = targeting;
                                            for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                                var name = __iterable1__ [__index1__];
                                                if (!(Game.creeps [name]) || movement.chebyshev_distance_room_pos (Game.creeps [name].pos, structure.pos) > distance * 1.5) {
                                                    var best_priority = priority;
                                                    var best_id = structure_id;
                                                    var stealing_from = name;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (stealing_from !== null) {
                                self._unregister_targeter (target_refill, stealing_from);
                            }
                            return best_id;
                        }, '_find_refill_target');}
                    });
                    Object.defineProperty (TargetMind, 'targets', property.call (TargetMind, TargetMind.__get_targets, TargetMind.__set_targets));;
                    Object.defineProperty (TargetMind, 'targeters', property.call (TargetMind, TargetMind.__get_targeters, TargetMind.__set_targeters));;
                    Object.defineProperty (TargetMind, 'targets_workforce', property.call (TargetMind, TargetMind.__get_targets_workforce, TargetMind.__set_targets_workforce));;
                    Object.defineProperty (TargetMind, 'reverse_targets', property.call (TargetMind, TargetMind.__get_reverse_targets, TargetMind.__set_reverse_targets));;
                    __pragma__ ('<use>' +
                        'cache.volatile_cache' +
                        'constants' +
                        'creep_management.spawning' +
                        'jstools.screeps_constants' +
                        'math' +
                        'position_management.flags' +
                        'position_management.locations' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.DEPOT = DEPOT;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.PYFIND_BUILDABLE_ROADS = PYFIND_BUILDABLE_ROADS;
                        __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
                        __all__.PYFIND_REPAIRABLE_ROADS = PYFIND_REPAIRABLE_ROADS;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.REROUTE = REROUTE;
                        __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
                        __all__.RESERVE_NOW = RESERVE_NOW;
                        __all__.SCOUT = SCOUT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SK_USERNAME = SK_USERNAME;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.TargetMind = TargetMind;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__._MAX_BUILDERS = _MAX_BUILDERS;
                        __all__._MAX_REPAIR_WORKFORCE = _MAX_REPAIR_WORKFORCE;
                        __all__._mass_count = _mass_count;
                        __all__.creep_base_1500miner = creep_base_1500miner;
                        __all__.creep_base_3000miner = creep_base_3000miner;
                        __all__.creep_base_3h = creep_base_3h;
                        __all__.creep_base_4000miner = creep_base_4000miner;
                        __all__.creep_base_carry3000miner = creep_base_carry3000miner;
                        __all__.creep_base_claim_attack = creep_base_claim_attack;
                        __all__.creep_base_claiming = creep_base_claiming;
                        __all__.creep_base_defender = creep_base_defender;
                        __all__.creep_base_dismantler = creep_base_dismantler;
                        __all__.creep_base_full_move_dismantler = creep_base_full_move_dismantler;
                        __all__.creep_base_full_move_goader = creep_base_full_move_goader;
                        __all__.creep_base_full_move_healer = creep_base_full_move_healer;
                        __all__.creep_base_full_move_power_attack = creep_base_full_move_power_attack;
                        __all__.creep_base_full_upgrader = creep_base_full_upgrader;
                        __all__.creep_base_goader = creep_base_goader;
                        __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
                        __all__.creep_base_half_move_healer = creep_base_half_move_healer;
                        __all__.creep_base_hauler = creep_base_hauler;
                        __all__.creep_base_mammoth_miner = creep_base_mammoth_miner;
                        __all__.creep_base_power_attack = creep_base_power_attack;
                        __all__.creep_base_rampart_defense = creep_base_rampart_defense;
                        __all__.creep_base_ranged_offense = creep_base_ranged_offense;
                        __all__.creep_base_reserving = creep_base_reserving;
                        __all__.creep_base_scout = creep_base_scout;
                        __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
                        __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
                        __all__.creep_base_worker = creep_base_worker;
                        __all__.default_roles = default_roles;
                        __all__.flags = flags;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.gmem_key_last_room_state_refresh = gmem_key_last_room_state_refresh;
                        __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
                        __all__.locations = locations;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
                        __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
                        __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.old_role_names = old_role_names;
                        __all__.recycle_time = recycle_time;
                        __all__.request_priority_economy = request_priority_economy;
                        __all__.request_priority_helping_party = request_priority_helping_party;
                        __all__.request_priority_imminent_threat_defense = request_priority_imminent_threat_defense;
                        __all__.request_priority_low = request_priority_low;
                        __all__.rmem_key_building_paused = rmem_key_building_paused;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.rmem_key_cache = rmem_key_cache;
                        __all__.rmem_key_carry_parts_by_role = rmem_key_carry_parts_by_role;
                        __all__.rmem_key_creeps_by_role = rmem_key_creeps_by_role;
                        __all__.rmem_key_creeps_by_role_and_replacement_time = rmem_key_creeps_by_role_and_replacement_time;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                        __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
                        __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
                        __all__.rmem_key_flag_for_testing_spawning_in_simulation = rmem_key_flag_for_testing_spawning_in_simulation;
                        __all__.rmem_key_focusing_home = rmem_key_focusing_home;
                        __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
                        __all__.rmem_key_metadata = rmem_key_metadata;
                        __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
                        __all__.rmem_key_now_supporting = rmem_key_now_supporting;
                        __all__.rmem_key_pause_all_room_operations = rmem_key_pause_all_room_operations;
                        __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
                        __all__.rmem_key_prepping_defenses = rmem_key_prepping_defenses;
                        __all__.rmem_key_remotes_explicitly_marked_under_attack = rmem_key_remotes_explicitly_marked_under_attack;
                        __all__.rmem_key_remotes_safe_when_under_siege = rmem_key_remotes_safe_when_under_siege;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.rmem_key_spawn_requests = rmem_key_spawn_requests;
                        __all__.rmem_key_sponsor = rmem_key_sponsor;
                        __all__.rmem_key_storage_use_enabled = rmem_key_storage_use_enabled;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
                        __all__.rmem_key_total_open_source_spaces = rmem_key_total_open_source_spaces;
                        __all__.rmem_key_upgrading_paused = rmem_key_upgrading_paused;
                        __all__.rmem_key_work_parts_by_role = rmem_key_work_parts_by_role;
                        __all__.role_bases = role_bases;
                        __all__.role_builder = role_builder;
                        __all__.role_cleanup = role_cleanup;
                        __all__.role_colonist = role_colonist;
                        __all__.role_defender = role_defender;
                        __all__.role_energy_grab = role_energy_grab;
                        __all__.role_hauler = role_hauler;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_miner = role_miner;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.role_mineral_miner = role_mineral_miner;
                        __all__.role_mineral_steal = role_mineral_steal;
                        __all__.role_power_attack = role_power_attack;
                        __all__.role_power_cleanup = role_power_cleanup;
                        __all__.role_ranged_offense = role_ranged_offense;
                        __all__.role_recycling = role_recycling;
                        __all__.role_remote_mining_reserve = role_remote_mining_reserve;
                        __all__.role_room_reserve = role_room_reserve;
                        __all__.role_scout = role_scout;
                        __all__.role_simple_claim = role_simple_claim;
                        __all__.role_simple_dismantle = role_simple_dismantle;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_spawn_fill_backup = role_spawn_fill_backup;
                        __all__.role_td_goad = role_td_goad;
                        __all__.role_td_healer = role_td_healer;
                        __all__.role_temporary_replacing = role_temporary_replacing;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.role_tower_fill_once = role_tower_fill_once;
                        __all__.role_upgrade_fill = role_upgrade_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.role_wall_defender = role_wall_defender;
                        __all__.spawning = spawning;
                        __all__.target_big_big_repair = target_big_big_repair;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_construction = target_construction;
                        __all__.target_destruction_site = target_destruction_site;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                        __all__.target_home_flag = target_home_flag;
                        __all__.target_rampart_defense = target_rampart_defense;
                        __all__.target_refill = target_refill;
                        __all__.target_repair = target_repair;
                        __all__.target_reserve_now = target_reserve_now;
                        __all__.target_single_flag = target_single_flag;
                        __all__.target_single_flag2 = target_single_flag2;
                        __all__.target_source = target_source;
                        __all__.target_spawn_deposit = target_spawn_deposit;
                        __all__.target_tower_fill = target_tower_fill;
                        __all__.update_targeters_memory_0_to_1 = update_targeters_memory_0_to_1;
                        __all__.volatile_cache = volatile_cache;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'jstools.errorlog', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var report_error = function (place, err, description) {
                        if (err == undefined) {
                            if (err === null) {
                                var err_description = 'null error';
                            }
                            else if (err === undefined) {
                                var err_description = 'undefined error';
                            }
                            else {
                                var err_description = err + ' error';
                            }
                        }
                        else if (err.stack == undefined) {
                            var err_description = 'error has undefined stack: {}'.format (err);
                        }
                        else {
                            var err_description = "error '{}' has stack:\n{}".format (err, err.stack);
                        }
                        var msg = '[{}][{}] Error: {}\n{}'.format (place, Game.time, description, err_description);
                        print (msg);
                        Game.notify (msg);
                        if (err == undefined) {
                            throw err;
                        }
                    };
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.report_error = report_error;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'jstools.memory_info', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var _path_cached_data_key_full_path = __init__ (__world__.empire.honey)._path_cached_data_key_full_path;
                    var _path_cached_data_key_length = __init__ (__world__.empire.honey)._path_cached_data_key_length;
                    var _path_cached_data_key_metadata = __init__ (__world__.empire.honey)._path_cached_data_key_metadata;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var analyse_memory = function (path) {
                        if (typeof path == 'undefined' || (path != null && path .hasOwnProperty ("__kwargtrans__"))) {;
                            var path = null;
                        };
                        var mem = Memory;
                        if (path !== null) {
                            var mem = _.get (mem, path);
                        }
                        var __iterable0__ = _.pairs (mem);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var __left0__ = __iterable0__ [__index0__];
                            var key = __left0__ [0];
                            var submem = __left0__ [1];
                            var amount = count_total_keys (submem);
                            print ('Under {}: {}'.format (key, amount));
                        }
                    };
                    var count_total_keys = function (mem) {
                        var total_count = 0;
                        var __iterable0__ = _.pairs (mem);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var __left0__ = __iterable0__ [__index0__];
                            var key = __left0__ [0];
                            var submem = __left0__ [1];
                            total_count++;
                            if (_.isObject (submem)) {
                                total_count += count_total_keys (submem);
                            }
                        }
                        return total_count;
                    };
                    var cache_stats = function () {
                        var total_path_v1 = 0;
                        var total_path_v2 = 0;
                        var total_path_v3 = 0;
                        var total_path_other = 0;
                        var total_cost_matrix = 0;
                        var total_other = 0;
                        var __iterable0__ = Object.keys (Memory.cache);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var key = __iterable0__ [__index0__];
                            if (key.startswith ('path_')) {
                                var value = Memory.cache [key];
                                if ((_path_cached_data_key_full_path in value)) {
                                    total_path_v1++;
                                }
                                else if ((_path_cached_data_key_length in value)) {
                                    total_path_v2++;
                                }
                                else if ((_path_cached_data_key_metadata in value)) {
                                    total_path_v3++;
                                }
                                else {
                                    total_path_other++;
                                }
                            }
                            else if (key.includes ('cost_matrix')) {
                                total_cost_matrix++;
                            }
                            else {
                                total_other++;
                            }
                        }
                        var result = ['Cache Stats:'];
                        if (total_path_v1 > 0) {
                            result.append ('Version 1 Paths: {}'.format (total_path_v1));
                        }
                        if (total_path_v2 > 0) {
                            result.append ('Version 2 Paths: {}'.format (total_path_v2));
                        }
                        if (total_path_v3 > 0) {
                            result.append ('Version 2 Paths: {}'.format (total_path_v3));
                        }
                        if (total_path_other > 0) {
                            result.append ('Other Paths: {}'.format (total_path_other));
                        }
                        if (total_cost_matrix > 0) {
                            result.append ('Cost Matrices: {}'.format (total_cost_matrix));
                        }
                        if (total_other > 0) {
                            result.append ('Other: {}'.format (total_other));
                        }
                        return '\n'.join (result);
                    };
                    __pragma__ ('<use>' +
                        'empire.honey' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__._path_cached_data_key_full_path = _path_cached_data_key_full_path;
                        __all__._path_cached_data_key_length = _path_cached_data_key_length;
                        __all__._path_cached_data_key_metadata = _path_cached_data_key_metadata;
                        __all__.analyse_memory = analyse_memory;
                        __all__.cache_stats = cache_stats;
                        __all__.count_total_keys = count_total_keys;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'jstools.records', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var _recording_now = false;
                    var _sub_recording_now = false;
                    var _single_record_start = null;
                    var _sub_record_start = null;
                    var _main_loop_record_start = null;
                    var _averages = null;
                    var _sub_records = null;
                    var prep_recording = function () {
                        _averages = Memory ['_averages'];
                        if (!(_averages)) {
                            var __left0__ = {};
                            _averages = __left0__;
                            Memory ['_averages'] = __left0__;
                        }
                        _recording_now = !(!(_averages ['_recording_now']));
                        _sub_recording_now = _averages ['_sub_recording_now'] || false;
                        if (_sub_recording_now) {
                            _sub_records = _averages ['_sub_records'];
                            if (!(_sub_records)) {
                                var __left0__ = {};
                                _sub_records = __left0__;
                                _averages ['_sub_records'] = __left0__;
                            }
                        }
                    };
                    var start_recording = function () {
                        Memory ['_averages'] ['_recording_now'] = true;
                    };
                    var stop_recording = function () {
                        Memory ['_averages'] ['_recording_now'] = false;
                        Memory ['_sub_recording_now'] = false;
                    };
                    var start_sub_recording = function () {
                        Memory ['_averages'] ['_sub_recording_now'] = true;
                        Memory ['_averages'] ['_recording_now'] = true;
                    };
                    var reset_records = function () {
                        Memory ['_averages'] = {};
                    };
                    var start_record = function () {
                        if (_recording_now) {
                            _single_record_start = Game.cpu.getUsed ();
                        }
                    };
                    var finish_record = function (identity) {
                        if (_recording_now && _single_record_start !== null) {
                            var end = Game.cpu.getUsed ();
                            if ((identity in _averages)) {
                                _averages [identity].calls++;
                                _averages [identity].time += end - _single_record_start;
                            }
                            else {
                                _averages [identity] = {'calls': 1, 'time': end - _single_record_start};
                            }
                        }
                    };
                    var start_sub_record = function () {
                        if (_sub_recording_now) {
                            _sub_record_start = Game.cpu.getUsed ();
                        }
                    };
                    var finish_sub_record = function (identity) {
                        if (_sub_recording_now && _sub_record_start !== null) {
                            var end = Game.cpu.getUsed ();
                            if ((identity in _sub_records)) {
                                _sub_records [identity].calls++;
                                _sub_records [identity].time += end - _sub_record_start;
                            }
                            else {
                                _sub_records [identity] = {'calls': 1, 'time': end - _sub_record_start};
                            }
                            _sub_record_start = null;
                        }
                    };
                    var start_main_record = function () {
                        if (_recording_now) {
                            _main_loop_record_start = Game.cpu.getUsed ();
                        }
                    };
                    var finish_main_record = function () {
                        if (_recording_now && _main_loop_record_start !== null) {
                            var end = Game.cpu.getUsed ();
                            if (('_main' in _averages)) {
                                _averages ['_main'] += end - _main_loop_record_start;
                            }
                            else {
                                _averages ['_main'] = end - _main_loop_record_start;
                            }
                            if (('_total' in _averages)) {
                                _averages ['_total'] += end;
                            }
                            else {
                                _averages ['_total'] = end;
                            }
                            if (('_ticks' in _averages)) {
                                _averages ['_ticks']++;
                            }
                            else {
                                _averages ['_ticks'] = 1;
                            }
                            if (_sub_recording_now) {
                                if (('_ticks' in _sub_records)) {
                                    _sub_records ['_ticks']++;
                                }
                                else {
                                    _sub_records ['_ticks'] = 1;
                                }
                            }
                        }
                    };
                    var record_memory_amount = function (time) {
                        if (_recording_now) {
                            if (('memory.init' in _averages)) {
                                _averages ['memory.init'].calls++;
                                _averages ['memory.init'].time += time;
                            }
                            else {
                                _averages ['memory.init'] = {'calls': 1, 'time': time};
                            }
                        }
                    };
                    var record_compile_amount = function (time) {
                        if (_recording_now) {
                            if (('code.compile' in _averages)) {
                                _averages ['code.compile'].calls++;
                                _averages ['code.compile'].time += time;
                            }
                            else {
                                _averages ['code.compile'] = {'calls': 1, 'time': time};
                            }
                        }
                    };
                    var display_num = function (num, val) {
                        if (typeof val == 'undefined' || (val != null && val .hasOwnProperty ("__kwargtrans__"))) {;
                            var val = 2;
                        };
                        return num.toFixed (val);
                    };
                    var output_records_full = function () {
                        var rows = ['time\tcalls\ttime/t\tcalls/t\taverage\tname'];
                        var total_time_in_records = 0;
                        var __iterable0__ = _ (_averages).pairs ().sortBy ((function __lambda__ (t) {
                            return -(t [1].time);
                        })).value ();
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var __left0__ = __iterable0__ [__index0__];
                            var identity = __left0__ [0];
                            var obj = __left0__ [1];
                            if (identity.startswith ('_')) {
                                continue;
                            }
                            if (identity != 'memory.init' && identity != 'code.compile') {
                                total_time_in_records += obj.time;
                            }
                            rows.push ('\n{}\t{}\t{}\t{}\t{}\t{}'.format (display_num (obj.time), display_num (obj.calls, 1), display_num (obj.time / _averages ['_ticks']), display_num (obj.calls / _averages ['_ticks']), display_num (obj.time / obj.calls), identity));
                        }
                        var missing_time = _averages ['_main'] - total_time_in_records;
                        rows.push ('\n{}\t{}\t{}\t{}\t{}\t{}'.format (display_num (missing_time), display_num (_averages ['_ticks']), display_num (missing_time / _averages ['_ticks']), display_num (1), display_num (missing_time / _averages ['_ticks']), 'unprofiled'));
                        rows.push ('\n{}\t{}\t{}\t{}\t{}\t{}'.format (display_num (_averages ['_main']), display_num (_averages ['_ticks']), display_num (_averages ['_main'] / _averages ['_ticks']), display_num (1), display_num (_averages ['_main'] / _averages ['_ticks']), 'total.main_loop'));
                        var compile_time = (_averages ['_total'] - _averages ['_main']) - _averages ['memory.init'];
                        rows.push ('\n{}\t{}\t{}\t{}\t{}\t{}'.format (display_num (compile_time), display_num (_averages ['_ticks']), display_num (compile_time / _averages ['_ticks']), display_num (1), display_num (compile_time / _averages ['_ticks']), 'total.compile'.format (Game.cpu.limit)));
                        rows.push ('\n{}\t{}\t{}\t{}\t{}\t{}'.format (display_num (_averages ['_total']), display_num (_averages ['_ticks']), display_num (_averages ['_total'] / _averages ['_ticks']), display_num (1), display_num (_averages ['_total'] / _averages ['_ticks']), 'total (limit: {})'.format (Game.cpu.limit)));
                        return ''.join (rows);
                    };
                    var output_records = function () {
                        if (!(_averages ['_ticks'])) {
                            return 'no data collected';
                        }
                        var rows = ['time/t\tcalls/t\taverage\tname'];
                        var total_time_in_records = 0;
                        var __iterable0__ = _ (_averages).pairs ().sortBy ((function __lambda__ (t) {
                            return -(t [1].time);
                        })).value ();
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var __left0__ = __iterable0__ [__index0__];
                            var identity = __left0__ [0];
                            var obj = __left0__ [1];
                            if (identity.startswith ('_')) {
                                continue;
                            }
                            if (identity != 'memory.init' && identity != 'code.compile') {
                                total_time_in_records += obj.time;
                            }
                            rows.push ('\n{}\t{}\t{}\t{}'.format (display_num (obj.time / _averages ['_ticks']), display_num (obj.calls / _averages ['_ticks'], 1), display_num (obj.time / obj.calls), identity));
                        }
                        var missing_time = _averages ['_main'] - total_time_in_records;
                        rows.push ('\n{}\t{}\t{}\t{}'.format (display_num (missing_time / _averages ['_ticks']), display_num (1, 1), display_num (missing_time / _averages ['_ticks']), 'unprofiled'));
                        rows.push ('\n{}\t{}\t{}\t{}'.format (display_num (_averages ['_main'] / _averages ['_ticks']), display_num (1, 1), display_num (_averages ['_main'] / _averages ['_ticks']), 'total.main_loop'.format (Game.cpu.limit)));
                        var compile_time = (_averages ['_total'] - _averages ['_main']) - _averages ['memory.init'].time;
                        rows.push ('\n{}\t{}\t{}\t{}'.format (display_num (compile_time / _averages ['_ticks']), display_num (1, 1), display_num (compile_time / _averages ['_ticks']), 'total.compile'.format (Game.cpu.limit)));
                        rows.push ('\n{}\t{}\t{}\t{}'.format (display_num (_averages ['_total'] / _averages ['_ticks']), display_num (1, 1), display_num (_averages ['_total'] / _averages ['_ticks']), 'total (limit: {})'.format (Game.cpu.limit)));
                        return ''.join (rows);
                    };
                    var output_sub_records = function () {
                        if (!(_sub_records ['_ticks'])) {
                            return 'no data collected';
                        }
                        var rows = ['time/t\tcalls/t\taverage\tname'];
                        var total_time_in_records = 0;
                        var __iterable0__ = _ (_sub_records).pairs ().sortBy ((function __lambda__ (t) {
                            return -(t [1].time);
                        })).value ();
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var __left0__ = __iterable0__ [__index0__];
                            var identity = __left0__ [0];
                            var obj = __left0__ [1];
                            if (identity.startswith ('_')) {
                                continue;
                            }
                            if (identity != 'memory.init' && identity != 'code.compile') {
                                total_time_in_records += obj.time;
                            }
                            rows.push ('\n{}\t{}\t{}\t{}'.format (display_num (obj.time / _sub_records ['_ticks']), display_num (obj.calls / _sub_records ['_ticks'], 1), display_num (obj.time / obj.calls), identity));
                        }
                        return ''.join (rows);
                    };
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__._averages = _averages;
                        __all__._main_loop_record_start = _main_loop_record_start;
                        __all__._recording_now = _recording_now;
                        __all__._single_record_start = _single_record_start;
                        __all__._sub_record_start = _sub_record_start;
                        __all__._sub_recording_now = _sub_recording_now;
                        __all__._sub_records = _sub_records;
                        __all__.display_num = display_num;
                        __all__.finish_main_record = finish_main_record;
                        __all__.finish_record = finish_record;
                        __all__.finish_sub_record = finish_sub_record;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.output_records = output_records;
                        __all__.output_records_full = output_records_full;
                        __all__.output_sub_records = output_sub_records;
                        __all__.prep_recording = prep_recording;
                        __all__.record_compile_amount = record_compile_amount;
                        __all__.record_memory_amount = record_memory_amount;
                        __all__.reset_records = reset_records;
                        __all__.start_main_record = start_main_record;
                        __all__.start_record = start_record;
                        __all__.start_recording = start_recording;
                        __all__.start_sub_record = start_sub_record;
                        __all__.start_sub_recording = start_sub_recording;
                        __all__.stop_recording = stop_recording;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'jstools.screeps_constants', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = function (iterable) {
                        if (typeof iterable == 'undefined' || (iterable != null && iterable .hasOwnProperty ("__kwargtrans__"))) {;
                            var iterable = undefined;
                        };
                        return new Map (iterable);
                    };
                    var new_set = function (iterable) {
                        if (typeof iterable == 'undefined' || (iterable != null && iterable .hasOwnProperty ("__kwargtrans__"))) {;
                            var iterable = undefined;
                        };
                        return new Set (iterable);
                    };
                    __pragma__ ('<all>')
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'math', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var pi = Math.PI;
                    var e = Math.E;
                    var exp = Math.exp;
                    var expm1 = function (x) {
                        return Math.exp (x) - 1;
                    };
                    var log = function (x, base) {
                        return (base === undefined ? Math.log (x) : Math.log (x) / Math.log (base));
                    };
                    var log1p = function (x) {
                        return Math.log (x + 1);
                    };
                    var log2 = function (x) {
                        return Math.log (x) / Math.LN2;
                    };
                    var log10 = function (x) {
                        return Math.log (x) / Math.LN10;
                    };
                    var pow = Math.pow;
                    var sqrt = Math.sqrt;
                    var sin = Math.sin;
                    var cos = Math.cos;
                    var tan = Math.tan;
                    var asin = Math.asin;
                    var acos = Math.acos;
                    var atan = Math.atan;
                    var atan2 = Math.atan2;
                    var hypot = Math.hypot;
                    var degrees = function (x) {
                        return (x * 180) / Math.PI;
                    };
                    var radians = function (x) {
                        return (x * Math.PI) / 180;
                    };
                    var sinh = Math.sinh;
                    var cosh = Math.cosh;
                    var tanh = Math.tanh;
                    var asinh = Math.asinh;
                    var acosh = Math.acosh;
                    var atanh = Math.atanh;
                    var floor = Math.floor;
                    var ceil = Math.ceil;
                    var trunc = Math.trunc;
                    var isnan = isNaN;
                    var inf = Infinity;
                    var nan = NaN;
                    __pragma__ ('<all>')
                        __all__.acos = acos;
                        __all__.acosh = acosh;
                        __all__.asin = asin;
                        __all__.asinh = asinh;
                        __all__.atan = atan;
                        __all__.atan2 = atan2;
                        __all__.atanh = atanh;
                        __all__.ceil = ceil;
                        __all__.cos = cos;
                        __all__.cosh = cosh;
                        __all__.degrees = degrees;
                        __all__.e = e;
                        __all__.exp = exp;
                        __all__.expm1 = expm1;
                        __all__.floor = floor;
                        __all__.hypot = hypot;
                        __all__.inf = inf;
                        __all__.isnan = isnan;
                        __all__.log = log;
                        __all__.log10 = log10;
                        __all__.log1p = log1p;
                        __all__.log2 = log2;
                        __all__.nan = nan;
                        __all__.pi = pi;
                        __all__.pow = pow;
                        __all__.radians = radians;
                        __all__.sin = sin;
                        __all__.sinh = sinh;
                        __all__.sqrt = sqrt;
                        __all__.tan = tan;
                        __all__.tanh = tanh;
                        __all__.trunc = trunc;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'position_management.flags', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
                    var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
                    var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
                    var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var REROUTE = __init__ (__world__.constants).REROUTE;
                    var REROUTE_DESTINATION = __init__ (__world__.constants).REROUTE_DESTINATION;
                    var RESERVE_NOW = __init__ (__world__.constants).RESERVE_NOW;
                    var SCOUT = __init__ (__world__.constants).SCOUT;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
                    var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
                    var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
                    var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
                    var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var naming = __init__ (__world__.utilities.naming);
                    var MAIN_BUILD = 100;
                    var MAIN_DESTRUCT = 101;
                    var SUB_RAMPART = 110;
                    var SUB_SPAWN = 111;
                    var SUB_EXTENSION = 112;
                    var SUB_TOWER = 113;
                    var SUB_STORAGE = 114;
                    var SUB_LINK = 115;
                    var SUB_EXTRACTOR = 116;
                    var SUB_TERMINAL = 117;
                    var SUB_WALL = 120;
                    var SUB_ROAD = 121;
                    var SUB_CONTAINER = 122;
                    var flag_definitions = {[LOCAL_MINE]: [COLOR_BLUE, COLOR_PURPLE], [DEPOT]: [COLOR_BLUE, COLOR_BLUE], [SPAWN_FILL_WAIT]: [COLOR_BLUE, COLOR_CYAN], [UPGRADER_SPOT]: [COLOR_BLUE, COLOR_GREEN], [SLIGHTLY_AVOID]: [COLOR_BLUE, COLOR_GREY], [SK_LAIR_SOURCE_NOTED]: [COLOR_BLUE, COLOR_WHITE], [TD_H_H_STOP]: [COLOR_CYAN, COLOR_RED], [TD_H_D_STOP]: [COLOR_CYAN, COLOR_PURPLE], [TD_D_GOAD]: [COLOR_CYAN, COLOR_BLUE], [ATTACK_DISMANTLE]: [COLOR_CYAN, COLOR_GREEN], [RAID_OVER]: [COLOR_CYAN, COLOR_YELLOW], [ENERGY_GRAB]: [COLOR_CYAN, COLOR_ORANGE], [SCOUT]: [COLOR_CYAN, COLOR_BROWN], [RANGED_DEFENSE]: [COLOR_CYAN, COLOR_CYAN], [ATTACK_POWER_BANK]: [COLOR_CYAN, COLOR_GREY], [REAP_POWER_BANK]: [COLOR_CYAN, COLOR_WHITE], [REMOTE_MINE]: [COLOR_GREEN, COLOR_CYAN], [CLAIM_LATER]: [COLOR_GREEN, COLOR_PURPLE], [RESERVE_NOW]: [COLOR_GREEN, COLOR_GREY], [RAMPART_DEFENSE]: [COLOR_GREEN, COLOR_GREEN], [REROUTE]: [COLOR_WHITE, COLOR_GREEN], [REROUTE_DESTINATION]: [COLOR_WHITE, COLOR_YELLOW]};
                    var main_to_flag_primary = {[MAIN_DESTRUCT]: COLOR_RED, [MAIN_BUILD]: COLOR_PURPLE};
                    var sub_to_flag_secondary = {[SUB_WALL]: COLOR_RED, [SUB_RAMPART]: COLOR_PURPLE, [SUB_EXTENSION]: COLOR_BLUE, [SUB_SPAWN]: COLOR_CYAN, [SUB_TOWER]: COLOR_GREEN, [SUB_STORAGE]: COLOR_YELLOW, [SUB_LINK]: COLOR_ORANGE, [SUB_EXTRACTOR]: COLOR_BROWN, [SUB_CONTAINER]: COLOR_BROWN, [SUB_ROAD]: COLOR_WHITE, [SUB_TERMINAL]: COLOR_GREY};
                    var flag_secondary_to_sub = {[COLOR_RED]: SUB_WALL, [COLOR_PURPLE]: SUB_RAMPART, [COLOR_BLUE]: SUB_EXTENSION, [COLOR_CYAN]: SUB_SPAWN, [COLOR_GREEN]: SUB_TOWER, [COLOR_YELLOW]: SUB_STORAGE, [COLOR_ORANGE]: SUB_LINK, [COLOR_BROWN]: SUB_EXTRACTOR, [COLOR_GREY]: SUB_TERMINAL, [COLOR_WHITE]: SUB_ROAD};
                    var flag_sub_to_structure_type = {[SUB_SPAWN]: STRUCTURE_SPAWN, [SUB_EXTENSION]: STRUCTURE_EXTENSION, [SUB_RAMPART]: STRUCTURE_RAMPART, [SUB_WALL]: STRUCTURE_WALL, [SUB_STORAGE]: STRUCTURE_STORAGE, [SUB_TOWER]: STRUCTURE_TOWER, [SUB_LINK]: STRUCTURE_LINK, [SUB_EXTRACTOR]: STRUCTURE_EXTRACTOR, [SUB_CONTAINER]: STRUCTURE_CONTAINER, [SUB_ROAD]: STRUCTURE_ROAD, [SUB_TERMINAL]: STRUCTURE_TERMINAL};
                    var structure_type_to_flag_sub = {[STRUCTURE_SPAWN]: SUB_SPAWN, [STRUCTURE_EXTENSION]: SUB_EXTENSION, [STRUCTURE_RAMPART]: SUB_RAMPART, [STRUCTURE_WALL]: SUB_WALL, [STRUCTURE_STORAGE]: SUB_STORAGE, [STRUCTURE_TOWER]: SUB_TOWER, [STRUCTURE_LINK]: SUB_LINK, [STRUCTURE_EXTRACTOR]: SUB_EXTRACTOR, [STRUCTURE_CONTAINER]: SUB_CONTAINER, [STRUCTURE_ROAD]: SUB_ROAD, [STRUCTURE_TERMINAL]: SUB_TERMINAL};
                    var _REFRESH_EVERY = 50;
                    var _last_flag_len = 0;
                    var _last_checked_flag_len = 0;
                    var refresh_flag_caches = function () {
                        var refresh_time = Game.time + _REFRESH_EVERY;
                        _room_flag_cache = new_map ();
                        _room_flag_refresh_time = refresh_time;
                        _global_flag_cache = new_map ();
                        _global_flag_refresh_time = refresh_time;
                        _closest_flag_cache = new_map ();
                        _closest_flag_refresh_time = refresh_time;
                        _last_flag_len = _.size (Game.flags);
                    };
                    var __check_new_flags = function () {
                        if (_last_checked_flag_len < Game.time) {
                            var length = _.size (Game.flags);
                            if (_last_flag_len != length) {
                                refresh_flag_caches ();
                            }
                        }
                    };
                    var move_flags = function () {
                        if (Memory.flags_to_move) {
                            var __iterable0__ = Memory.flags_to_move;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var name = __left0__ [0];
                                var pos = __left0__ [1];
                                var pos = new RoomPosition (pos.x, pos.y, pos.roomName);
                                var result = Game.flags [name].setPosition (pos);
                                print ('[flags] Moving flag {} to {}. Result: {}'.format (name, pos, result));
                            }
                            delete Memory.flags_to_move;
                        }
                    };
                    var is_def = function (flag, flag_type) {
                        var flag_def = flag_definitions [flag_type];
                        return flag.color == flag_def [0] && flag.secondaryColor == flag_def [1];
                    };
                    var _room_flag_cache = new_map ();
                    var _room_flag_refresh_time = Game.time + _REFRESH_EVERY;
                    var __get_room_and_name = function (room) {
                        if (room.room) {
                            var room = room.room;
                        }
                        if (room.name) {
                            return [room, room.name];
                        }
                        else {
                            return [Game.rooms [room], room];
                        }
                    };
                    var __get_cache = function (room_name, flag_type) {
                        __check_new_flags ();
                        if (Game.time > _room_flag_refresh_time) {
                            _room_flag_refresh_time = Game.time + _REFRESH_EVERY;
                            _room_flag_cache = new_map ();
                        }
                        if (_room_flag_cache.has (room_name) && _room_flag_cache.get (room_name).has (flag_type)) {
                            return _room_flag_cache.get (room_name).get (flag_type);
                        }
                        else {
                            return null;
                        }
                    };
                    var find_flags = function (room, flag_type) {
                        var __left0__ = __get_room_and_name (room);
                        var room = __left0__ [0];
                        var room_name = __left0__ [1];
                        var cached = __get_cache (room_name, flag_type);
                        if (cached) {
                            return cached;
                        }
                        var flag_def = flag_definitions [flag_type];
                        if (room) {
                            var flag_list = room.find (FIND_FLAGS, {'filter': {'color': flag_def [0], 'secondaryColor': flag_def [1]}});
                        }
                        else {
                            var flag_list = [];
                            var __iterable0__ = Object.keys (Game.flags);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag_name = __iterable0__ [__index0__];
                                var flag = Game.flags [flag_name];
                                if (flag.pos.roomName == room_name && flag.color == flag_def [0] && flag.secondaryColor == flag_def [1]) {
                                    flag_list.append (flag);
                                }
                            }
                        }
                        if (_room_flag_cache.has (room_name)) {
                            _room_flag_cache.get (room_name).set (flag_type, flag_list);
                        }
                        else {
                            _room_flag_cache.set (room_name, new_map ([[flag_type, flag_list]]));
                        }
                        return flag_list;
                    };
                    var find_by_main_with_sub = function (room, main_type) {
                        var __left0__ = __get_room_and_name (room);
                        var room = __left0__ [0];
                        var room_name = __left0__ [1];
                        var cached = __get_cache (room_name, main_type);
                        if (cached) {
                            return cached;
                        }
                        var flag_primary = main_to_flag_primary [main_type];
                        if (room) {
                            var flag_list = [];
                            var __iterable0__ = room.find (FIND_FLAGS, {'filter': {'color': flag_primary}});
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                flag_list.append ([flag, flag_secondary_to_sub [flag.secondaryColor]]);
                            }
                        }
                        else {
                            var flag_list = [];
                            var __iterable0__ = Object.keys (Game.flags);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var name = __iterable0__ [__index0__];
                                var flag = Game.flags [name];
                                if (flag.pos.roomName == room_name && flag.color == flag_primary) {
                                    var secondary = flag_secondary_to_sub [flag.secondaryColor];
                                    if (secondary) {
                                        flag_list.append ([flag, secondary]);
                                    }
                                }
                            }
                        }
                        if (_room_flag_cache.has (room_name)) {
                            _room_flag_cache.get (room_name).set (main_type, flag_list);
                        }
                        else {
                            _room_flag_cache.set (room_name, new_map ([[main_type, flag_list]]));
                        }
                        return flag_list;
                    };
                    var find_ms_flags = function (room, main_type, sub_type) {
                        var type_name = '{}_{}'.format (main_type, sub_type);
                        var __left0__ = __get_room_and_name (room);
                        var room = __left0__ [0];
                        var room_name = __left0__ [1];
                        var cached = __get_cache (room_name, '{}_{}'.format (main_type, sub_type));
                        if (cached) {
                            return cached;
                        }
                        var primary = main_to_flag_primary [main_type];
                        var secondary = sub_to_flag_secondary [sub_type];
                        if (room) {
                            var flag_list = room.find (FIND_FLAGS, {'filter': {'color': primary, 'secondaryColor': secondary}});
                        }
                        else {
                            var flag_list = [];
                            var __iterable0__ = Object.keys (Game.flags);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag_name = __iterable0__ [__index0__];
                                var flag = Game.flags [flag_name];
                                if (flag.pos.roomName == room_name && flag.color == primary && flag.secondaryColor == secondary) {
                                    flag_list.append (flag);
                                }
                            }
                        }
                        if (_room_flag_cache.has (room_name)) {
                            _room_flag_cache.get (room_name).set (type_name, flag_list);
                        }
                        else {
                            _room_flag_cache.set (room_name, new_map ([[type_name, flag_list]]));
                        }
                        return flag_list;
                    };
                    var _global_flag_cache = new_map ();
                    var _global_flag_refresh_time = Game.time + _REFRESH_EVERY;
                    var find_flags_global = function (flag_type, reload) {
                        if (typeof reload == 'undefined' || (reload != null && reload .hasOwnProperty ("__kwargtrans__"))) {;
                            var reload = false;
                        };
                        __check_new_flags ();
                        if (Game.time > _global_flag_refresh_time) {
                            _global_flag_refresh_time = Game.time + _REFRESH_EVERY;
                            _global_flag_cache = new_map ();
                        }
                        if (_global_flag_cache.has (flag_type) && !(reload)) {
                            return _global_flag_cache.get (flag_type);
                        }
                        var flag_def = flag_definitions [flag_type];
                        var flag_list = [];
                        var __iterable0__ = Object.keys (Game.flags);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var name = __iterable0__ [__index0__];
                            var flag = Game.flags [name];
                            if (flag.color == flag_def [0] && flag.secondaryColor == flag_def [1]) {
                                flag_list.append (flag);
                            }
                        }
                        _global_flag_cache.set (flag_type, flag_list);
                        return flag_list;
                    };
                    var find_flags_ms_global = function (main_type, sub_type, reload) {
                        if (typeof reload == 'undefined' || (reload != null && reload .hasOwnProperty ("__kwargtrans__"))) {;
                            var reload = false;
                        };
                        var type_name = '{}_{}'.format (main_type, sub_type);
                        __check_new_flags ();
                        if (Game.time > _global_flag_refresh_time) {
                            _global_flag_refresh_time = Game.time + _REFRESH_EVERY;
                            _global_flag_cache = new_map ();
                        }
                        if (_global_flag_cache.has (type_name) && !(reload)) {
                            return _global_flag_cache.get (type_name);
                        }
                        var primary = main_to_flag_primary [main_type];
                        var secondary = sub_to_flag_secondary [sub_type];
                        var flag_list = [];
                        var __iterable0__ = Object.keys (Game.flags);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var name = __iterable0__ [__index0__];
                            var flag = Game.flags [name];
                            if (flag.color == primary && flag.secondaryColor == secondary) {
                                flag_list.append (flag);
                            }
                        }
                        _global_flag_cache.set (type_name, flag_list);
                        return flag_list;
                    };
                    var find_by_main_with_sub_global = function (main_type, reload) {
                        if (typeof reload == 'undefined' || (reload != null && reload .hasOwnProperty ("__kwargtrans__"))) {;
                            var reload = false;
                        };
                        __check_new_flags ();
                        if (Game.time > _global_flag_refresh_time) {
                            _global_flag_refresh_time = Game.time + _REFRESH_EVERY;
                            _global_flag_cache = new_map ();
                        }
                        if (_global_flag_cache.has (main_type) && !(reload)) {
                            return _global_flag_cache.get (main_type);
                        }
                        var primary = main_to_flag_primary [main_type];
                        var flag_list = [];
                        var __iterable0__ = Object.keys (Game.flags);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var name = __iterable0__ [__index0__];
                            var flag = Game.flags [name];
                            if (flag.color == primary) {
                                var secondary = flag_secondary_to_sub [flag.secondaryColor];
                                if (secondary) {
                                    flag_list.append ([flag, secondary]);
                                }
                            }
                        }
                        _global_flag_cache.set (main_type, flag_list);
                        return flag_list;
                    };
                    var _closest_flag_cache = new_map ();
                    var _closest_flag_refresh_time = Game.time + _REFRESH_EVERY;
                    var squared_distance = function (x1, y1, x2, y2) {
                        var x_diff = x1 - x2;
                        var y_diff = y1 - y2;
                        return x_diff * x_diff + y_diff * y_diff;
                    };
                    var find_closest_in_room = function (pos, flag_type) {
                        __check_new_flags ();
                        if (Game.time > _closest_flag_refresh_time) {
                            _closest_flag_refresh_time = Game.time + 50;
                            _closest_flag_cache = new_map ();
                        }
                        var key = '{}_{}_{}_{}'.format (pos.roomName, pos.x, pos.y, flag_type);
                        if (_closest_flag_cache.has (key)) {
                            return _closest_flag_cache.get (key);
                        }
                        var closest_distance = Infinity;
                        var closest_flag = null;
                        var __iterable0__ = find_flags (pos.roomName, flag_type);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var flag = __iterable0__ [__index0__];
                            var distance = squared_distance (pos.x, pos.y, flag.pos.x, flag.pos.y);
                            if (distance < closest_distance) {
                                var closest_distance = distance;
                                var closest_flag = flag;
                            }
                        }
                        _closest_flag_cache.set (key, closest_flag);
                        return closest_flag;
                    };
                    var __create_flag = function (position, flag_type, primary, secondary) {
                        if (position.pos) {
                            var position = position.pos;
                        }
                        var name = '{}_{}'.format (flag_type, naming.random_digits ());
                        var room = Game.rooms [position.roomName];
                        if (room) {
                            var flag_name = room.createFlag (position, name, primary, secondary);
                            print ('[flags] Created flag at {}: {}'.format (position, flag_name));
                            return flag_name;
                        }
                        else {
                            var known_position = Game.spawns [Object.keys (Game.spawns) [0]].pos;
                            var flag_name = known_position.createFlag (name, primary, secondary);
                            if (Memory.flags_to_move) {
                                Memory.flags_to_move.push ([flag_name, position]);
                            }
                            else {
                                Memory.flags_to_move = [[flag_name, position]];
                            }
                            return flag_name;
                        }
                    };
                    var create_flag = function (position, flag_type) {
                        var flag_def = flag_definitions [flag_type];
                        return __create_flag (position, flag_type, flag_def [0], flag_def [1]);
                    };
                    var create_ms_flag = function (position, main, sub) {
                        return __create_flag (position, '{}_{}'.format (main, sub), main_to_flag_primary [main], sub_to_flag_secondary [sub]);
                    };
                    var rename_flags = function () {
                        refresh_flag_caches ();
                        var __iterable0__ = Object.keys (flag_definitions);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var name = __iterable0__ [__index0__];
                            var __iterable1__ = find_flags_global (name);
                            for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                var flag = __iterable1__ [__index1__];
                                if (Game.cpu.getUsed () > 400) {
                                    refresh_flag_caches ();
                                    return 'Used too much CPU!';
                                }
                                if (Game.rooms [flag.pos.roomName] && (flag.name.startswith ('Flag') || !(flag.name.includes ('_'))) && !(flag.name in Memory.flags)) {
                                    var new_name = create_flag (flag.pos, name);
                                    if (Memory.flags [flag.name]) {
                                        if (len (Memory.flags [flag.name])) {
                                            Memory.flags [new_name] = Memory.flags [flag.name];
                                        }
                                        delete Memory.flags [flag.name];
                                    }
                                    flag.remove ();
                                }
                            }
                        }
                        var __iterable0__ = Object.keys (main_to_flag_primary);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var main = __iterable0__ [__index0__];
                            var __iterable1__ = find_by_main_with_sub_global (main);
                            for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                var __left0__ = __iterable1__ [__index1__];
                                var flag = __left0__ [0];
                                var sub = __left0__ [1];
                                if (Game.cpu.getUsed () > 400) {
                                    refresh_flag_caches ();
                                    return 'Used too much CPU!';
                                }
                                if (Game.rooms [flag.pos.roomName] && (flag.name.startswith ('Flag') || !(flag.name.includes ('_'))) && !(flag.name in Memory.flags)) {
                                    var new_name = create_ms_flag (flag.pos, main, sub);
                                    if (Memory.flags [flag.name]) {
                                        if (len (Memory.flags [flag.name])) {
                                            Memory.flags [new_name] = Memory.flags [flag.name];
                                        }
                                        delete Memory.flags [flag.name];
                                    }
                                    flag.remove ();
                                }
                            }
                        }
                        refresh_flag_caches ();
                    };
                    var look_for = function (room, position, main, sub) {
                        if (typeof sub == 'undefined' || (sub != null && sub .hasOwnProperty ("__kwargtrans__"))) {;
                            var sub = null;
                        };
                        if (!(room.look_at)) {
                            var __except0__ = ValueError ('Invalid room argument');
                            __except0__.__cause__ = null;
                            throw __except0__;
                        }
                        if (position.pos) {
                            var position = position.pos;
                        }
                        if (sub) {
                            return _.find (room.look_at (LOOK_FLAGS, position), (function __lambda__ (f) {
                                return f.color == main_to_flag_primary [main] && f.secondaryColor == sub_to_flag_secondary [sub];
                            }));
                        }
                        else {
                            var flag_def = flag_definitions [main];
                            if (!(flag_def)) {
                                return [];
                            }
                            return _.find (room.look_at (LOOK_FLAGS, position), (function __lambda__ (f) {
                                return f.color == flag_def [0] && f.secondaryColor == flag_def [1];
                            }));
                        }
                    };
                    __pragma__ ('<use>' +
                        'constants' +
                        'jstools.screeps_constants' +
                        'utilities.naming' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.DEPOT = DEPOT;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.MAIN_BUILD = MAIN_BUILD;
                        __all__.MAIN_DESTRUCT = MAIN_DESTRUCT;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.REROUTE = REROUTE;
                        __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
                        __all__.RESERVE_NOW = RESERVE_NOW;
                        __all__.SCOUT = SCOUT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.SUB_CONTAINER = SUB_CONTAINER;
                        __all__.SUB_EXTENSION = SUB_EXTENSION;
                        __all__.SUB_EXTRACTOR = SUB_EXTRACTOR;
                        __all__.SUB_LINK = SUB_LINK;
                        __all__.SUB_RAMPART = SUB_RAMPART;
                        __all__.SUB_ROAD = SUB_ROAD;
                        __all__.SUB_SPAWN = SUB_SPAWN;
                        __all__.SUB_STORAGE = SUB_STORAGE;
                        __all__.SUB_TERMINAL = SUB_TERMINAL;
                        __all__.SUB_TOWER = SUB_TOWER;
                        __all__.SUB_WALL = SUB_WALL;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__._REFRESH_EVERY = _REFRESH_EVERY;
                        __all__.__check_new_flags = __check_new_flags;
                        __all__.__create_flag = __create_flag;
                        __all__.__get_cache = __get_cache;
                        __all__.__get_room_and_name = __get_room_and_name;
                        __all__._closest_flag_cache = _closest_flag_cache;
                        __all__._closest_flag_refresh_time = _closest_flag_refresh_time;
                        __all__._global_flag_cache = _global_flag_cache;
                        __all__._global_flag_refresh_time = _global_flag_refresh_time;
                        __all__._last_checked_flag_len = _last_checked_flag_len;
                        __all__._last_flag_len = _last_flag_len;
                        __all__._room_flag_cache = _room_flag_cache;
                        __all__._room_flag_refresh_time = _room_flag_refresh_time;
                        __all__.create_flag = create_flag;
                        __all__.create_ms_flag = create_ms_flag;
                        __all__.find_by_main_with_sub = find_by_main_with_sub;
                        __all__.find_by_main_with_sub_global = find_by_main_with_sub_global;
                        __all__.find_closest_in_room = find_closest_in_room;
                        __all__.find_flags = find_flags;
                        __all__.find_flags_global = find_flags_global;
                        __all__.find_flags_ms_global = find_flags_ms_global;
                        __all__.find_ms_flags = find_ms_flags;
                        __all__.flag_definitions = flag_definitions;
                        __all__.flag_secondary_to_sub = flag_secondary_to_sub;
                        __all__.flag_sub_to_structure_type = flag_sub_to_structure_type;
                        __all__.is_def = is_def;
                        __all__.look_for = look_for;
                        __all__.main_to_flag_primary = main_to_flag_primary;
                        __all__.move_flags = move_flags;
                        __all__.naming = naming;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.refresh_flag_caches = refresh_flag_caches;
                        __all__.rename_flags = rename_flags;
                        __all__.squared_distance = squared_distance;
                        __all__.structure_type_to_flag_sub = structure_type_to_flag_sub;
                        __all__.sub_to_flag_secondary = sub_to_flag_secondary;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'position_management.locations', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var naming = __init__ (__world__.utilities.naming);
                    var _mem_hints = null;
                    var _mem_expirations = null;
                    var _mem = null;
                    var _created_objects = null;
                    var _last_update = 0;
                    var DeserializedPos = function (string, name) {
                        var __left0__ = string.py_split ('|');
                        var xy_str = __left0__ [0];
                        var room = __left0__ [1];
                        var expiration = __left0__ [2];
                        var xy = int (xy_str);
                        this.x = xy & 63;
                        this.y = xy >> 6 & 63;
                        this.roomName = room;
                        this.name = name;
                        if (expiration != undefined) {
                            _mem_expirations [name] = Game.time + expiration;
                        }
                    };
                    DeserializedPos.prototype = Object.create (RoomPosition.prototype);
                    var _update_deserialized_pos_xy = function (x, y, room_name) {
                        this.x = x;
                        this.y = y;
                        if (room_name != undefined) {
                            this.roomName = room_name;
                        }
                        _mem [this.name] = _serialize (this);
                    };
                    var _get_hint = function () {
                        var hint = _mem_hints [this.name];
                        if (hint === undefined) {
                            var hint = null;
                        }
                        Object.defineProperty (this, 'hint', {'get': () => hint
                        , 'set': _set_hint, 'enumerable': true, 'configurable': true});
                        return hint;
                    };
                    var _set_hint = function (hint) {
                        Object.defineProperty (this, 'hint', {'get': () => hint
                        , 'set': _set_hint, 'enumerable': true, 'configurable': true});
                        _mem_hints [this.name] = hint;
                    };
                    var _deserialized_pos_to_string = function () {
                        var things = ['[Location ', this.name];
                        if (this.hint) {
                            things.push (' (type: ', this.hint, ')');
                        }
                        things.push (': ', this.x, ',', this.y, ' ', this.roomName, ']');
                        return ''.join (things);
                    };
                    DeserializedPos.prototype.py_update = _update_deserialized_pos_xy;
                    Object.defineProperty (DeserializedPos.prototype, 'hint', {'get': _get_hint, 'set': _set_hint, 'enumerable': true, 'configurable': true});
                    DeserializedPos.prototype.toString = _deserialized_pos_to_string;
                    var _deserialize = function (string, name) {
                        return new DeserializedPos (string, name);
                    };
                    var _serialize = function (position, expiration) {
                        if (typeof expiration == 'undefined' || (expiration != null && expiration .hasOwnProperty ("__kwargtrans__"))) {;
                            var expiration = null;
                        };
                        if (position.pos !== undefined) {
                            var position = position.pos;
                        }
                        if (position.x == undefined || position.y == undefined || position.roomName == undefined) {
                            var __except0__ = ValueError ('Invalid position: {}'.format (position));
                            __except0__.__cause__ = null;
                            throw __except0__;
                        }
                        var parts = [position.x | position.y << 6, position.roomName];
                        if (expiration != undefined) {
                            parts.append (expiration);
                        }
                        return '|'.join (parts);
                    };
                    var init = function () {
                        if (!('_locations' in Memory)) {
                            Memory ['_locations'] = {'-': null};
                        }
                        if (!('_hints' in Memory)) {
                            Memory ['_hints'] = {'-': null};
                        }
                        if (!('_exp' in Memory)) {
                            Memory ['_exp'] = {'-': null};
                        }
                        _mem = Memory ['_locations'];
                        _mem_hints = Memory ['_hints'];
                        _mem_expirations = Memory ['_exp'];
                    };
                    var serialized = function (name) {
                        var result = _mem [name];
                        if (result === undefined) {
                            return null;
                        }
                        else {
                            return result;
                        }
                    };
                    var get = function (name) {
                        var serialized_result = _mem [name];
                        if (serialized_result == undefined) {
                            return null;
                        }
                        else {
                            return _deserialize (serialized_result, name);
                        }
                    };
                    var create = function (position, hint, expiration) {
                        if (typeof hint == 'undefined' || (hint != null && hint .hasOwnProperty ("__kwargtrans__"))) {;
                            var hint = null;
                        };
                        if (typeof expiration == 'undefined' || (expiration != null && expiration .hasOwnProperty ("__kwargtrans__"))) {;
                            var expiration = null;
                        };
                        var name = naming.random_digits ();
                        while ((name in _mem)) {
                            name += naming.random_digits ();
                        }
                        if (expiration == undefined) {
                            var expiration = 10 * 1000;
                        }
                        else if (expiration <= 0) {
                            var expiration = null;
                        }
                        _mem [name] = _serialize (position, expiration);
                        if (hint != undefined) {
                            _mem_hints [name] = hint;
                        }
                        return get (name);
                    };
                    var delete_location = function (name) {
                        delete _mem_expirations [name];
                        delete _mem_hints [name];
                        delete _mem [name];
                    };
                    var clean_old_positions = function () {
                        var __iterable0__ = Object.keys (_mem_expirations);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var name = __iterable0__ [__index0__];
                            if (name != '-' && _mem_expirations [name] < Game.time) {
                                var exp = _mem_expirations [name];
                                print ('[locations] Expiring location {}: {} < {}'.format (get (name), exp, Game.time));
                                delete _mem_expirations [name];
                                delete _mem_hints [name];
                                delete _mem [name];
                            }
                        }
                    };
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                        'utilities.naming' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.DeserializedPos = DeserializedPos;
                        __all__._created_objects = _created_objects;
                        __all__._deserialize = _deserialize;
                        __all__._deserialized_pos_to_string = _deserialized_pos_to_string;
                        __all__._get_hint = _get_hint;
                        __all__._last_update = _last_update;
                        __all__._mem = _mem;
                        __all__._mem_expirations = _mem_expirations;
                        __all__._mem_hints = _mem_hints;
                        __all__._serialize = _serialize;
                        __all__._set_hint = _set_hint;
                        __all__._update_deserialized_pos_xy = _update_deserialized_pos_xy;
                        __all__.clean_old_positions = clean_old_positions;
                        __all__.create = create;
                        __all__.delete_location = delete_location;
                        __all__.get = get;
                        __all__.init = init;
                        __all__.naming = naming;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.serialized = serialized;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'random', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var _array = function () {
                        var __accu0__ = [];
                        for (var i = 0; i < 624; i++) {
                            __accu0__.append (0);
                        }
                        return __accu0__;
                    } ();
                    var _index = 0;
                    var _bitmask1 = Math.pow (2, 32) - 1;
                    var _bitmask2 = Math.pow (2, 31);
                    var _bitmask3 = Math.pow (2, 31) - 1;
                    var _fill_array = function () {
                        for (var i = 0; i < 624; i++) {
                            var y = (_array [i] & _bitmask2) + (_array [__mod__ (i + 1, 624)] & _bitmask3);
                            _array [i] = _array [__mod__ (i + 397, 624)] ^ y >> 1;
                            if (__mod__ (y, 2) != 0) {
                                _array [i] ^= 2567483615;
                            }
                        }
                    };
                    var _random_integer = function () {
                        if (_index == 0) {
                            _fill_array ();
                        }
                        var y = _array [_index];
                        y ^= y >> 11;
                        y ^= y << 7 & 2636928640;
                        y ^= y << 15 & 4022730752;
                        y ^= y >> 18;
                        _index = __mod__ (_index + 1, 624);
                        return y;
                    };
                    var seed = function (x) {
                        if (typeof x == 'undefined' || (x != null && x .hasOwnProperty ("__kwargtrans__"))) {;
                            var x = int (_bitmask3 * Math.random ());
                        };
                        _array [0] = x;
                        for (var i = 1; i < 624; i++) {
                            _array [i] = (1812433253 * _array [i - 1] ^ (_array [i - 1] >> 30) + i) & _bitmask1;
                        }
                    };
                    var randint = function (a, b) {
                        return a + __mod__ (_random_integer (), (b - a) + 1);
                    };
                    var choice = function (seq) {
                        return seq [randint (0, len (seq) - 1)];
                    };
                    var random = function () {
                        return _random_integer () / _bitmask3;
                    };
                    seed ();
                    __pragma__ ('<all>')
                        __all__._array = _array;
                        __all__._bitmask1 = _bitmask1;
                        __all__._bitmask2 = _bitmask2;
                        __all__._bitmask3 = _bitmask3;
                        __all__._fill_array = _fill_array;
                        __all__._index = _index;
                        __all__._random_integer = _random_integer;
                        __all__.choice = choice;
                        __all__.randint = randint;
                        __all__.random = random;
                        __all__.seed = seed;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'rooms.building', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    var random = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    __nest__ (random, '', __init__ (__world__.random));
                    var context = __init__ (__world__.cache.context);
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
                    var max_repave_mine_roads_every = __init__ (__world__.constants).max_repave_mine_roads_every;
                    var min_repath_mine_roads_every = __init__ (__world__.constants).min_repath_mine_roads_every;
                    var min_repave_mine_roads_every = __init__ (__world__.constants).min_repave_mine_roads_every;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
                    var mining_paths = __init__ (__world__.creep_management.mining_paths);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var movement = __init__ (__world__.utilities.movement);
                    var positions = __init__ (__world__.utilities.positions);
                    var _cache_key_placed_roads_for_mine = 'prfm';
                    var _cache_key_found_roads_for_mine = 'frfm';
                    var _build_roads_constant_missing_rooms = 'mr';
                    var _build_roads_constant_not_enough_sites = 'ns';
                    var building_priorities = {[STRUCTURE_EXTENSION]: 0, [STRUCTURE_SPAWN]: 1, [STRUCTURE_LINK]: 1, [STRUCTURE_TOWER]: 2, [STRUCTURE_STORAGE]: 3, [STRUCTURE_WALL]: 6, [STRUCTURE_RAMPART]: 6, [STRUCTURE_TERMINAL]: 8};
                    var rcl_lt4_priorities = {[STRUCTURE_SPAWN]: 0, [STRUCTURE_TOWER]: 1, [STRUCTURE_EXTENSION]: 2, [STRUCTURE_ROAD]: 3, [STRUCTURE_WALL]: 11, [STRUCTURE_RAMPART]: 12};
                    var default_priority = 10;
                    var max_priority_for_non_wall_sites = 5;
                    var get_priority = function (room, structure_type) {
                        if (!(room.spawn)) {
                            if (structure_type == STRUCTURE_SPAWN) {
                                if (room.being_bootstrapped ()) {
                                    if (room.mem [rmem_key_building_priority_spawn]) {
                                        return -(2);
                                    }
                                    else {
                                        return 5;
                                    }
                                }
                                else {
                                    return -(2);
                                }
                            }
                            else if (structure_type == STRUCTURE_LINK) {
                                if (room.being_bootstrapped ()) {
                                    return 4;
                                }
                            }
                            else if ((structure_type == STRUCTURE_WALL || structure_type == STRUCTURE_EXTENSION) && room.being_bootstrapped ()) {
                                if (room.mem [rmem_key_building_priority_walls]) {
                                    return -(1);
                                }
                                else {
                                    return -(3);
                                }
                            }
                        }
                        if (room.rcl < 4) {
                            if ((structure_type in rcl_lt4_priorities)) {
                                return rcl_lt4_priorities [structure_type];
                            }
                        }
                        else if ((structure_type in building_priorities)) {
                            return building_priorities [structure_type];
                        }
                        return default_priority;
                    };
                    var not_road = function (id) {
                        var thing = Game.getObjectById (id);
                        if (thing !== null) {
                            return thing.structureType != STRUCTURE_ROAD;
                        }
                        else {
                            var flag = Game.flags [id];
                            return flag !== undefined && flags.flag_secondary_to_sub [flag.secondaryColor] != flags.SUB_ROAD;
                        }
                    };
                    var protect_with_ramparts = [STRUCTURE_SPAWN, STRUCTURE_POWER_SPAWN, STRUCTURE_TERMINAL, STRUCTURE_STORAGE, STRUCTURE_TOWER, STRUCTURE_LAB];
                    var rampart_priorities = {[STRUCTURE_STORAGE]: 1, [STRUCTURE_TOWER]: 2, [STRUCTURE_SPAWN]: 3, [STRUCTURE_TERMINAL]: 4, [STRUCTURE_POWER_SPAWN]: 5, [STRUCTURE_LAB]: 6};
                    var ConstructionMind = __class__ ('ConstructionMind', [object], {
                        get __init__ () {return __get__ (this, function (self, room) {
                            self.room = room;
                            self.hive = room.hive;
                        });},
                        get toString () {return __get__ (this, function (self) {
                            return 'ConstructionMind[room: {}]'.format (self.room.name);
                        });},
                        get refresh_building_targets () {return __get__ (this, function (self, now) {
                            if (typeof now == 'undefined' || (now != null && now .hasOwnProperty ("__kwargtrans__"))) {;
                                var now = false;
                            };
                            self.refresh_num_builders (now);
                            if (now) {
                                self.room.delete_cached_property ('building_targets');
                                self.room.delete_cached_property ('non_wall_construction_targets');
                                self.room.delete_cached_property ('sieged_walls_unbuilt');
                            }
                            else {
                                self.room.expire_property_next_tick ('building_targets');
                                self.room.expire_property_next_tick ('non_wall_construction_targets');
                                self.room.expire_property_next_tick ('sieged_walls_unbuilt');
                            }
                        });},
                        get refresh_repair_targets () {return __get__ (this, function (self, now) {
                            if (typeof now == 'undefined' || (now != null && now .hasOwnProperty ("__kwargtrans__"))) {;
                                var now = false;
                            };
                            self.refresh_num_builders (now);
                            if (now) {
                                self.room.delete_cached_property ('repair_targets');
                                self.room.delete_cached_property ('big_repair_targets');
                            }
                            else {
                                self.room.expire_property_next_tick ('repair_targets');
                                self.room.expire_property_next_tick ('big_repair_targets');
                            }
                        });},
                        get refresh_destruction_targets () {return __get__ (this, function (self) {
                            self.room.delete_cached_property ('destruct_targets');
                        });},
                        get _max_hits_at () {return __get__ (this, function (self, struct, big_repair) {
                            if (typeof big_repair == 'undefined' || (big_repair != null && big_repair .hasOwnProperty ("__kwargtrans__"))) {;
                                var big_repair = false;
                            };
                            if (struct.structureType == STRUCTURE_WALL) {
                                if (big_repair) {
                                    return self.room.max_sane_wall_hits;
                                }
                                else {
                                    return self.room.min_sane_wall_hits;
                                }
                            }
                            else if (struct.structureType == STRUCTURE_RAMPART) {
                                if (big_repair) {
                                    return min (self.room.max_sane_wall_hits, struct.hitsMax);
                                }
                                else {
                                    return min (self.room.min_sane_wall_hits, struct.hitsMax);
                                }
                            }
                            else {
                                return struct.hitsMax;
                            }
                        });},
                        get _get_is_relatively_decayed_callback () {return __get__ (this, function (self, big_repair) {
                            if (typeof big_repair == 'undefined' || (big_repair != null && big_repair .hasOwnProperty ("__kwargtrans__"))) {;
                                var big_repair = false;
                            };
                            var is_relatively_decayed = function (thing_id) {
                                var thing = Game.getObjectById (thing_id);
                                if (thing === null) {
                                    return false;
                                }
                                if (thing.structureType == STRUCTURE_ROAD) {
                                    return thing.hits < thing.hitsMax * 0.35;
                                }
                                else {
                                    var max_hits = self._max_hits_at (thing, big_repair);
                                    var max_hits = max_hits - min (max_hits * 0.4, 50 * 1000);
                                    return thing.hits < max_hits;
                                }
                            };
                            return is_relatively_decayed;
                        });},
                        get _hits_left_to_repair_at () {return __get__ (this, function (self, thing_id) {
                            var thing = Game.getObjectById (thing_id);
                            if (thing === null) {
                                return 0;
                            }
                            if (thing.structureType != STRUCTURE_RAMPART && thing.structureType != STRUCTURE_WALL) {
                                return thing.hitsMax - thing.hits;
                            }
                            return max (0, self.room.max_sane_wall_hits - thing.hits);
                        });},
                        get get_target_num_builders () {return __get__ (this, function (self) {
                            var num = self.room.get_cached_property ('builders_needed');
                            if (num !== null) {
                                return num;
                            }
                            var sites_and_repair = _.sum (self.get_construction_targets (), not_road) + _.sum (self.get_repair_targets (), self._get_is_relatively_decayed_callback (false));
                            if (sites_and_repair > 0) {
                                if (sites_and_repair < 4) {
                                    var num = 1;
                                }
                                else if (sites_and_repair < 12) {
                                    var num = 2;
                                }
                                else {
                                    var num = 4;
                                }
                            }
                            else {
                                var extra_repair = _.sum (self.get_big_repair_targets (), self._get_is_relatively_decayed_callback (true));
                                if (extra_repair > 0) {
                                    var num = 1;
                                }
                                else {
                                    var num = 0;
                                }
                            }
                            self.room.store_cached_property ('builders_needed', num, 1000);
                            return num;
                        });},
                        get get_max_builder_work_parts () {return __get__ (this, function (self) {
                            var parts = self.room.get_cached_property ('max_builder_work_parts');
                            if (parts !== null) {
                                return parts;
                            }
                            var construction = 0;
                            var __iterable0__ = self.get_construction_targets ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var site_id = __iterable0__ [__index0__];
                                var site = Game.getObjectById (site_id);
                                if (site && site.progressTotal) {
                                    construction += site.progressTotal - site.progress;
                                }
                            }
                            var repair = _.sum (self.get_big_repair_targets (), self._hits_left_to_repair_at);
                            var total_work_ticks_needed = construction / BUILD_POWER + repair / REPAIR_POWER;
                            var total_work_parts_needed = math.ceil (total_work_ticks_needed / (CREEP_LIFE_TIME / 2));
                            self.room.store_cached_property ('max_builder_work_parts', total_work_parts_needed, 1000);
                            return total_work_parts_needed;
                        });},
                        get get_max_builder_work_parts_noextra () {return __get__ (this, function (self) {
                            var parts = self.room.get_cached_property ('max_builder_work_parts_noextra');
                            if (parts !== null) {
                                return parts;
                            }
                            var construction = 0;
                            var __iterable0__ = self.get_construction_targets ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var site_id = __iterable0__ [__index0__];
                                var site = Game.getObjectById (site_id);
                                if (site && site.progressTotal) {
                                    construction += site.progressTotal - site.progress;
                                }
                            }
                            var repair = _.sum (self.get_repair_targets (), self._hits_left_to_repair_at);
                            var total_work_ticks_needed = construction / BUILD_POWER + repair / REPAIR_POWER;
                            var total_work_parts_needed = math.ceil (total_work_ticks_needed / (CREEP_LIFE_TIME / 2));
                            self.room.store_cached_property ('max_builder_work_parts_noextra', total_work_parts_needed, 1000);
                            return total_work_parts_needed;
                        });},
                        get get_max_builder_work_parts_urgent () {return __get__ (this, function (self) {
                            var parts = self.room.get_cached_property ('max_builder_work_parts_urgent_only');
                            if (parts !== null) {
                                return parts;
                            }
                            var construction = 0;
                            var __iterable0__ = self.get_construction_targets ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var site_id = __iterable0__ [__index0__];
                                var site = Game.getObjectById (site_id);
                                if (!(site)) {
                                    continue;
                                }
                                if (site && (site.structureType == STRUCTURE_WALL || site.structureType == STRUCTURE_RAMPART || site.structureType == STRUCTURE_SPAWN || site.structureType == STRUCTURE_ROAD)) {
                                    construction += site.progressTotal - site.progress;
                                }
                            }
                            var repair = 0;
                            var __iterable0__ = self.get_repair_targets ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var struct_id = __iterable0__ [__index0__];
                                var struct = Game.getObjectById (struct_id);
                                if (struct && struct.hits) {
                                    if (struct.structureType == STRUCTURE_WALL || struct.structureType == STRUCTURE_RAMPART) {
                                        repair += max (0, self.room.min_sane_wall_hits / 2 - struct.hits);
                                    }
                                    else {
                                        repair += struct.hitsMax - struct.hits;
                                    }
                                }
                            }
                            var total_work_ticks_needed = construction / BUILD_POWER + repair / REPAIR_POWER;
                            var total_work_parts_needed = math.ceil (total_work_ticks_needed / (CREEP_LIFE_TIME / 2));
                            self.room.store_cached_property ('max_builder_work_parts_urgent_only', total_work_parts_needed, 1000);
                            return total_work_parts_needed;
                        });},
                        get refresh_num_builders () {return __get__ (this, function (self, now) {
                            if (typeof now == 'undefined' || (now != null && now .hasOwnProperty ("__kwargtrans__"))) {;
                                var now = false;
                            };
                            if (now) {
                                self.room.delete_cached_property ('builders_needed');
                                self.room.delete_cached_property ('max_builder_work_parts');
                                self.room.delete_cached_property ('max_builder_work_parts_noextra');
                                self.room.delete_cached_property ('max_builder_work_parts_urgent_only');
                            }
                            else {
                                self.room.expire_property_next_tick ('builders_needed');
                                self.room.expire_property_next_tick ('max_builder_work_parts');
                                self.room.expire_property_next_tick ('max_builder_work_parts_noextra');
                                self.room.expire_property_next_tick ('max_builder_work_parts_urgent_only');
                            }
                        });},
                        get get_high_value_construction_targets () {return __get__ (this, function (self) {
                            if (self.room.under_siege ()) {
                                var targets = self.room.get_cached_property ('sieged_walls_unbuilt');
                                if (targets !== null) {
                                    return targets;
                                }
                                var targets = _ (self.get_construction_targets ()).map ((function __lambda__ (x) {
                                    return Game.getObjectById (x);
                                })).filter ((function __lambda__ (x) {
                                    return x !== null && (x.structureType == STRUCTURE_WALL || x.structureType == STRUCTURE_RAMPART) && !(len (x.pos.lookFor (LOOK_STRUCTURES)));
                                })).sortBy ((function __lambda__ (x) {
                                    return -(1) * max (abs (25 - x.pos.x), abs (25 - x.pos.y));
                                })).pluck ('id').value ();
                                self.room.store_cached_property ('seiged_walls_unbuilt', targets, 200);
                                return targets;
                            }
                            else {
                                var targets = self.room.get_cached_property ('non_wall_construction_targets');
                                if (targets !== null) {
                                    return targets;
                                }
                                var targets = _ (self.get_construction_targets ()).map ((function __lambda__ (x) {
                                    return Game.getObjectById (x);
                                })).filter ((function __lambda__ (x) {
                                    return x !== null && get_priority (self.room, x.structureType) <= max_priority_for_non_wall_sites;
                                })).pluck ('id').value ();
                                self.room.store_cached_property ('non_wall_construction_targets', targets, 200);
                                return targets;
                            }
                        });},
                        get get_construction_targets () {return __get__ (this, function (self) {
                            var targets = self.room.get_cached_property ('building_targets');
                            if (targets !== null) {
                                var last_rcl = self.room.get_cached_property ('bt_last_checked_rcl');
                                if (last_rcl >= self.room.rcl) {
                                    return targets;
                                }
                            }
                            print ('[{}] Calculating new construction targets'.format (self.room.name));
                            self.room.delete_cached_property ('non_wall_construction_targets');
                            self.room.delete_cached_property ('seiged_walls_unbuilt');
                            self.refresh_num_builders (true);
                            if (self.room.spawn) {
                                var spawn_pos = self.room.spawn.pos;
                            }
                            else {
                                var spawn_flag = flags.find_ms_flags (self.room, flags.MAIN_BUILD, flags.SUB_SPAWN);
                                if (len (spawn_flag)) {
                                    var spawn_pos = spawn_flag [0].pos;
                                }
                                else {
                                    print ('[{}][building] Warning: Finding construction targets for room {}, which has no spawn planned!'.format (self.room.name, self.room.name));
                                    var spawn_pos = movement.center_pos (self.room.name);
                                }
                            }
                            var volatile = volatile_cache.volatile ();
                            var total_count = len (Game.constructionSites) + (volatile.get ('construction_sites_placed') || 0);
                            var new_sites = [];
                            if (_.sum (self.room.find (FIND_CONSTRUCTION_SITES), not_road) < 15 && total_count < MAX_CONSTRUCTION_SITES) {
                                var currently_existing = _ (self.room.find (FIND_STRUCTURES)).concat (self.room.find (FIND_MY_CONSTRUCTION_SITES)).countBy ('structureType').value ();
                                var all_walls = self.room.rcl < 5 && self.room.being_bootstrapped () && self.room.mem [rmem_key_building_priority_walls];
                                var prio_spawn = self.room.rcl < 5 && self.room.being_bootstrapped () && !(!(self.room.mem [rmem_key_building_priority_spawn]));
                                var no_walls = !(all_walls) && (self.room.rcl < 3 || self.room.rcl == 3 && !(_.find (self.room.find (FIND_MY_STRUCTURES), (function __lambda__ (s) {
                                    return s.structureType == STRUCTURE_TOWER;
                                }))));
                                var flag_priority = function (flag_tuple) {
                                    var struct_type = flags.flag_sub_to_structure_type [flag_tuple [1]];
                                    return get_priority (self.room, struct_type) * 50 + movement.distance_room_pos (spawn_pos, flag_tuple [0].pos);
                                };
                                var __iterable0__ = _.sortBy (flags.find_by_main_with_sub (self.room, flags.MAIN_BUILD), flag_priority);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var __left0__ = __iterable0__ [__index0__];
                                    var flag = __left0__ [0];
                                    var flag_type = __left0__ [1];
                                    var structure_type = flags.flag_sub_to_structure_type [flag_type];
                                    if (!(structure_type)) {
                                        print ('[{}][building] Warning: structure type corresponding to flag type {} not found!'.format (self.room.name, flag_type));
                                        continue;
                                    }
                                    if (structure_type == STRUCTURE_EXTRACTOR && !(self.room.look_at (LOOK_MINERALS, flag.pos))) {
                                        var structure_type = STRUCTURE_CONTAINER;
                                    }
                                    if (no_walls || all_walls || prio_spawn) {
                                        var selected = false;
                                        if (all_walls && structure_type == STRUCTURE_RAMPART || structure_type == STRUCTURE_WALL) {
                                            var selected = true;
                                        }
                                        else if (no_walls && !(all_walls) && !(prio_spawn) && structure_type != STRUCTURE_RAMPART && structure_type != STRUCTURE_WALL) {
                                            var selected = true;
                                        }
                                        else if (prio_spawn && structure_type == STRUCTURE_SPAWN) {
                                            var selected = true;
                                        }
                                        if (!(selected)) {
                                            continue;
                                        }
                                    }
                                    if (CONTROLLER_STRUCTURES [structure_type] [self.room.rcl] > (currently_existing [structure_type] || 0) && !(flags.look_for (self.room, flag, flags.MAIN_DESTRUCT, flags.structure_type_to_flag_sub [structure_type])) && !(_.find (self.room.look_at (LOOK_STRUCTURES, flag.pos), {'structureType': structure_type}) || _.find (self.room.look_at (LOOK_CONSTRUCTION_SITES, flag.pos)))) {
                                        total_count++;
                                        flag.pos.createConstructionSite (structure_type);
                                        new_sites.append ('flag-{}'.format (flag.name));
                                        currently_existing [structure_type] = (currently_existing [structure_type] || 0) + 1;
                                        if (len (new_sites) >= 4 || total_count >= MAX_CONSTRUCTION_SITES) {
                                            break;
                                        }
                                    }
                                }
                                volatile.set ('construction_sites_placed', total_count);
                            }
                            var sites = _ (self.room.find (FIND_MY_CONSTRUCTION_SITES)).sortBy ((function __lambda__ (s) {
                                return get_priority (self.room, s.structureType) * 50 + movement.distance_room_pos (spawn_pos, s.pos);
                            })).pluck ('id').value ().concat (new_sites);
                            self.room.store_cached_property ('building_targets', sites, 1000);
                            self.room.store_cached_property ('bt_last_checked_rcl', self.room.rcl, 1000);
                            return self.room.get_cached_property ('building_targets');
                        });},
                        get get_repair_targets () {return __get__ (this, function (self) {
                            var structures = self.room.get_cached_property ('repair_targets');
                            if (structures !== null) {
                                var last_rcl = self.room.get_cached_property ('rt_last_checked_rcl');
                                if (last_rcl >= self.room.rcl) {
                                    return structures;
                                }
                                else {
                                    self.refresh_num_builders (true);
                                }
                            }
                            if (self.room.spawn) {
                                var spawn_pos = self.room.spawn.pos;
                            }
                            else {
                                var spawn_flag = flags.find_ms_flags (self.room, flags.MAIN_BUILD, flags.SUB_SPAWN);
                                if (len (spawn_flag)) {
                                    var spawn_pos = spawn_flag [0].pos;
                                }
                                else {
                                    print ('[{}][building] Warning: Finding repair targets for room {}, which has no spawn planned!'.format (self.room.name, self.room.name));
                                    var spawn_pos = movement.center_pos (self.room.name);
                                }
                            }
                            var max_hits = self.room.min_sane_wall_hits;
                            var any_destruct_flags = len (flags.find_by_main_with_sub (self.room, flags.MAIN_DESTRUCT));
                            var structures = _ (self.room.find (FIND_STRUCTURES)).map ((function __lambda__ (s) {
                                return [s, (s.structureType == STRUCTURE_WALL || s.structureType == STRUCTURE_RAMPART ? min (s.hitsMax, max_hits) : s.hitsMax)];
                            })).filter ((function __lambda__ (t) {
                                return (t [0].my || !(t [0].owner)) && t [0].hits < t [1] * 0.9 && (t [0].structureType != STRUCTURE_ROAD || t [0].hits < t [0].hitsMax * 0.8) && (!(any_destruct_flags) || !(flags.look_for (self.room, t [0].pos, flags.MAIN_DESTRUCT, flags.structure_type_to_flag_sub [t [0].structureType])));
                            })).sortBy ((function __lambda__ (t) {
                                return (get_priority (self.room, t [0].structureType) * 10 + ((t [0].structureType != STRUCTURE_RAMPART && t [0].structureType != STRUCTURE_WALL ? movement.distance_room_pos (spawn_pos, t [0].pos) : -(movement.distance_room_pos (spawn_pos, t [0].pos))) / 50) * 10) - ((t [1] - t [0].hits) / t [1]) * 100;
                            })).map ((function __lambda__ (t) {
                                return t [0].id;
                            })).value ();
                            self.room.store_cached_property ('repair_targets', structures, 50);
                            self.room.store_cached_property ('rt_last_checked_rcl', self.room.rcl, 50);
                            return structures;
                        });},
                        get get_big_repair_targets () {return __get__ (this, function (self) {
                            var target_list = self.room.get_cached_property ('big_repair_targets');
                            if (target_list !== null) {
                                return target_list;
                            }
                            var max_hits = self.room.max_sane_wall_hits;
                            var any_destruct_flags = len (flags.find_by_main_with_sub (self.room, flags.MAIN_DESTRUCT));
                            var target_list = _ (self.room.find (FIND_STRUCTURES)).filter ((function __lambda__ (s) {
                                return (s.my || !(s.owner)) && s.hits < s.hitsMax && s.hits < max_hits && (s.structureType != STRUCTURE_ROAD || s.hits < s.hitsMax * 0.5) && (!(any_destruct_flags) || !(flags.look_for (self.room, s, flags.MAIN_DESTRUCT, flags.structure_type_to_flag_sub [s.structureType])));
                            })).sortBy ((function __lambda__ (s) {
                                return s.hits;
                            })).pluck ('id').value ();
                            self.room.store_cached_property ('big_repair_targets', target_list, 200);
                            return target_list;
                        });},
                        get get_destruction_targets () {return __get__ (this, function (self) {
                            var target_list = self.room.get_cached_property ('destruct_targets');
                            if (target_list !== null) {
                                return target_list;
                            }
                            var target_list = [];
                            if (self.room.spawn) {
                                var spawn_pos = self.room.spawn.pos;
                            }
                            else {
                                var spawn_flag = flags.find_ms_flags (self.room, flags.MAIN_BUILD, flags.SUB_SPAWN);
                                if (len (spawn_flag)) {
                                    var spawn_pos = spawn_flag [0].pos;
                                }
                                else {
                                    print ('[{}][building] Warning: Finding destruct targets for room {}, which has no spawn planned!'.format (self.room.name, self.room.name));
                                    var spawn_pos = movement.center_pos (self.room.name);
                                }
                            }
                            var __iterable0__ = _.sortBy (flags.find_by_main_with_sub (self.room, flags.MAIN_DESTRUCT), (function __lambda__ (t) {
                                return -(movement.distance_squared_room_pos (t [0].pos, spawn_pos));
                            }));
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var flag = __left0__ [0];
                                var secondary = __left0__ [1];
                                var structure_type = flags.flag_sub_to_structure_type [secondary];
                                if (structure_type == STRUCTURE_ROAD) {
                                    continue;
                                }
                                var structures = _.filter (self.room.look_at (LOOK_STRUCTURES, flag.pos), (function __lambda__ (s) {
                                    return s.structureType == structure_type;
                                }));
                                if (structure_type != STRUCTURE_RAMPART && _.find (self.room.look_at (LOOK_STRUCTURES, flag.pos), {'structureType': STRUCTURE_RAMPART})) {
                                    var __iterable1__ = structures;
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var struct = __iterable1__ [__index1__];
                                        print ('[{}][building] Not dismantling {}, as it is under a rampart.'.format (self.room.name, struct));
                                    }
                                    continue;
                                }
                                if (len (structures) && !(flags.look_for (self.room, flag.pos, flags.MAIN_BUILD, secondary))) {
                                    var __iterable1__ = structures;
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var struct = __iterable1__ [__index1__];
                                        target_list.append (struct.id);
                                    }
                                }
                                else {
                                    flag.remove ();
                                }
                            }
                            self.room.store_cached_property ('destruct_targets', target_list, 200);
                            return target_list;
                        });},
                        get build_most_needed_road () {return __get__ (this, function (self) {
                            var __iterable0__ = self.room.mining.active_mines;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var mine_flag = __iterable0__ [__index0__];
                                var re_checked = self.build_road (mine_flag);
                                if (re_checked) {
                                    return true;
                                }
                            }
                            return false;
                        });},
                        get build_road () {return __get__ (this, function (self, mine_flag) {
                            var current_method_version = 1;
                            var last_built_roads_key = _cache_key_placed_roads_for_mine + mine_flag.name;
                            var cached_version = self.room.get_cached_property (last_built_roads_key);
                            var deposit_point = self.room.mining.closest_deposit_point_to_mine (mine_flag);
                            if (!(deposit_point)) {
                                return false;
                            }
                            var latest_version = (str (current_method_version) + '-') + deposit_point.id;
                            if (cached_version == latest_version) {
                                return false;
                            }
                            else if (cached_version !== null && cached_version.startswith (_build_roads_constant_missing_rooms)) {
                                var only_search_rooms = cached_version.__getslice__ (len (_build_roads_constant_missing_rooms), null, 1).py_split ('-');
                                var __break0__ = false;
                                var __iterable0__ = only_search_rooms;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var name = __iterable0__ [__index0__];
                                    if ((name in Game.rooms)) {
                                        __break0__ = true;
                                        break;
                                    }
                                }
                                if (!__break0__) {
                                    return false;
                                }
                            }
                            else if (cached_version !== null && cached_version.startswith (_build_roads_constant_not_enough_sites)) {
                                var needed = int (cached_version.__getslice__ (len (_build_roads_constant_not_enough_sites), null, 1));
                                var current = _.size (Game.constructionSites) + (volatile_cache.volatile ().get ('construction_sites_placed') || 0);
                                if (min (needed, 25) < MAX_CONSTRUCTION_SITES * 0.8 - current) {
                                    return false;
                                }
                            }
                            print ('[{}][building] Building roads for {}.'.format (self.room.name, mine_flag.name));
                            var last_found_roads_key = _cache_key_found_roads_for_mine + mine_flag.name;
                            var latest_found_roads = self.room.get_cached_property (last_found_roads_key);
                            if (latest_found_roads != latest_version) {
                                self._repath_roads_for (mine_flag, deposit_point);
                                self.room.store_cached_property (last_found_roads_key, latest_version, random.randint (min_repath_mine_roads_every, max_repath_mine_roads_every));
                            }
                            var checked_positions = {};
                            var missing_rooms = [];
                            var all_modified_rooms = [];
                            var hive = self.hive;
                            var site_count = _.size (Game.constructionSites) + (volatile_cache.volatile ().get ('construction_sites_placed') || 0);
                            var need_more_sites = 0;
                            var check_route = function (serialized_obj, not_near_start_of, not_near_end_of) {
                                var __iterable0__ = Object.keys (serialized_obj);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var room_name = __iterable0__ [__index0__];
                                    if (!(movement.is_valid_room_name (room_name))) {
                                        continue;
                                    }
                                    if (!(room_name in Game.rooms)) {
                                        if (!(missing_rooms.includes (room_name))) {
                                            missing_rooms.push (room_name);
                                        }
                                        continue;
                                    }
                                    if (!(all_modified_rooms.includes (room_name))) {
                                        all_modified_rooms.push (room_name);
                                    }
                                    if ((room_name in checked_positions)) {
                                        var checked_here = checked_positions [room_name];
                                    }
                                    else {
                                        var __left0__ = new_set ();
                                        var checked_here = __left0__;
                                        checked_positions [room_name] = __left0__;
                                    }
                                    var room = hive.get_room (room_name);
                                    var path = Room.deserializePath (serialized_obj [room_name]);
                                    if (room_name == not_near_end_of) {
                                        var rest = path.slice (-(2));
                                        var path = path.slice (0, -(2));
                                    }
                                    if (room_name == not_near_start_of) {
                                        var rest = path.slice (0, 2);
                                        var path = path.slice (2);
                                    }
                                    var __iterable1__ = path;
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var position = __iterable1__ [__index1__];
                                        var xy_key = positions.serialize_pos_xy (position);
                                        if (checked_here.has (xy_key)) {
                                            continue;
                                        }
                                        else {
                                            checked_here.add (xy_key);
                                        }
                                        var structures = room.look_at (LOOK_STRUCTURES, position.x, position.y);
                                        if (!(_.some (structures, 'structureType', STRUCTURE_ROAD))) {
                                            if (site_count >= MAX_CONSTRUCTION_SITES * 0.9) {
                                                need_more_sites++;
                                            }
                                            else {
                                                room.room.createConstructionSite (position.x, position.y, STRUCTURE_ROAD);
                                                site_count++;
                                            }
                                        }
                                    }
                                }
                            };
                            var honey = self.hive.honey;
                            if (deposit_point.pos.isNearTo (mine_flag)) {
                                var all_positions = [];
                            }
                            else {
                                var route_to_mine = honey.get_serialized_path_obj (mine_flag, deposit_point, {'paved_for': mine_flag, 'keep_for': min_repath_mine_roads_every * 2});
                                check_route (route_to_mine, (mine_flag.pos || mine_flag).roomName, null);
                                var all_positions = honey.list_of_room_positions_in_path (mine_flag, deposit_point, {'paved_for': mine_flag, 'keep_for': min_repath_mine_roads_every * 2});
                            }
                            var __iterable0__ = self.room.spawns;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var spawn = __iterable0__ [__index0__];
                                if (len (all_positions)) {
                                    var closest = null;
                                    var closest_distance = Infinity;
                                    var __iterable1__ = enumerate (all_positions);
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var __left0__ = __iterable1__ [__index1__];
                                        var index = __left0__ [0];
                                        var pos = __left0__ [1];
                                        var distance = movement.chebyshev_distance_room_pos (spawn, pos) - index * 0.7;
                                        if (pos.roomName != spawn.pos.roomName || pos.x < 2 || pos.x > 48 || pos.y < 2 || pos.y > 48) {
                                            distance += 10;
                                        }
                                        if (distance < closest_distance) {
                                            var closest = pos;
                                            var closest_distance = distance;
                                        }
                                    }
                                    if (closest.isNearTo (mine_flag) && closest.roomName != (mine_flag.pos || mine_flag).roomName) {
                                        var no_pave_end = closest.roomName;
                                    }
                                    else {
                                        var no_pave_end = null;
                                    }
                                }
                                else {
                                    var closest = mine_flag.pos || mine_flag;
                                    var no_pave_end = closest.roomName;
                                }
                                if (closest.isNearTo (spawn)) {
                                    continue;
                                }
                                var route_to_spawn = honey.get_serialized_path_obj (spawn, closest, {'paved_for': [mine_flag, spawn], 'keep_for': min_repath_mine_roads_every * 2});
                                check_route (route_to_spawn, null, no_pave_end);
                            }
                            var __iterable0__ = all_modified_rooms;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var room_name = __iterable0__ [__index0__];
                                var room = hive.get_room (room_name);
                                if (room && !(room.my)) {
                                    var all_planned_sites_set = mining_paths.get_set_of_all_serialized_positions_in (room_name);
                                    var __iterable1__ = room.find (FIND_MY_CONSTRUCTION_SITES);
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var site = __iterable1__ [__index1__];
                                        var xy = positions.serialize_pos_xy (site);
                                        if (site.structureType == STRUCTURE_ROAD && !(all_planned_sites_set.has (xy))) {
                                            print ('[building] Removing {} at {}.'.format (site, site.pos));
                                            site.remove ();
                                        }
                                    }
                                }
                            }
                            if (need_more_sites > 0) {
                                self.room.store_cached_property (last_built_roads_key, _build_roads_constant_not_enough_sites + str (need_more_sites), min_repath_mine_roads_every);
                                print ('[{}][building] Stopped: need more sites. ({}/{})'.format (self.room.name, MAX_CONSTRUCTION_SITES - site_count, need_more_sites));
                            }
                            else if (len (missing_rooms) > 0) {
                                self.room.store_cached_property (last_built_roads_key, _build_roads_constant_missing_rooms + '-'.join (missing_rooms), min_repath_mine_roads_every);
                                print ('[{}][building] Stopped: missing rooms. ({})'.format (self.room.name, ', '.join (missing_rooms)));
                            }
                            else {
                                self.room.store_cached_property (last_built_roads_key, latest_version, random.randint (min_repave_mine_roads_every, max_repave_mine_roads_every));
                            }
                            return true;
                        });},
                        get _repath_roads_for () {return __get__ (this, function (self, mine_flag, deposit_point) {
                            var honey = self.hive.honey;
                            if (deposit_point.pos.isNearTo (mine_flag)) {
                                var mine_path = [];
                                mining_paths.register_new_mining_path (mine_flag, mine_path);
                            }
                            else {
                                var mine_path = honey.completely_repath_and_get_raw_path (mine_flag, deposit_point, {'paved_for': mine_flag, 'keep_for': min_repath_mine_roads_every * 2});
                            }
                            var __iterable0__ = self.room.spawns;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var spawn = __iterable0__ [__index0__];
                                if (len (mine_path)) {
                                    var closest = null;
                                    var closest_distance = Infinity;
                                    var __iterable1__ = enumerate (mine_path);
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var __left0__ = __iterable1__ [__index1__];
                                        var index = __left0__ [0];
                                        var pos = __left0__ [1];
                                        var distance = movement.chebyshev_distance_room_pos (spawn, pos) - index * 0.7;
                                        if (pos.roomName != spawn.pos.roomName || pos.x < 2 || pos.x > 48 || pos.y < 2 || pos.y > 48) {
                                            distance += 10;
                                        }
                                        if (distance < closest_distance) {
                                            var closest = pos;
                                            var closest_distance = distance;
                                        }
                                    }
                                }
                                else {
                                    var closest = mine_flag.pos || mine_flag;
                                }
                                if (closest.isNearTo (spawn)) {
                                    mining_paths.register_new_mining_path ([mine_flag, spawn], []);
                                    continue;
                                }
                                honey.completely_repath_and_get_raw_path (spawn, closest, {'paved_for': [mine_flag, spawn], 'keep_for': min_repath_mine_roads_every * 2});
                            }
                        });},
                        get place_home_ramparts () {return __get__ (this, function (self) {
                            var last_run = self.room.get_cached_property ('placed_ramparts');
                            if (last_run) {
                                return ;
                            }
                            if (self.room.rcl < 3 || !(len (self.room.defense.towers ()))) {
                                self.room.store_cached_property ('placed_ramparts', 'lower_rcl', 20);
                                return ;
                            }
                            if (_ (self.get_construction_targets ()).concat (self.get_repair_targets ()).map ((function __lambda__ (x) {
                                return Game.getObjectById (x);
                            })).sum ((function __lambda__ (c) {
                                return c && c.structureType == STRUCTURE_RAMPART || 0;
                            })) >= 3) {
                                self.room.store_cached_property ('placed_ramparts', 'existing_sites', 20);
                                return ;
                            }
                            var volatile = volatile_cache.volatile ();
                            var site_count = len (Game.constructionSites);
                            var prev_sites_placed = volatile.get ('construction_sites_placed') || 0;
                            var sites_placed_now = 0;
                            if (site_count + prev_sites_placed >= MAX_CONSTRUCTION_SITES * 0.9) {
                                return ;
                            }
                            var ramparts = new_set ();
                            var need_ramparts = new_map ();
                            var __iterable0__ = self.room.find (FIND_MY_STRUCTURES);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var structure = __iterable0__ [__index0__];
                                var pos_key = structure.pos.x * 64 + structure.pos.y;
                                if (structure.structureType == STRUCTURE_RAMPART) {
                                    ramparts.add (pos_key);
                                }
                                else if (protect_with_ramparts.includes (structure.structureType) && (structure.structureType != STRUCTURE_EXTENSION || len (self.room.mining.active_mines) > 1)) {
                                    need_ramparts.set (pos_key, structure);
                                }
                            }
                            var __iterable0__ = self.room.find (FIND_MY_CONSTRUCTION_SITES);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var site = __iterable0__ [__index0__];
                                var pos_key = site.pos.x * 64 + site.pos.y;
                                if (site.structureType == STRUCTURE_RAMPART) {
                                    ramparts.add (pos_key);
                                }
                            }
                            var entries = Array.from (need_ramparts.entries ());
                            var sorted_entries = _.sortBy (entries, (function __lambda__ (t) {
                                return rampart_priorities [t [1].structureType] || 10;
                            }));
                            var __iterable0__ = sorted_entries;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var pos_key = __left0__ [0];
                                var structure = __left0__ [1];
                                if (!(ramparts.has (pos_key))) {
                                    print ('[{}][building] Protecting {} with a rampart.'.format (self.room.name, structure));
                                    structure.pos.createConstructionSite (STRUCTURE_RAMPART);
                                    sites_placed_now++;
                                    if ((site_count + prev_sites_placed) + sites_placed_now >= MAX_CONSTRUCTION_SITES || sites_placed_now >= 5) {
                                        break;
                                    }
                                }
                            }
                            volatile.set ('construction_sites_placed', sites_placed_now);
                            if (sites_placed_now > 0) {
                                self.refresh_building_targets ();
                            }
                            self.room.store_cached_property ('placed_ramparts', 1, random.randint (500, 600));
                        });},
                        get re_place_home_ramparts () {return __get__ (this, function (self) {
                            self.room.expire_property_next_tick ('placed_ramparts');
                        });},
                        get find_loc_near_away_from () {return __get__ (this, function (self, near, away_from) {
                            if (near.pos) {
                                var near = near.pos;
                            }
                            var path = PathFinder.search (near, away_from, {'roomCallback': self.hive.honey._get_callback (near, near, {}), 'flee': true, 'maxRooms': 1});
                            if (path.incomplete) {
                                print ("[{}][building] WARNING: Couldn't find full path near {} and away from {}!".format (self.room.name, near, function () {
                                    var __accu0__ = [];
                                    var __iterable0__ = away_from;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var x = __iterable0__ [__index0__];
                                        __accu0__.append (x.pos);
                                    }
                                    return __accu0__;
                                } ()));
                                if (!(len (path.path))) {
                                    return ;
                                }
                            }
                            return path.path [len (path) - 1];
                        });},
                        get place_depot_flag () {return __get__ (this, function (self) {
                            var center = self.room.spawn;
                            if (!(center)) {
                                var center = flags.find_ms_flags (self.room, flags.MAIN_BUILD, flags.SUB_SPAWN) [0];
                                if (!(center)) {
                                    var center = self.room.spawns [0];
                                    if (!(center)) {
                                        return ;
                                    }
                                }
                            }
                            var cache = volatile_cache.setmem ('npcf');
                            var cache_key = 'depot_{}'.format (self.room.name);
                            if (cache.has (cache_key)) {
                                return ;
                            }
                            var away_from = [{'pos': center.pos, 'range': 4}];
                            var __iterable0__ = self.room.sources;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var source = __iterable0__ [__index0__];
                                away_from.append ({'pos': source.pos, 'range': 5});
                            }
                            var __iterable0__ = self.room.spawns;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var spawn = __iterable0__ [__index0__];
                                away_from.append ({'pos': spawn.pos, 'range': 4});
                            }
                            var __iterable0__ = self.room.find (FIND_MINERALS);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var mineral = __iterable0__ [__index0__];
                                away_from.append ({'pos': mineral.pos, 'range': 4});
                            }
                            var __iterable0__ = flags.find_ms_flags (self.room, flags.MAIN_BUILD, flags.SUB_WALL);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                away_from.append ({'pos': flag.pos, 'range': 1});
                            }
                            var __iterable0__ = flags.find_ms_flags (self.room, flags.MAIN_BUILD, flags.SUB_RAMPART);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                away_from.append ({'pos': flag.pos, 'range': 1});
                            }
                            var target = self.find_loc_near_away_from (center, away_from);
                            flags.create_flag (target, DEPOT);
                            cache.add (cache_key);
                        });}
                    });
                    var clean_up_all_road_construction_sites = function () {
                        var rooms_to_sites = _.groupBy (Game.constructionSites, 'pos.roomName');
                        var __iterable0__ = Object.keys (rooms_to_sites);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var room_name = __iterable0__ [__index0__];
                            if (_.get (Game.rooms, [room_name, 'controller', 'my'], false)) {
                                continue;
                            }
                            var planned_roads = mining_paths.get_set_of_all_serialized_positions_in (room_name);
                            var __iterable1__ = rooms_to_sites [room_name];
                            for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                var site = __iterable1__ [__index1__];
                                var xy = positions.serialize_pos_xy (site);
                                if (site.structureType == STRUCTURE_ROAD) {
                                    if (!(planned_roads.has (xy))) {
                                        print ('[building] Removing {} at {}.'.format (site, site.pos));
                                        site.remove ();
                                    }
                                }
                                else {
                                    var msg = '[building] WARNING: Construction site for a {} found in unowned room {}. Non-road construction sites are generally not supported in unowned rooms!'.format (site.structureType, room_name);
                                    print (msg);
                                    Game.notify (msg);
                                }
                            }
                        }
                    };
                    var repave = function (mine_name) {
                        var flag = Game.flags [mine_name];
                        if (!(flag)) {
                            return 'error: flag {} does not exist!'.format (mine_name);
                        }
                        if (('sponsor' in flag.memory)) {
                            var sponsor = flag.memory.sponsor;
                        }
                        else {
                            var sponsor = flag.name.py_split ('_') [0];
                        }
                        var room = context.hive ().get_room (sponsor);
                        if (!(room)) {
                            return 'error: room {} not visible.'.format (sponsor);
                        }
                        if (!(room.my)) {
                            return 'error: room {} not owned.'.format (sponsor);
                        }
                        room.delete_cached_property (_cache_key_found_roads_for_mine + flag.name);
                        room.delete_cached_property (_cache_key_placed_roads_for_mine + flag.name);
                        room.building.build_road (flag);
                    };
                    __pragma__ ('<use>' +
                        'cache.context' +
                        'cache.volatile_cache' +
                        'constants' +
                        'creep_management.mining_paths' +
                        'jstools.screeps_constants' +
                        'math' +
                        'position_management.flags' +
                        'random' +
                        'utilities.movement' +
                        'utilities.positions' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ConstructionMind = ConstructionMind;
                        __all__.DEPOT = DEPOT;
                        __all__._build_roads_constant_missing_rooms = _build_roads_constant_missing_rooms;
                        __all__._build_roads_constant_not_enough_sites = _build_roads_constant_not_enough_sites;
                        __all__._cache_key_found_roads_for_mine = _cache_key_found_roads_for_mine;
                        __all__._cache_key_placed_roads_for_mine = _cache_key_placed_roads_for_mine;
                        __all__.building_priorities = building_priorities;
                        __all__.clean_up_all_road_construction_sites = clean_up_all_road_construction_sites;
                        __all__.context = context;
                        __all__.default_priority = default_priority;
                        __all__.flags = flags;
                        __all__.get_priority = get_priority;
                        __all__.max_priority_for_non_wall_sites = max_priority_for_non_wall_sites;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
                        __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
                        __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
                        __all__.mining_paths = mining_paths;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.not_road = not_road;
                        __all__.positions = positions;
                        __all__.protect_with_ramparts = protect_with_ramparts;
                        __all__.rampart_priorities = rampart_priorities;
                        __all__.rcl_lt4_priorities = rcl_lt4_priorities;
                        __all__.repave = repave;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.volatile_cache = volatile_cache;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'rooms.defense', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var SK_USERNAME = __init__ (__world__.constants).SK_USERNAME;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
                    var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
                    var rmem_key_defense_mind_storage = __init__ (__world__.constants).rmem_key_defense_mind_storage;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
                    var role_wall_defender = __init__ (__world__.constants).role_wall_defender;
                    var deathwatch = __init__ (__world__.creep_management.deathwatch);
                    var errorlog = __init__ (__world__.jstools.errorlog);
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var locations = __init__ (__world__.position_management.locations);
                    var hostile_utils = __init__ (__world__.utilities.hostile_utils);
                    var movement = __init__ (__world__.utilities.movement);
                    var positions = __init__ (__world__.utilities.positions);
                    var _init_tough_part_multipliers = function () {
                        var result = {};
                        var input_obj = BOOSTS [TOUGH];
                        var __iterable0__ = Object.keys (input_obj);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var boost = __iterable0__ [__index0__];
                            result [boost] = 1 / (1 - input_obj [boost]);
                        }
                        return result;
                    };
                    var TOUGH_HIT_MULTIPLIERS = _init_tough_part_multipliers ();
                    var tower_damage = function (range) {
                        if (range > 20) {
                            return 150;
                        }
                        else if (range < 5) {
                            return 600;
                        }
                        return (25 - range) * 30;
                    };
                    var poll_hostiles = function (hive, run_away_checks) {
                        if (!('hostiles' in Memory)) {
                            Memory.hostiles = {};
                        }
                        var __iterable0__ = hive.visible_rooms;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var room = __iterable0__ [__index0__];
                            if (hostile_utils.enemy_room (room.name)) {
                                continue;
                            }
                            var targets = room.defense.dangerous_hostiles ();
                            if (len (targets)) {
                                var danger = [];
                                var __iterable1__ = targets;
                                for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                    var c = __iterable1__ [__index1__];
                                    var store = {'user': c.owner.username, 'pos': c.pos.x | c.pos.y << 6, 'room': c.pos.roomName, 'id': c.id, 'death': Game.time + c.ticksToLive, 'ranged': c.getActiveBodyparts (RANGED_ATTACK), 'attack': c.getActiveBodyparts (ATTACK), 'heal': c.getActiveBodyparts (HEAL), 'offensive': hostile_utils.is_offensive (c)};
                                    danger.push (store);
                                    Memory.hostiles [c.id] = store;
                                }
                                if (!(rmem_key_stored_hostiles in room.mem)) {
                                    if (room.my) {
                                        room.reset_planned_role ();
                                    }
                                    else {
                                        var __iterable1__ = flags.find_flags (room, REMOTE_MINE);
                                        for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                            var flag = __iterable1__ [__index1__];
                                            var sponsor = hive.get_room (flag.memory.sponsor);
                                            if (sponsor) {
                                                sponsor.reset_planned_role ();
                                            }
                                        }
                                    }
                                }
                                room.mem [rmem_key_stored_hostiles] = danger;
                                try {
                                    run_away_checks (room);
                                    deathwatch.mark_creeps (room);
                                }
                                catch (__except0__) {
                                    errorlog.report_error ('defense.poll-hostiles', __except0__, 'Error running run-away-checks in {}.'.format (room.name));
                                }
                            }
                            else if ((room.name in Memory.rooms)) {
                                delete room.mem [rmem_key_stored_hostiles];
                                if (!(len (room.mem))) {
                                    delete Memory.rooms [room.name];
                                }
                            }
                        }
                    };
                    var cleanup_stored_hostiles = function () {
                        var __iterable0__ = _.pairs (Memory.hostiles);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var __left0__ = __iterable0__ [__index0__];
                            var key = __left0__ [0];
                            var hostile = __left0__ [1];
                            if (hostile.death <= Game.time) {
                                delete Memory.hostiles [key];
                            }
                        }
                        var __iterable0__ = _.pairs (Memory.rooms);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var __left0__ = __iterable0__ [__index0__];
                            var name = __left0__ [0];
                            var mem = __left0__ [1];
                            if (('danger' in mem)) {
                                var danger = mem.danger;
                                var i = 0;
                                while (i < danger.length) {
                                    if ((danger [i].id in Memory.hostiles)) {
                                        i++;
                                    }
                                    else {
                                        danger.splice (i, 1);
                                    }
                                }
                                if (!(len (danger))) {
                                    delete mem.danger;
                                    if (!(len (mem))) {
                                        delete Memory.rooms [name];
                                    }
                                }
                            }
                        }
                    };
                    var does_need_urgent_repair = function (s) {
                        return s.structureType == STRUCTURE_ROAD && (s.hits < ROAD_DECAY_AMOUNT * 3 || Game.map.getTerrainAt (s.pos.x, s.pos.y, s.pos.roomName) == 'swamp' && s.hits < (ROAD_DECAY_AMOUNT * CONSTRUCTION_COST_ROAD_SWAMP_RATIO) * 3) || s.structureType == STRUCTURE_RAMPART && s.hits < RAMPART_DECAY_AMOUNT * 3;
                    };
                    var stored_hostiles_near = function (room_name) {
                        var cache = volatile_cache.mem ('stored_hostiles_near');
                        if (cache.has (room_name)) {
                            return cache.get (room_name);
                        }
                        var __left0__ = movement.parse_room_to_xy (room_name);
                        var room_x = __left0__ [0];
                        var room_y = __left0__ [1];
                        if (room_x == 0 && room_y == 0 && room_name == 'sim') {
                            return stored_hostiles_in (room_name);
                        }
                        var result = [];
                        for (var x = room_x - 1; x < room_x + 2; x++) {
                            for (var y = room_y - 1; y < room_y + 2; y++) {
                                var name = movement.room_xy_to_name (x, y);
                                var mem = Memory.rooms [name];
                                if (mem !== undefined && ('danger' in mem)) {
                                    var __iterable0__ = mem.danger;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var c = __iterable0__ [__index0__];
                                        if (Game.time < c.death) {
                                            result.push (c);
                                        }
                                    }
                                }
                            }
                        }
                        cache.set (room_name, result);
                        return result;
                    };
                    var stored_hostiles_in = function (room_name) {
                        var cache = volatile_cache.mem ('stored_hostiles_in');
                        if (cache.has (room_name)) {
                            return cache.get (room_name);
                        }
                        var result = [];
                        var mem = Memory.rooms [room_name];
                        if (mem !== undefined && ('danger' in mem)) {
                            var __iterable0__ = mem.danger;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var c = __iterable0__ [__index0__];
                                if (Game.time < c.death) {
                                    result.push (c);
                                }
                            }
                            if (!(len (result))) {
                                delete mem.danger;
                            }
                        }
                        cache.set (room_name, result);
                        return result;
                    };
                    var RoomDefense = __class__ ('RoomDefense', [object], {
                        get __init__ () {return __get__ (this, function (self, room) {
                            self.room = room;
                            self._cache = new_map ();
                            if (self.room.my) {
                                self.mem = self.room.mem [rmem_key_defense_mind_storage];
                                if (self.mem == undefined) {
                                    var __left0__ = {};
                                    self.mem = __left0__;
                                    self.room.mem [rmem_key_defense_mind_storage] = __left0__;
                                }
                            }
                        });},
                        get _hive () {return __get__ (this, function (self) {
                            return self.room.hive;
                        }, '_hive');},
                        get all_hostiles () {return __get__ (this, function (self) {
                            return self.room.find (FIND_HOSTILE_CREEPS);
                        }, 'all_hostiles');},
                        get any_broken_walls () {return __get__ (this, function (self) {
                            if (self._cache.has ('any_broken_walls')) {
                                return self._cache.get ('any_broken_walls');
                            }
                            else {
                                var broken = false;
                                if (self.room.being_bootstrapped () && !(self.room.mem [rmem_key_building_priority_walls])) {
                                    var broken = true;
                                }
                                else {
                                    var __iterable0__ = flags.find_ms_flags (self.room, flags.MAIN_BUILD, flags.SUB_WALL).concat (flags.find_ms_flags (self.room, flags.MAIN_BUILD, flags.SUB_RAMPART));
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var flag = __iterable0__ [__index0__];
                                        if (!(_.find (flag.pos.lookFor (LOOK_STRUCTURES), (function __lambda__ (s) {
                                            return s.structureType == STRUCTURE_WALL || s.structureType == STRUCTURE_RAMPART;
                                        })))) {
                                            var broken = true;
                                            break;
                                        }
                                    }
                                }
                                self._cache.set ('any_broken_walls', broken);
                                return broken;
                            }
                        }, 'any_broken_walls');},
                        get this_room_mining_ops () {return __get__ (this, function (self) {
                            if (self._cache.has ('this_room_mining_ops')) {
                                return self._cache.get ('this_room_mining_ops');
                            }
                            else {
                                var any_ops = !(!(_.find (flags.find_flags (self, REMOTE_MINE), (function __lambda__ (f) {
                                    return f.memory.active;
                                }))));
                                self._cache.set ('this_room_mining_ops', any_ops);
                                return any_ops;
                            }
                        }, 'this_room_mining_ops');},
                        get healing_possible_on () {return __get__ (this, function (self, hostile) {
                            if (('_possible_heal' in hostile)) {
                                return hostile._possible_heal;
                            }
                            else {
                                var nearby = self.room.look_for_in_area_around (LOOK_CREEPS, hostile, 3);
                                var healing_possible = 0;
                                var __iterable0__ = nearby;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var obj = __iterable0__ [__index0__];
                                    var creep = obj.creep;
                                    var distance = movement.chebyshev_distance_room_pos (hostile, creep);
                                    if (distance <= 2) {
                                        healing_possible += creep.getActiveBodypartsBoostEquivalent (HEAL, 'heal') * HEAL_POWER;
                                    }
                                    else {
                                        healing_possible += creep.getActiveBodypartsBoostEquivalent (HEAL, 'rangedHeal') * RANGED_HEAL_POWER;
                                    }
                                }
                                hostile._possible_heal = healing_possible;
                                return healing_possible;
                            }
                        }, 'healing_possible_on');},
                        get defenders_near () {return __get__ (this, function (self, hostile) {
                            if (('_defenders_near' in hostile)) {
                                return hostile._defenders_near;
                            }
                            else {
                                var nearby = self.room.look_for_in_area_around (LOOK_CREEPS, hostile, 1);
                                var result = _.filter (nearby, (function __lambda__ (c) {
                                    return c.creep.my && c.creep.hasActiveBodyparts (ATTACK) && _.find (c.creep.pos.lookFor (LOOK_STRUCTURES), (function __lambda__ (s) {
                                        return s.structureType == STRUCTURE_RAMPART;
                                    }));
                                }));
                                hostile._defenders_near = result;
                                return result;
                            }
                        }, 'defenders_near');},
                        get any_attack_invaders () {return __get__ (this, function (self) {
                            if (self._cache.has ('_attack_invaders')) {
                                return self._cache.get ('_attack_invaders');
                            }
                            else {
                                var any_attack_invaders = _.some (self.all_hostiles (), (function __lambda__ (h) {
                                    return h.owner.username == INVADER_USERNAME && (h.hasBodyparts (ATTACK) || h.hasBodyparts (RANGED_ATTACK));
                                }));
                                self._cache.set ('_attack_invaders', any_attack_invaders);
                                return any_attack_invaders;
                            }
                        }, 'any_attack_invaders');},
                        get _calc_danger_level () {return __get__ (this, function (self, hostile) {
                            var under_siege = self.room.mem [rmem_key_currently_under_siege];
                            var user = hostile.owner.username;
                            if (user == INVADER_USERNAME) {
                                if (!(hostile.hasBodyparts (ATTACK)) && !(hostile.hasBodyparts (RANGED_ATTACK))) {
                                    if (self.any_attack_invaders ()) {
                                        return 0.3;
                                    }
                                    else {
                                        return 0;
                                    }
                                }
                                else {
                                    return 2;
                                }
                            }
                            else if (user == SK_USERNAME) {
                                return 0;
                            }
                            else if (Memory.meta.friends.includes (user)) {
                                return 0;
                            }
                            else if (hostile.my) {
                                return 0;
                            }
                            else if (self.room.my) {
                                var structs_near = _.some (self.room.look_for_in_area_around (LOOK_STRUCTURES, hostile, 1), (function __lambda__ (s) {
                                    return s.structure.structureType == STRUCTURE_RAMPART || s.structure.structureType == STRUCTURE_WALL || s.structure.structureType == STRUCTURE_TOWER || s.structure.structureType == STRUCTURE_SPAWN;
                                }));
                                if (structs_near && hostile.hasBodyparts (WORK)) {
                                    return 100 + hostile.getActiveBodyparts (WORK) * DISMANTLE_POWER;
                                }
                                else if (structs_near && hostile.hasBodyparts (ATTACK)) {
                                    return 100 + hostile.getActiveBodyparts (ATTACK) * ATTACK_POWER;
                                }
                                else if (hostile.hasActiveBodyparts (RANGED_ATTACK)) {
                                    if (under_siege) {
                                        return 10.04;
                                    }
                                    else {
                                        return 10;
                                    }
                                }
                                else if (hostile.hasBodyparts (ATTACK)) {
                                    if (self.any_broken_walls () || structs_near || _.find (self.room.look_for_in_area_around (LOOK_CREEPS, hostile, 1), (function __lambda__ (obj) {
                                        return obj.creep.my;
                                    }))) {
                                        if (under_siege) {
                                            return 10.07;
                                        }
                                        else {
                                            return 7;
                                        }
                                    }
                                    else if (under_siege) {
                                        return 10.05;
                                    }
                                    else {
                                        return 5;
                                    }
                                }
                                else if (hostile.hasBodyparts (WORK)) {
                                    if (under_siege) {
                                        return 10.04;
                                    }
                                    else {
                                        return 5;
                                    }
                                }
                                else if ((1 < hostile.pos.x && hostile.pos.x < 48) && (1 < hostile.pos.y && hostile.pos.y < 48)) {
                                    return 0.2;
                                }
                                else {
                                    return 0;
                                }
                            }
                            else if (hostile.hasActiveBodyparts (RANGED_ATTACK)) {
                                return 4;
                            }
                            else if (hostile.hasActiveBodyparts (ATTACK)) {
                                return 1;
                            }
                            else if (_.find (hostile.body, (function __lambda__ (p) {
                                return p.type == ATTACK || p.type == RANGED_ATTACK;
                            }))) {
                                return 0.7;
                            }
                            else if ((hostile.hasBodyparts (CARRY) || hostile.hasBodyparts (WORK)) && self.this_room_mining_ops ()) {
                                return 0.5;
                            }
                            else if (hostile.hasActiveBodyparts (TOUGH)) {
                                return 0.3;
                            }
                            else {
                                return 0;
                            }
                        }, '_calc_danger_level');},
                        get danger_level () {return __get__ (this, function (self, hostile) {
                            if (self._cache.has (hostile.id)) {
                                return self._cache.get (hostile.id);
                            }
                            else {
                                var danger_level = self._calc_danger_level (hostile);
                                self._cache.set (hostile.id, danger_level);
                                return danger_level;
                            }
                        }, 'danger_level');},
                        get dangerous_hostiles () {return __get__ (this, function (self) {
                            if (self._cache.has ('active_hostiles')) {
                                return self._cache.get ('active_hostiles');
                            }
                            else if (self.room.enemy) {
                                var hostiles = [];
                                self._cache.set ('active_hostiles', hostiles);
                                return hostiles;
                            }
                            else {
                                if (self.room.my && self.room.room.controller.safeMode > 1000) {
                                    var hostiles = [];
                                }
                                else {
                                    var hostiles = self.all_hostiles ();
                                }
                                if (len (hostiles)) {
                                    if (self.room.my) {
                                        var protect = self.room.spawns.concat (self.towers ());
                                        if (self.room.room.storage) {
                                            protect.push (self.room.room.storage);
                                        }
                                        if (!(len (protect))) {
                                            protect.push (movement.center_pos (self.room.name));
                                        }
                                        var hostiles = _ (hostiles).filter (self.danger_level).sortBy ((function __lambda__ (c) {
                                            return ((((-(self.danger_level (c)) * 5000 - len (self.defenders_near (c)) * 500) + movement.minimum_chebyshev_distance (c, protect)) + self.healing_possible_on (c) * 30) + (_.sum (protect, (function __lambda__ (s) {
                                                return movement.chebyshev_distance_room_pos (c, s);
                                            })) / len (protect)) / 50) - ((c.hitsMax - c.hits) / c.hitsMax) / 100;
                                        })).value ();
                                        if (self.mem.debug) {
                                            print ('Chose hostiles:\n{}'.format ('\n'.join (function () {
                                                var __accu0__ = [];
                                                var __iterable0__ = hostiles;
                                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                                    var c = __iterable0__ [__index0__];
                                                    __accu0__.append ('{},{}: {}, {}, {}, {}, {}'.format (c.pos.x, c.pos.y, -(self.danger_level (c)) * 5000, -(len (self.defenders_near (c))) * 500, +(movement.minimum_chebyshev_distance (c, protect)), (+(_.sum (protect, (function __lambda__ (s) {
                                                        return movement.chebyshev_distance_room_pos (c, s);
                                                    }))) / len (protect)) / 50, (-((c.hitsMax - c.hits) + self.healing_possible_on (c)) / c.hitsMax) / 100));
                                                }
                                                return __accu0__;
                                            } ())));
                                        }
                                    }
                                    else {
                                        var hostiles = _.filter (hostiles, self.danger_level);
                                    }
                                }
                                self._cache.set ('active_hostiles', hostiles);
                                return hostiles;
                            }
                        }, 'dangerous_hostiles');},
                        get remote_hostiles () {return __get__ (this, function (self) {
                            if (self._cache.has ('remote_active_hostiles')) {
                                return self._cache.get ('remote_active_hostiles');
                            }
                            else {
                                var hostile_lists = [];
                                var checked_rooms = new_set ();
                                var __iterable0__ = self.room.subsidiaries;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var room = __iterable0__ [__index0__];
                                    var hostiles = stored_hostiles_in (room.name);
                                    if (len (hostiles)) {
                                        hostile_lists.push (hostiles);
                                    }
                                    checked_rooms.add (room.name);
                                }
                                var __iterable0__ = self.room.mining.active_mines;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var flag = __iterable0__ [__index0__];
                                    if (flag.pos.roomName != self.room.name && !(checked_rooms.has (flag.pos.roomName))) {
                                        var hostiles = stored_hostiles_in (flag.pos.roomName);
                                        if (len (hostiles)) {
                                            hostile_lists.push (hostiles);
                                        }
                                    }
                                }
                                if (len (hostile_lists)) {
                                    var hostiles = Array.prototype.concat.apply
                                     ([], hostile_lists);
                                }
                                else {
                                    var hostiles = hostile_lists;
                                }
                                self._cache.set ('remote_active_hostiles', hostiles);
                                return hostiles;
                            }
                        });},
                        get activate_live_defenses () {return __get__ (this, function (self) {
                            if (!(self.room.mem [rmem_key_currently_under_siege])) {
                                self.room.mem [rmem_key_currently_under_siege] = true;
                                self.room.reset_spending_state ();
                                self.hive.states.calculate_room_states ();
                            }
                            self.mem.attack_until = Game.time + 2000;
                            self.room.reset_planned_role ();
                            var message = '{} activating live defenses.'.format (self.room.name);
                            Game.notify (message);
                            console.log (message);
                            self.set_protection_all_walls ();
                        });},
                        get set_protection_all_walls () {return __get__ (this, function (self) {
                            var all_nearby_hostiles = stored_hostiles_near (self.room.name);
                            var protect = new_map ();
                            if (!(len (all_nearby_hostiles))) {
                                var enemy_positions = function () {
                                    var __accu0__ = [];
                                    var __iterable0__ = all_nearby_hostiles;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var enemy = __iterable0__ [__index0__];
                                        __accu0__.append (positions.deserialize_xy_to_pos (enemy.pos, enemy.room));
                                    }
                                    return __accu0__;
                                } ();
                            }
                            else {
                                var enemy_positions = self.room.find (FIND_EXIT);
                            }
                            var already_checked = [];
                            var __iterable0__ = enemy_positions;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var enemy = __iterable0__ [__index0__];
                                if (_.some (already_checked, (function __lambda__ (x) {
                                    return movement.chebyshev_distance_room_pos (x, enemy) <= 4;
                                }))) {
                                    continue;
                                }
                                already_checked.append (enemy);
                                var path_obj = self.hive.honey.find_path (enemy, self.room.spawn, {'use_roads': false, 'ignore_swamp': true, 'current_room': self.room.name});
                                var __iterable1__ = path_obj;
                                for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                    var position = __iterable1__ [__index1__];
                                    var is_rampart = false;
                                    var is_other = false;
                                    var __iterable2__ = self.room.look_at (LOOK_STRUCTURES, position.x, position.y);
                                    for (var __index2__ = 0; __index2__ < __iterable2__.length; __index2__++) {
                                        var struct = __iterable2__ [__index2__];
                                        if (struct.structureType == STRUCTURE_RAMPART) {
                                            var is_rampart = true;
                                        }
                                        else if (struct.structureType != STRUCTURE_ROAD && struct.structureType != STRUCTURE_CONTAINER) {
                                            var is_other = true;
                                        }
                                    }
                                    if (is_rampart && !(is_other)) {
                                        protect.set (positions.serialize_pos_xy (position), 0);
                                    }
                                }
                            }
                            var current_iteration = Array.from (protect.entries ());
                            print ('[defense] Found inital walls: {} from {} paths'.format (len (current_iteration), len (already_checked)));
                            while (true) {
                                var next_iteration = [];
                                var __iterable0__ = current_iteration;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var __left0__ = __iterable0__ [__index0__];
                                    var origin_xy = __left0__ [0];
                                    var priority = __left0__ [1];
                                    var origin_x = origin_xy & 63;
                                    var origin_y = origin_xy >> 6 & 63;
                                    var new_priority = priority + 1;
                                    for (var x = origin_x - 1; x < origin_x + 2; x++) {
                                        for (var y = origin_y - 1; y < origin_y + 2; y++) {
                                            var serialized = positions.serialize_xy (x, y);
                                            if (protect.has (serialized)) {
                                                continue;
                                            }
                                            var is_rampart = false;
                                            var is_wall = false;
                                            var is_other = false;
                                            var __iterable1__ = self.room.look_at (LOOK_STRUCTURES, x, y);
                                            for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                                var struct = __iterable1__ [__index1__];
                                                if (struct.structureType == STRUCTURE_RAMPART) {
                                                    var is_rampart = true;
                                                }
                                                else if (struct.structureType == STRUCTURE_WALL) {
                                                    var is_wall = true;
                                                    var is_other = true;
                                                }
                                                else if (struct.structureType != STRUCTURE_ROAD && struct.structureType != STRUCTURE_CONTAINER) {
                                                    var is_other = true;
                                                }
                                            }
                                            if (is_wall || is_rampart) {
                                                if (is_rampart && !(is_other)) {
                                                    protect.set (serialized, new_priority);
                                                }
                                                if (new_priority < 5) {
                                                    next_iteration.append ([serialized, new_priority]);
                                                }
                                            }
                                        }
                                    }
                                }
                                if (len (next_iteration)) {
                                    var current_iteration = next_iteration;
                                }
                                else {
                                    break;
                                }
                            }
                            if (self.mem.known_locations) {
                                var __iterable0__ = self.mem.known_locations;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var name = __iterable0__ [__index0__];
                                    locations.delete_location (name);
                                }
                                delete self.mem.known_locations;
                            }
                            self._cache.delete ('live_defender_spots');
                            self.room.delete_cached_property ('rcrnd');
                            var spots = [];
                            var hot = [];
                            var cold = [];
                            var __iterable0__ = _.sortBy (Array.from (protect.entries ()), (function __lambda__ (x) {
                                return x [1];
                            }));
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var pos = __left0__ [0];
                                var priority = __left0__ [1];
                                var loc = locations.create (pos);
                                spots.push (loc.name);
                                if (priority <= 1) {
                                    hot.push (loc.name);
                                }
                                else {
                                    cold.push (loc.name);
                                }
                            }
                            print ('[{}][defense] Found {} ramparts to protect during initial seed.'.format (self.room.name, len (spots)));
                            self.mem.known_locations = spots;
                            self.room.store_cached_property ('rcrnd', [hot, cold], 50);
                        });},
                        get towers () {return __get__ (this, function (self) {
                            if (self._cache.has ('towers')) {
                                return self._cache.get ('towers');
                            }
                            else {
                                var towers = _.filter (self.room.find (FIND_MY_STRUCTURES), {'structureType': STRUCTURE_TOWER});
                                self._cache.set ('towers', towers);
                                return towers;
                            }
                        });},
                        get healing_capable () {return __get__ (this, function (self) {
                            return len (self.towers ());
                        });},
                        get set_ramparts () {return __get__ (this, function (self, defensive) {
                            var __iterable0__ = _.filter (self.room.find (FIND_STRUCTURES), {'structureType': STRUCTURE_RAMPART});
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var rampart = __iterable0__ [__index0__];
                                if (defensive || _.find (self.room.look_at (LOOK_STRUCTURES, rampart.pos), (function __lambda__ (s) {
                                    return s.structureType != STRUCTURE_RAMPART && s.structureType != STRUCTURE_ROAD;
                                }))) {
                                    rampart.setPublic (false);
                                }
                                else {
                                    rampart.setPublic (true);
                                }
                            }
                        });},
                        get tower_heal () {return __get__ (this, function (self) {
                            var damaged = _.filter (self.room.find (FIND_MY_CREEPS), (function __lambda__ (c) {
                                return c.hits < c.hitsMax;
                            }));
                            if (len (damaged)) {
                                var towers = self.towers ();
                                if (!(len (towers))) {
                                    return ;
                                }
                                if (len (damaged) > 1 && len (towers) > 1) {
                                    var __iterable0__ = _.sortBy (damaged, 'hits');
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var creep = __iterable0__ [__index0__];
                                        if (len (towers) == 1) {
                                            towers [0].heal (creep);
                                            break;
                                        }
                                        else if (len (towers) < 1) {
                                            break;
                                        }
                                        else {
                                            var closest_distance = Infinity;
                                            var closest_index = -(1);
                                            for (var i = 0; i < len (towers); i++) {
                                                var distance = movement.chebyshev_distance_room_pos (creep.pos, towers [i].pos);
                                                if (distance < closest_distance) {
                                                    var closest_index = i;
                                                    var closest_distance = distance;
                                                }
                                            }
                                            var tower = towers.splice (closest_index, 1) [0];
                                            tower.heal (creep);
                                        }
                                    }
                                }
                                else if (len (damaged) > 1) {
                                    towers [0].heal (_.min (damaged, (function __lambda__ (c) {
                                        return movement.chebyshev_distance_room_pos (c, towers [0]);
                                    })));
                                }
                                else {
                                    towers [0].heal (damaged [0]);
                                }
                            }
                            else if (__mod__ (Game.time, 7) == 0) {
                                var urgent_repair = _.find (self.room.find (FIND_STRUCTURES), does_need_urgent_repair);
                                if (urgent_repair) {
                                    var __iterable0__ = self.towers ();
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var tower = __iterable0__ [__index0__];
                                        tower.repair (urgent_repair);
                                    }
                                }
                            }
                        });},
                        get alert () {return __get__ (this, function (self) {
                            if (self._cache.has ('alert')) {
                                return self._cache.get ('alert');
                            }
                            else {
                                var alert = self.mem.alert;
                                if (!(alert) && (self.room.my || __mod__ (Game.time, 3) == 1) && len (self.all_hostiles ())) {
                                    self.set_ramparts (true);
                                    var __left0__ = true;
                                    self.mem.alert = __left0__;
                                    var alert = __left0__;
                                }
                                self._cache.set ('alert', alert);
                                return alert;
                            }
                        });},
                        get tick () {return __get__ (this, function (self) {
                            if (__mod__ (Game.time, 6) == 0 && !(len (self.room.spawns)) && !(self.room.being_bootstrapped ()) && !(_.find (self.room.find (FIND_MY_CONSTRUCTION_SITES), {'structureType': STRUCTURE_SPAWN}))) {
                                self.room.building.refresh_building_targets (true);
                                self.room.building.get_construction_targets ();
                            }
                            var alert = self.alert ();
                            if (!(alert)) {
                                if (__mod__ (Game.time, 100) == 69) {
                                    self.set_ramparts (false);
                                    if (self.room.mem [rmem_key_currently_under_siege]) {
                                        if (self.mem.attack_until) {
                                            if (Game.time > self.mem.attack_until) {
                                                delete self.room.mem [rmem_key_currently_under_siege];
                                                delete self.mem.attack_until;
                                                var message = '{}: disabling active defenses.'.format (self.room.name);
                                                Game.notify (message);
                                                console.log (message);
                                            }
                                        }
                                        else {
                                            self.mem.attack_until = Game.time + 2000;
                                        }
                                    }
                                }
                                self.tower_heal ();
                                return ;
                            }
                            if (self.room.mem [rmem_key_currently_under_siege] && _.some (self.all_hostiles (), (function __lambda__ (h) {
                                return h.owner.username != INVADER_USERNAME;
                            }))) {
                                self.mem.attack_until = Game.time + 2000;
                            }
                            if (__mod__ (Game.time, 5) == 1) {
                                if (!(self.room.being_bootstrapped ()) || self.room.mem [rmem_key_building_priority_walls]) {
                                    var __iterable0__ = flags.find_ms_flags (self.room, flags.MAIN_BUILD, flags.SUB_RAMPART).concat (flags.find_ms_flags (self.room, flags.MAIN_BUILD, flags.SUB_WALL));
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var flag = __iterable0__ [__index0__];
                                        var wall = _.find (self.room.room.lookForAt (LOOK_STRUCTURES, flag), (function __lambda__ (s) {
                                            return s.structureType == STRUCTURE_WALL || s.structureType == STRUCTURE_RAMPART;
                                        }));
                                        if (!(wall)) {
                                            if (len (self.room.find (FIND_MY_CONSTRUCTION_SITES)) < 15 && !(_.find (self.room.room.lookForAt (LOOK_CONSTRUCTION_SITES, flag), (function __lambda__ (s) {
                                                return s.structureType == STRUCTURE_WALL || s.structureType == STRUCTURE_RAMPART;
                                            })))) {
                                                self.room.building.refresh_building_targets (true);
                                            }
                                        }
                                        else if (wall.hits < self.room.get_min_sane_wall_hits) {
                                            self.room.building.refresh_repair_targets (true);
                                        }
                                    }
                                    self.room.building.get_construction_targets ();
                                }
                            }
                            if (!(len (self.all_hostiles ()))) {
                                if (!(self.mem.alert_for < 0)) {
                                    self.mem.alert_for = 0;
                                }
                                self.mem.alert_for--;
                                if (self.mem.alert_for < -(5)) {
                                    self.set_ramparts (false);
                                    delete self.mem.alert_for;
                                    delete self.mem.alert;
                                }
                                return ;
                            }
                            if (self.mem.alert_for > 0) {
                                self.mem.alert_for++;
                            }
                            else {
                                self.mem.alert_for = 1;
                            }
                            var hostiles = self.dangerous_hostiles ();
                            var towers = self.towers ();
                            if (len (towers)) {
                                if (__mod__ (Game.time, 3) == 1) {
                                    var damaged_warriors = _.filter (self.room.find (FIND_MY_CREEPS), (function __lambda__ (c) {
                                        return c.hasBodyparts (ATTACK) && c.hits < c.hitsMax;
                                    }));
                                    if (len (damaged_warriors)) {
                                        var __iterable0__ = towers;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var tower = __iterable0__ [__index0__];
                                            tower.heal (damaged_warriors [0]);
                                        }
                                    }
                                }
                                var tower_index = 0;
                                var some_left = false;
                                var __iterable0__ = hostiles;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var hostile = __iterable0__ [__index0__];
                                    var healing_possible = self.healing_possible_on (hostile);
                                    var nearby_defenders = self.defenders_near (hostile);
                                    var attack_possible = _.sum (nearby_defenders, (function __lambda__ (c) {
                                        return !(c.creep.defense_override) && c.creep.getActiveBodyparts (ATTACK) || 0;
                                    })) * ATTACK_POWER + _.sum (towers.slice (tower_index), (function __lambda__ (t) {
                                        return tower_damage (t.pos.getRangeTo (hostile));
                                    }));
                                    if (hostile.hasActiveBoostedBodyparts (TOUGH)) {
                                        var damage_to_account_for = attack_possible;
                                        var __iterable1__ = hostile.body;
                                        for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                            var part = __iterable1__ [__index1__];
                                            if (part.hits <= 0) {
                                                continue;
                                            }
                                            if (damage_to_account_for <= 0) {
                                                break;
                                            }
                                            if (part.boost === undefined || part.type != TOUGH) {
                                                damage_to_account_for -= part.hits;
                                                continue;
                                            }
                                            var effective_hits = math.ceil (part.hits * TOUGH_HIT_MULTIPLIERS [part.boost]);
                                            if (effective_hits <= damage_to_account_for) {
                                                damage_to_account_for -= effective_hits;
                                                attack_possible -= effective_hits - part.hits;
                                            }
                                            else {
                                                var actually_destroyed = math.floor (((effective_hits - damage_to_account_for) / effective_hits) * part.hits);
                                                var attack_possible = damage_to_account_for - actually_destroyed;
                                                break;
                                            }
                                        }
                                    }
                                    if (healing_possible > attack_possible) {
                                        print ('[{}] Not attacking hostile at {}: {} heal possible, {} damage possible.'.format (self.room.name, hostile.pos, healing_possible, attack_possible));
                                        var some_left = true;
                                        continue;
                                    }
                                    var __iterable1__ = nearby_defenders;
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var my_defender = __iterable1__ [__index1__];
                                        my_defender.creep.attack (hostile);
                                        my_defender.creep.defense_override = true;
                                    }
                                    var hits_left = hostile.hits + healing_possible;
                                    while (tower_index < len (towers) && hits_left > 0) {
                                        var tower = towers [tower_index];
                                        tower_index++;
                                        tower.attack (hostile);
                                        hits_left -= tower_damage (tower.pos.getRangeTo (hostile));
                                    }
                                    if (tower_index >= len (towers)) {
                                        var some_left = true;
                                        break;
                                    }
                                }
                                if (some_left) {
                                    self.check_for_noninvader_raid ();
                                }
                            }
                            else if (self.room.spawn) {
                                self.check_for_noninvader_raid ();
                            }
                        });},
                        get check_for_noninvader_raid () {return __get__ (this, function (self) {
                            if (self.room.mem [rmem_key_currently_under_siege]) {
                                return ;
                            }
                            var total_noninvader = 0;
                            var hostiles = self.dangerous_hostiles ();
                            var user = null;
                            var __iterable0__ = hostiles;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var hostile = __iterable0__ [__index0__];
                                if (hostile.owner.username != INVADER_USERNAME) {
                                    var user = hostile.owner.username;
                                    var __iterable1__ = hostile.body;
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var part = __iterable1__ [__index1__];
                                        if (part.type == ATTACK) {
                                            if (part.boost) {
                                                total_noninvader += _.get (BOOSTS, [ATTACK, part.boost, 'attack'], 1);
                                            }
                                            else {
                                                total_noninvader++;
                                            }
                                        }
                                        else if (part.type == RANGED_ATTACK) {
                                            if (part.boost) {
                                                total_noninvader += _.get (BOOSTS, [RANGED_ATTACK, part.boost, 'rangedAttack'], 1);
                                            }
                                            else {
                                                total_noninvader++;
                                            }
                                        }
                                        else if (part.type == HEAL) {
                                            if (part.boost) {
                                                total_noninvader += _.get (BOOSTS, [HEAL, part.boost, 'heal'], 1) * 2;
                                            }
                                            else {
                                                total_noninvader += 2;
                                            }
                                        }
                                        else if (part.type == WORK) {
                                            if (part.boost) {
                                                total_noninvader += _.get (BOOSTS, [WORK, part.boost, 'dismantle'], 1);
                                            }
                                            else {
                                                total_noninvader += 0.5;
                                            }
                                        }
                                    }
                                }
                            }
                            if (total_noninvader >= 10) {
                                var message = '\nDANGER: -----\nOver 10 hostile player bodyparts detected directly in {}. Game time: {}\n\nCreeps:\n{}\n\nThis has triggered active-defense mode in {}\nDANGER: -----'.format (self.room.name, Game.time, '\n'.join (function () {
                                    var __accu0__ = [];
                                    var __iterable0__ = hostiles;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var h = __iterable0__ [__index0__];
                                        if (h.owner.username != INVADER_USERNAME) {
                                            __accu0__.append ('owner: {}, body: {}'.format (h.owner.username, JSON.stringify (_.countBy (h.body, 'type'))));
                                        }
                                    }
                                    return __accu0__;
                                } ()), self.room.name);
                                console.log (message);
                                Game.notify (message);
                                self.activate_live_defenses ();
                            }
                        });},
                        get get_current_defender_spots () {return __get__ (this, function (self) {
                            if (self._cache.has ('live_defender_spots')) {
                                return self._cache.get ('live_defender_spots');
                            }
                            var cached = self.room.get_cached_property ('rcrnd');
                            if (cached) {
                                var __left0__ = cached;
                                var hot = __left0__ [0];
                                var cold = __left0__ [1];
                                var hot = _ (hot).map (locations.get).filter ().value ();
                                var cold = _ (cold).map (locations.get).filter ().value ();
                                self._cache.set ('live_defender_spots', [hot, cold]);
                                return [hot, cold];
                            }
                            var last_used = self.mem.kllu;
                            if (last_used == undefined) {
                                var __left0__ = {};
                                var last_used = __left0__;
                                self.mem.kllu = __left0__;
                            }
                            if (!(len (self.dangerous_hostiles ()))) {
                                var hot = [];
                                var cold = [];
                                if (self.mem.known_locations) {
                                    var to_remove = [];
                                    var __iterable0__ = self.mem.known_locations;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var name = __iterable0__ [__index0__];
                                        var location = locations.get (name);
                                        if (location !== null) {
                                            if (!(name in last_used)) {
                                                last_used [name] = Game.time;
                                            }
                                            else if (Game.time - last_used [name] > 1500) {
                                                to_remove.push (name);
                                            }
                                            cold.push (location);
                                        }
                                    }
                                    if (len (to_remove)) {
                                        _.pull (self.mem.known_locations, to_remove);
                                        if (self.mem.ods) {
                                            var existing_old = new_set ();
                                            var __iterable0__ = self.mem.ods;
                                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                                var name = __iterable0__ [__index0__];
                                                existing_old.add (locations.serialized (name));
                                            }
                                            var __iterable0__ = to_remove;
                                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                                var name = __iterable0__ [__index0__];
                                                if (!(existing_old.has (locations.serialized (name)))) {
                                                    self.mem.ods.push (name);
                                                }
                                            }
                                            if (len (self.mem.ods) > len (self.room.role_count (role_wall_defender))) {
                                                self.mem.ods.splice (0, len (self.mem.ods) - len (self.room.role_count (role_wall_defender)));
                                            }
                                        }
                                        else {
                                            self.mem.ods = to_remove;
                                        }
                                    }
                                }
                                self.room.store_cached_property ('rcrnd', [hot, cold], 30);
                                self._cache.set ('live_defender_spots', [hot, cold]);
                                return [hot, cold];
                            }
                            var serialized_locations = self.mem.known_locations;
                            var hot_found = new_set ();
                            var hot_spots = [];
                            var cold_spots = [];
                            if (serialized_locations != undefined) {
                                var old_locs = [];
                                var __iterable0__ = serialized_locations;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var name = __iterable0__ [__index0__];
                                    var location = locations.get (name);
                                    if (location) {
                                        var nearby = self.room.look_for_in_area_around (LOOK_CREEPS, location, 1);
                                        if (_.some (nearby, (function __lambda__ (x) {
                                            return !(x.creep.my) && !(Memory.meta.friends.includes (x.creep.owner.username));
                                        }))) {
                                            hot_spots.append (location);
                                            hot_found.add (positions.serialize_pos_xy (location));
                                        }
                                        else {
                                            cold_spots.append (location);
                                        }
                                    }
                                    else {
                                        old_locs.append (name);
                                    }
                                }
                                if (len (old_locs)) {
                                    _.pull (serialized_locations, old_locs);
                                }
                            }
                            else {
                                var __left0__ = [];
                                var serialized_locations = __left0__;
                                self.mem.known_locations = __left0__;
                            }
                            var ramparts_undefended = [];
                            var __iterable0__ = self.room.find (FIND_MY_STRUCTURES);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var rampart = __iterable0__ [__index0__];
                                if (rampart.setPublic) {
                                    var serialized = positions.serialize_pos_xy (rampart);
                                    if (!(hot_found.has (serialized))) {
                                        var nearby = self.room.look_for_in_area_around (LOOK_CREEPS, rampart, 1);
                                        var total_offense = 0;
                                        var __iterable1__ = nearby;
                                        for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                            var obj = __iterable1__ [__index1__];
                                            var creep = obj.creep;
                                            if (!(creep.my) && !(Memory.meta.friends.includes (creep.owner.username))) {
                                                var offense = max (creep.getBodyparts (WORK) * DISMANTLE_POWER, creep.getBodyparts (ATTACK) * ATTACK_POWER);
                                                if (_.some (hot_spots, (function __lambda__ (x) {
                                                    return movement.chebyshev_distance_room_pos (x, creep) <= 1;
                                                }))) {
                                                    offense /= 3;
                                                }
                                                total_offense += offense;
                                            }
                                        }
                                        if (total_offense) {
                                            ramparts_undefended.push ([rampart, total_offense]);
                                        }
                                    }
                                }
                            }
                            var num_undefended = len (ramparts_undefended);
                            if (num_undefended) {
                                if (num_undefended > 1 && len (cold_spots)) {
                                    var ramparts_undefended = _.sortBy (ramparts_undefended, (function __lambda__ (x) {
                                        return x [1];
                                    }));
                                }
                                var __iterable0__ = ramparts_undefended;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var __left0__ = __iterable0__ [__index0__];
                                    var rampart = __left0__ [0];
                                    if (len (cold_spots)) {
                                        var nearest = null;
                                        var nearest_distance = Infinity;
                                        var __iterable1__ = cold_spots;
                                        for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                            var spot = __iterable1__ [__index1__];
                                            var distance = movement.chebyshev_distance_room_pos (spot, rampart);
                                            if (distance < nearest_distance) {
                                                var nearest_distance = distance;
                                                var nearest = spot;
                                            }
                                        }
                                        nearest.py_update (rampart.pos.x, rampart.pos.y, rampart.pos.roomName);
                                        _.pull (cold_spots, [nearest]);
                                        hot_spots.append (nearest);
                                    }
                                    else {
                                        var new_obj = locations.create (rampart, RAMPART_DEFENSE, 2000);
                                        hot_spots.push (new_obj);
                                        serialized_locations.push (new_obj.name);
                                    }
                                }
                            }
                            self._cache.set ('live_defender_spots', [hot_spots, cold_spots]);
                            self.room.store_cached_property ('rcrnd', [function () {
                                var __accu0__ = [];
                                var __iterable0__ = hot_spots;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var s = __iterable0__ [__index0__];
                                    __accu0__.append (s.name);
                                }
                                return __accu0__;
                            } (), function () {
                                var __accu0__ = [];
                                var __iterable0__ = cold_spots;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var s = __iterable0__ [__index0__];
                                    __accu0__.append (s.name);
                                }
                                return __accu0__;
                            } ()], 3);
                            var __iterable0__ = hot_spots;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var loc = __iterable0__ [__index0__];
                                last_used [loc.name] = Game.time;
                            }
                            return [hot_spots, cold_spots];
                        });},
                        get get_old_defender_spots () {return __get__ (this, function (self) {
                            if (self._cache.has ('old_defender_spots')) {
                                return self._cache.get ('old_defender_spots');
                            }
                            var result = [];
                            if (self.mem.ods) {
                                var __iterable0__ = self.mem.ods;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var name = __iterable0__ [__index0__];
                                    var loc = locations.get (name);
                                    if (loc !== null) {
                                        result.push (loc);
                                    }
                                }
                            }
                            self._cache.set ('old_defender_spots', result);
                            return result;
                        });}
                    });
                    Object.defineProperty (RoomDefense, 'hive', property.call (RoomDefense, RoomDefense._hive));;
                    Object.defineProperty (RoomDefense, 'broken_walls', property.call (RoomDefense, RoomDefense.any_broken_walls));;
                    __pragma__ ('<use>' +
                        'cache.volatile_cache' +
                        'constants' +
                        'creep_management.deathwatch' +
                        'jstools.errorlog' +
                        'jstools.screeps_constants' +
                        'math' +
                        'position_management.flags' +
                        'position_management.locations' +
                        'utilities.hostile_utils' +
                        'utilities.movement' +
                        'utilities.positions' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.RoomDefense = RoomDefense;
                        __all__.SK_USERNAME = SK_USERNAME;
                        __all__.TOUGH_HIT_MULTIPLIERS = TOUGH_HIT_MULTIPLIERS;
                        __all__._init_tough_part_multipliers = _init_tough_part_multipliers;
                        __all__.cleanup_stored_hostiles = cleanup_stored_hostiles;
                        __all__.deathwatch = deathwatch;
                        __all__.does_need_urgent_repair = does_need_urgent_repair;
                        __all__.errorlog = errorlog;
                        __all__.flags = flags;
                        __all__.hostile_utils = hostile_utils;
                        __all__.locations = locations;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.poll_hostiles = poll_hostiles;
                        __all__.positions = positions;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                        __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.role_wall_defender = role_wall_defender;
                        __all__.stored_hostiles_in = stored_hostiles_in;
                        __all__.stored_hostiles_near = stored_hostiles_near;
                        __all__.tower_damage = tower_damage;
                        __all__.volatile_cache = volatile_cache;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'rooms.links', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var rmem_key_linking_mind_storage = __init__ (__world__.constants).rmem_key_linking_mind_storage;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var movement = __init__ (__world__.utilities.movement);
                    var LinkingMind = __class__ ('LinkingMind', [object], {
                        get __init__ () {return __get__ (this, function (self, room) {
                            self.room = room;
                            self._links = null;
                            self._main_link = null;
                            self.link_creep = null;
                            self.enabled_last_turn = room.get_cached_property ('links_enabled') || false;
                        }, '__init__');},
                        get _get_links () {return __get__ (this, function (self) {
                            if (self._links === null) {
                                self._links = _.filter (self.room.find (FIND_MY_STRUCTURES), {'structureType': STRUCTURE_LINK});
                            }
                            return self._links;
                        }, '_get_links');},
                        get get_main_link () {return __get__ (this, function (self) {
                            if (self._main_link === null) {
                                if (self.room.my && self.room.room.storage && len (self.links) >= 2) {
                                    self._main_link = _.min (self._links, (function __lambda__ (l) {
                                        return movement.chebyshev_distance_room_pos (self.room.room.storage, l);
                                    }));
                                    if (movement.chebyshev_distance_room_pos (self._main_link, self.room.room.storage) > 2) {
                                        self._main_link = null;
                                    }
                                }
                                else {
                                    self._main_link = null;
                                }
                            }
                            return self._main_link;
                        }, 'get_main_link');},
                        get link_mem () {return __get__ (this, function (self, link) {
                            if (link.id) {
                                var link = link.id;
                            }
                            if (!(rmem_key_linking_mind_storage in self.room.mem)) {
                                self.room.mem [rmem_key_linking_mind_storage] = {};
                            }
                            if (!(link in self.room.mem [rmem_key_linking_mind_storage])) {
                                self.room.mem [rmem_key_linking_mind_storage] [link] = {};
                            }
                            return self.room.mem [rmem_key_linking_mind_storage] [link];
                        }, 'link_mem');},
                        get volatile_link_mem () {return __get__ (this, function (self, link) {
                            if (link.id) {
                                var link = link.id;
                            }
                            return volatile_cache.submem ('links', link);
                        }, 'volatile_link_mem');},
                        get _enabled () {return __get__ (this, function (self) {
                            return self.enabled_last_turn;
                        }, '_enabled');},
                        get enabled_this_turn () {return __get__ (this, function (self) {
                            if (!(!(self.room.room.storage)) && self.link_creep && self.main_link && len (self.links) >= 2) {
                                self.room.store_cached_property ('links_enabled', true, 2);
                                return true;
                            }
                            return false;
                        }, 'enabled_this_turn');},
                        get register_target_withdraw () {return __get__ (this, function (self, target, targeter, needed, distance) {
                            if (targeter.name) {
                                var targeter = targeter.name;
                            }
                            self.volatile_link_mem (target).set (targeter, {'cap': -(needed), 'distance': distance});
                            self.link_mem (target).last_withdraw = Game.time;
                        }, 'register_target_withdraw');},
                        get register_target_deposit () {return __get__ (this, function (self, target, targeter, depositing, distance) {
                            if (targeter.name) {
                                var targeter = targeter.name;
                            }
                            self.volatile_link_mem (target).set (targeter, {'cap': +(depositing), 'distance': distance});
                            self.link_mem (target).last_deposit = Game.time;
                        }, 'register_target_deposit');},
                        get note_link_manager () {return __get__ (this, function (self, creep) {
                            if (self.link_creep !== null) {
                                var creep1 = self.link_creep;
                                var creep2 = creep;
                                var send_to_link = function (amount) {
                                    creep1.send_to_link (amount);
                                    if (amount > creep1.creep.carryCapacity / 2) {
                                        creep2.send_to_link (amount - creep1.creep.carryCapacity / 2);
                                    }
                                };
                                var send_from_link = function (amount) {
                                    creep1.send_from_link (amount);
                                    if (amount > creep1.creep.carryCapacity / 2) {
                                        creep2.send_to_link (amount - creep1.creep.carryCapacity / 2);
                                    }
                                };
                                self.link_creep = {'send_to_link': send_to_link, 'send_from_link': send_from_link, 'creep': {'carryCapacity': creep1.creep.carryCapacity + creep2.creep.carryCapacity}};
                            }
                            self.link_creep = creep;
                        }, 'note_link_manager');},
                        get tick_links () {return __get__ (this, function (self) {
                            if (!(self.enabled_this_turn ())) {
                                return ;
                            }
                            var main_link = self.get_main_link ();
                            var current_output_links = [];
                            var current_input_links = [];
                            var future_output_links = [];
                            var future_input_links = [];
                            var __iterable0__ = self.links;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var link = __iterable0__ [__index0__];
                                if (link.id == main_link.id) {
                                    continue;
                                }
                                var mem = self.link_mem (link);
                                var vmem = self.volatile_link_mem (link);
                                var energy_change_now = 0;
                                var __iterable1__ = Array.from (vmem.values ());
                                for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                    var obj = __iterable1__ [__index1__];
                                    if (obj.distance <= 1) {
                                        energy_change_now += obj.cap;
                                    }
                                }
                                if (Memory.links_debug == self.room.name) {
                                    print ('[{}] Energy change: {}'.format (link.id.__getslice__ (-(5), null, 1), energy_change_now));
                                }
                                if (energy_change_now > 0) {
                                    if (energy_change_now * 3 > link.energyCapacity - link.energy && link.cooldown <= 0) {
                                        current_input_links.append ({'link': link, 'priority': -(energy_change_now)});
                                    }
                                    else {
                                        future_input_links.append ({'link': link, 'amount': energy_change_now, 'priority': link.cooldown});
                                    }
                                }
                                else if (energy_change_now < 0) {
                                    if (-(energy_change_now) * 3 > link.energy) {
                                        current_output_links.append ({'link': link, 'priority': energy_change_now});
                                    }
                                    else {
                                        future_output_links.append ({'link': link, 'amount': -(energy_change_now) - link.energy, 'priority': math.floor (link.energy / energy_change_now)});
                                    }
                                }
                                else {
                                    var access_list = _.sortBy (_.filter (vmem.values (), (function __lambda__ (x) {
                                        return x.distance > 1;
                                    })), (function __lambda__ (x) {
                                        return x.distance;
                                    }));
                                    if (len (access_list)) {
                                        var count = access_list [0].cap;
                                        var __iterable1__ = access_list;
                                        for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                            var x = __iterable1__ [__index1__];
                                            if (x.cap > 0 == count > 0) {
                                                count += x.cap;
                                            }
                                            else {
                                                break;
                                            }
                                        }
                                        if (count > 0) {
                                            if (count > link.energyCapacity - link.energy) {
                                                future_input_links.append ({'link': link, 'amount': -(count), 'priority': access_list [0].distance});
                                            }
                                        }
                                        else if (count < link.energy) {
                                            future_output_links.append ({'link': link, 'amount': count, 'priority': access_list [0].distance});
                                        }
                                    }
                                    else if (mem.last_deposit && (!(mem.last_withdraw) || mem.last_deposit > mem.last_withdraw)) {
                                        future_input_links.append ({'link': link, 'amount': link.energy, 'priority': 10});
                                    }
                                    else if (mem.last_withdraw && (!(mem.last_deposit) || mem.last_withdraw > mem.last_deposit)) {
                                        future_output_links.append ({'link': link, 'amount': link.energy, 'priority': 10});
                                    }
                                }
                            }
                            current_input_links.py_sort (null, __kwargtrans__ ({key: (function __lambda__ (x) {
                                return x.priority;
                            })}));
                            current_output_links.py_sort (null, __kwargtrans__ ({key: (function __lambda__ (x) {
                                return x.priority;
                            })}));
                            if (Memory.links_debug == self.room.name) {
                                if (len (current_input_links)) {
                                    print ('Current Input: {}'.format (function () {
                                        var __accu0__ = [];
                                        var __iterable0__ = current_input_links;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var x = __iterable0__ [__index0__];
                                            __accu0__.append ('{} (p:{} a:{})'.format (x.link, x.priority, x.amount));
                                        }
                                        return __accu0__;
                                    } ()));
                                }
                                if (len (current_output_links)) {
                                    print ('Current Output: {}'.format (function () {
                                        var __accu0__ = [];
                                        var __iterable0__ = current_output_links;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var x = __iterable0__ [__index0__];
                                            __accu0__.append ('{} (p:{} a:{})'.format (x.link, x.priority, x.amount));
                                        }
                                        return __accu0__;
                                    } ()));
                                }
                                if (len (future_input_links)) {
                                    print ('Future Input: {}'.format (function () {
                                        var __accu0__ = [];
                                        var __iterable0__ = future_input_links;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var x = __iterable0__ [__index0__];
                                            __accu0__.append ('{} (p:{} a:{})'.format (x.link, x.priority, x.amount));
                                        }
                                        return __accu0__;
                                    } ()));
                                }
                                if (len (future_output_links)) {
                                    print ('Future Output: {}'.format (function () {
                                        var __accu0__ = [];
                                        var __iterable0__ = future_output_links;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var x = __iterable0__ [__index0__];
                                            __accu0__.append ('{} (p:{} a:{})'.format (x.link, x.priority, x.amount));
                                        }
                                        return __accu0__;
                                    } ()));
                                }
                            }
                            if (len (current_output_links) && (!(len (current_input_links)) || __mod__ (Game.time, 12) >= 6)) {
                                if (main_link.energy < main_link.energyCapacity) {
                                    self.link_creep.send_to_link (main_link.energyCapacity - main_link.energy);
                                }
                                if (main_link.cooldown == 0) {
                                    if (main_link.energy >= current_output_links [0].link.energyCapacity - current_output_links [0].link.energy) {
                                        self.main_link.transferEnergy (current_output_links [0].link);
                                    }
                                }
                                else if (len (current_input_links)) {
                                    current_input_links [0].link.transferEnergy (current_output_links [0].link);
                                }
                                else if (len (future_input_links)) {
                                    future_input_links [0].link.transferEnergy (current_output_links [0].link);
                                }
                            }
                            else if (len (current_input_links)) {
                                if (main_link.energy > 0) {
                                    self.link_creep.send_from_link (main_link.energy);
                                }
                                else {
                                    var __iterable0__ = current_input_links;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var obj = __iterable0__ [__index0__];
                                        if (obj.link.energy >= obj.link.energyCapacity * 0.85) {
                                            obj.link.transferEnergy (main_link);
                                            break;
                                        }
                                    }
                                }
                            }
                            else if (len (future_input_links)) {
                                if (main_link.energyCapacity - main_link.energy < future_input_links [0].link.energy) {
                                    self.link_creep.send_from_link (main_link.energy);
                                }
                                else {
                                    future_input_links [0].link.transferEnergy (main_link);
                                }
                            }
                            else if (len (future_output_links)) {
                                if (main_link.energy < future_output_links [0].amount - future_output_links [0].link.energy) {
                                    self.link_creep.send_to_link ((future_output_links [0].amount - future_output_links [0].link.energy) - main_link.energy);
                                }
                                else {
                                    self.main_link.transferEnergy (future_output_links [0].link);
                                }
                            }
                            else if (main_link.energy != main_link.energyCapacity * 2) {
                                if (main_link.energy > main_link.energyCapacity * 2) {
                                    self.link_creep.send_from_link (main_link.energy - main_link.energyCapacity * 2);
                                }
                                else {
                                    self.link_creep.send_to_link (main_link.energyCapacity * 2 - main_link.energy);
                                }
                            }
                        }, 'tick_links');}
                    });
                    Object.defineProperty (LinkingMind, 'main_link', property.call (LinkingMind, LinkingMind.get_main_link));;
                    Object.defineProperty (LinkingMind, 'links', property.call (LinkingMind, LinkingMind._get_links));;
                    Object.defineProperty (LinkingMind, 'enabled', property.call (LinkingMind, LinkingMind._enabled));;
                    __pragma__ ('<use>' +
                        'cache.volatile_cache' +
                        'constants' +
                        'jstools.screeps_constants' +
                        'math' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.LinkingMind = LinkingMind;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
                        __all__.volatile_cache = volatile_cache;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'rooms.minerals', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants).rmem_key_empty_all_resources_into_room;
                    var rmem_key_mineral_mind_storage = __init__ (__world__.constants).rmem_key_mineral_mind_storage;
                    var rmem_key_now_supporting = __init__ (__world__.constants).rmem_key_now_supporting;
                    var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var energy_to_keep_always_in_reserve = __init__ (__world__.rooms.room_constants).energy_to_keep_always_in_reserve;
                    var energy_to_keep_always_in_reserve_when_supporting_sieged = __init__ (__world__.rooms.room_constants).energy_to_keep_always_in_reserve_when_supporting_sieged;
                    var max_minerals_to_keep = __init__ (__world__.rooms.room_constants).max_minerals_to_keep;
                    var room_spending_state_supporting = __init__ (__world__.rooms.room_constants).room_spending_state_supporting;
                    var room_spending_state_supporting_sieged = __init__ (__world__.rooms.room_constants).room_spending_state_supporting_sieged;
                    var movement = __init__ (__world__.utilities.movement);
                    var _SINGLE_MINERAL_FULFILLMENT_MAX = 50 * 1000;
                    var _SELL_ORDER_SIZE = 10 * 1000;
                    var _KEEP_IN_TERMINAL_MY_MINERAL = TERMINAL_CAPACITY * 0.4;
                    var _KEEP_IN_TERMINAL_ENERGY_WHEN_SELLING = TERMINAL_CAPACITY * 0.5;
                    var _KEEP_IN_TERMINAL_ENERGY = 0;
                    var sell_at_prices = {[RESOURCE_OXYGEN]: 2.0, [RESOURCE_HYDROGEN]: 2.0, [RESOURCE_ZYNTHIUM]: 2.0, [RESOURCE_UTRIUM]: 2.0, [RESOURCE_LEMERGIUM]: 2.0, [RESOURCE_KEANIUM]: 2.0};
                    var bottom_prices = {[RESOURCE_OXYGEN]: 0.8, [RESOURCE_HYDROGEN]: 0.55, [RESOURCE_KEANIUM]: 0.25, [RESOURCE_ZYNTHIUM]: 0.15, [RESOURCE_UTRIUM]: 0.2, [RESOURCE_LEMERGIUM]: 0.2};
                    var MineralMind = __class__ ('MineralMind', [object], {
                        get __init__ () {return __get__ (this, function (self, room) {
                            self.room = room;
                            self.hive = room.hive;
                            self.targets = self.hive.targets;
                            self.storage = room.room.storage;
                            self.terminal = room.room.terminal;
                            self._has_no_terminal_or_storage = !(self.terminal && self.storage && self.terminal.my && self.storage.my && self.room.rcl >= 6);
                            if (self.has_no_terminal_or_storage ()) {
                                return ;
                            }
                            if (!(rmem_key_mineral_mind_storage in room.mem)) {
                                room.mem [rmem_key_mineral_mind_storage] = {'total_energy_needed': 0, 'fulfilling': {}};
                            }
                            else {
                                if (!('total_energy_needed' in room.mem [rmem_key_mineral_mind_storage])) {
                                    room.mem [rmem_key_mineral_mind_storage] ['total_energy_needed'] = 0;
                                }
                                if (!('fulfilling' in room.mem [rmem_key_mineral_mind_storage])) {
                                    room.mem [rmem_key_mineral_mind_storage].fulfilling = {};
                                }
                            }
                            self.mem = room.mem [rmem_key_mineral_mind_storage];
                            self.fulfilling = self.mem.fulfilling;
                            if (!('last_sold' in self.mem)) {
                                self.mem.last_sold = {};
                            }
                            if (!('last_sold_at' in self.mem)) {
                                self.mem.last_sold_at = {};
                            }
                        }, '__init__');},
                        get has_no_terminal_or_storage () {return __get__ (this, function (self) {
                            return self._has_no_terminal_or_storage;
                        }, 'has_no_terminal_or_storage');},
                        get fully_setup () {return __get__ (this, function (self) {
                            return !(self._has_no_terminal_or_storage);
                        }, 'fully_setup');},
                        get storage_terminal_access_pos () {return __get__ (this, function (self) {
                            var cached = self.room.get_cached_property ('storage_terminal_access_pos');
                            if (cached !== null) {
                                return cached || null;
                            }
                            var in_between = movement.find_clear_inbetween_spaces (self.room, self.storage, self.terminal);
                            if (len (in_between) > 0) {
                                self.room.store_cached_property ('storage_terminal_access_pos', in_between, 1000);
                                return in_between;
                            }
                            else {
                                self.room.store_cached_property ('storage_terminal_access_pos', false, 1000);
                                return null;
                            }
                        }, 'storage_terminal_access_pos');},
                        get note_mineral_hauler () {return __get__ (this, function (self, name) {
                            self.mem.mineral_hauler = name;
                        }, 'note_mineral_hauler');},
                        get send_minerals () {return __get__ (this, function (self, target_room, mineral, amount) {
                            self.fulfill_market_order (target_room, mineral, amount, null);
                        }, 'send_minerals');},
                        get fill_order () {return __get__ (this, function (self, order_id, target_amount) {
                            if (typeof target_amount == 'undefined' || (target_amount != null && target_amount .hasOwnProperty ("__kwargtrans__"))) {;
                                var target_amount = Infinity;
                            };
                            var info = Game.market.getOrderById (order_id);
                            if (!(info)) {
                                self.log ("WARNING: Tried to fill market order which didn't exit: {}".format (order_id));
                                return ;
                            }
                            if (info.type != ORDER_BUY) {
                                self.log ('WARNING: Tried to fill market order... which was a sell order. ({})'.format (order_id));
                                return ;
                            }
                            var mineral = info.resourceType;
                            var target_room = info.roomName;
                            var amount = min (target_amount, info.amount);
                            return self.fulfill_market_order (target_room, mineral, amount, order_id);
                        }, 'fill_order');},
                        get fulfill_market_order () {return __get__ (this, function (self, target_room, mineral, amount, order_id) {
                            if (typeof order_id == 'undefined' || (order_id != null && order_id .hasOwnProperty ("__kwargtrans__"))) {;
                                var order_id = null;
                            };
                            var would_have_needed_haulers_before = self.get_target_mineral_hauler_count () || self.room.role_count (role_mineral_hauler);
                            var energy_cost = Game.market.calcTransactionCost (min (_SINGLE_MINERAL_FULFILLMENT_MAX, amount), self.room.name, target_room);
                            if (mineral == RESOURCE_ENERGY) {
                                energy_cost += amount;
                            }
                            if (energy_cost > self.mem ['total_energy_needed']) {
                                self.recalculate_energy_needed ();
                            }
                            if (order_id) {
                                var obj = {'order_id': order_id, 'room': target_room, 'amount': amount};
                            }
                            else {
                                var obj = {'room': target_room, 'amount': amount};
                            }
                            if ((mineral in self.fulfilling)) {
                                self.fulfilling [mineral].push (obj);
                            }
                            else {
                                self.fulfilling [mineral] = [obj];
                            }
                            self.log ('Now fulfilling: Order for {} {}, sent to {}!'.format (amount, mineral, target_room));
                            if (!(would_have_needed_haulers_before)) {
                                self.room.reset_planned_role ();
                            }
                        }, 'fulfill_market_order');},
                        get recalculate_energy_needed () {return __get__ (this, function (self) {
                            var energy_needed = 0;
                            var __iterable0__ = _.pairs (self.fulfilling);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var mineral = __left0__ [0];
                                var order_list = __left0__ [1];
                                var __iterable1__ = order_list;
                                for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                    var order = __iterable1__ [__index1__];
                                    var amount = min (_SINGLE_MINERAL_FULFILLMENT_MAX, order.amount);
                                    if (mineral == RESOURCE_ENERGY) {
                                        var needed_here = Game.market.calcTransactionCost (amount, self.room.name, order.room) + amount;
                                    }
                                    else {
                                        var needed_here = Game.market.calcTransactionCost (amount, self.room.name, order.room);
                                    }
                                    var energy_needed = max (energy_needed, needed_here);
                                }
                            }
                            self.mem ['total_energy_needed'] = energy_needed;
                        }, 'recalculate_energy_needed');},
                        get log () {return __get__ (this, function (self, message) {
                            print ('[{}][market] {}'.format (self.room.name, message));
                        }, 'log');},
                        get get_mineral_hauler () {return __get__ (this, function (self) {
                            return Game.creeps [self.mem.mineral_hauler];
                        }, 'get_mineral_hauler');},
                        get mineral_hauler_carry () {return __get__ (this, function (self) {
                            var hauler = self.get_mineral_hauler ();
                            if (hauler) {
                                return hauler.carry;
                            }
                            else {
                                return {};
                            }
                        }, 'mineral_hauler_carry');},
                        get my_mineral_deposit_minerals () {return __get__ (this, function (self) {
                            if (!(self._my_mineral_deposit_minerals)) {
                                var result = [];
                                var __iterable0__ = self.room.find (FIND_MINERALS);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var deposit = __iterable0__ [__index0__];
                                    if (_.find (self.room.look_at (LOOK_STRUCTURES, deposit), {'my': true, 'structureType': STRUCTURE_EXTRACTOR})) {
                                        result.append (deposit.mineralType);
                                    }
                                }
                                self._my_mineral_deposit_minerals = result;
                            }
                            return self._my_mineral_deposit_minerals;
                        }, 'my_mineral_deposit_minerals');},
                        get get_all_terminal_targets () {return __get__ (this, function (self) {
                            if (self._target_mineral_counts !== undefined) {
                                return self._target_mineral_counts;
                            }
                            var target_counts = {};
                            var counts = self.get_total_room_resource_counts ();
                            var __iterable0__ = _.pairs (counts);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var rtype = __left0__ [0];
                                var have = __left0__ [1];
                                if (have > 0) {
                                    var target = self._terminal_target_for_resource (rtype, have);
                                    if (target > 0) {
                                        target_counts [rtype] = min (target, have);
                                    }
                                }
                            }
                            if (_.sum (target_counts) == target_counts [RESOURCE_ENERGY]) {
                                var target_counts = {};
                            }
                            self._target_mineral_counts = target_counts;
                            return target_counts;
                        }, 'get_all_terminal_targets');},
                        get removing_from_terminal () {return __get__ (this, function (self) {
                            if (self._removing_from_terminal === undefined) {
                                var removing = [];
                                var __iterable0__ = Object.keys (self.terminal.store);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var resource = __iterable0__ [__index0__];
                                    var target = self.get_all_terminal_targets () [resource] || 0;
                                    if (self.terminal.store [resource] > target) {
                                        removing.append ([resource, self.terminal.store [resource] - target]);
                                    }
                                }
                                self._removing_from_terminal = removing;
                            }
                            return self._removing_from_terminal;
                        }, 'removing_from_terminal');},
                        get adding_to_terminal () {return __get__ (this, function (self) {
                            if (self._adding_to_terminal === undefined) {
                                var adding = [];
                                var all_targets = self.get_all_terminal_targets ();
                                var __iterable0__ = Object.keys (self.get_all_terminal_targets ());
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var resource = __iterable0__ [__index0__];
                                    var target = all_targets [resource];
                                    var current = self.terminal.store [resource] || 0;
                                    if (current < target) {
                                        adding.append ([resource, target - current]);
                                    }
                                }
                                self._adding_to_terminal = adding;
                            }
                            return self._adding_to_terminal;
                        }, 'adding_to_terminal');},
                        get labs () {return __get__ (this, function (self) {
                            if (self._labs === undefined) {
                                self._labs = _.filter (self.room.find (FIND_MY_STRUCTURES), {'structureType': STRUCTURE_LAB});
                            }
                            return self._labs;
                        }, 'labs');},
                        get amount_needed_in_lab1 () {return __get__ (this, function (self) {
                            if (self._needed_in_lab1 === undefined) {
                                var mineral = self.get_lab_target_mineral ();
                                if (mineral === null) {
                                    return 0;
                                }
                                var all_labs = _ (self.labs ());
                                var labs = all_labs.filter ((function __lambda__ (x) {
                                    return x.mineralType == mineral;
                                }));
                                if (!(labs.size ())) {
                                    var labs = all_labs.filter ((function __lambda__ (x) {
                                        return !(x.mineralAmount);
                                    }));
                                }
                                var capacity = labs.sum ('mineralCapacity');
                                var filled = labs.sum ('mineralAmount');
                                var empty = capacity - filled;
                                var available = self.get_total_room_resource_counts () [mineral] - filled;
                                self._needed_in_lab1 = min (empty, available);
                            }
                            return self._needed_in_lab1;
                        }, 'amount_needed_in_lab1');},
                        get amount_needed_in_lab2 () {return __get__ (this, function (self) {
                            if (self._needed_in_lab2 === undefined) {
                                var mineral = self.get_lab2_target_mineral ();
                                if (mineral === null) {
                                    return 0;
                                }
                                var all_labs = _ (self.labs ());
                                var labs = all_labs.filter ((function __lambda__ (x) {
                                    return x.mineralType == mineral;
                                }));
                                if (!(labs.size ())) {
                                    var labs = all_labs.filter ((function __lambda__ (x) {
                                        return !(x.mineralAmount);
                                    }));
                                }
                                var capacity = labs.sum ('mineralCapacity');
                                var filled = labs.sum ('mineralAmount');
                                var empty = capacity - filled;
                                var available = self.get_total_room_resource_counts () [mineral] - filled;
                                self._needed_in_lab2 = min (empty, available);
                            }
                            return self._needed_in_lab2;
                        }, 'amount_needed_in_lab2');},
                        get energy_needed_in_labs () {return __get__ (this, function (self) {
                            if (self._energy_needed_in_labs === undefined) {
                                var mineral = self.get_lab_target_mineral ();
                                if (mineral === null) {
                                    return 0;
                                }
                                var labs = _ (self.labs ()).filter ('mineralAmount');
                                var capacity = labs.sum ('energyCapacity');
                                var filled = labs.sum ('energy');
                                var empty = capacity - filled;
                                var available = self.get_total_room_resource_counts () [RESOURCE_ENERGY] - filled;
                                self._energy_needed_in_labs = min (empty, available);
                            }
                            return self._energy_needed_in_labs;
                        }, 'energy_needed_in_labs');},
                        get get_lab_target_mineral () {return __get__ (this, function (self) {
                            var mineral = 'XKHO2';
                            if (_.find (self.labs (), (function __lambda__ (l) {
                                return l.mineralType == mineral || !(l.mineralType);
                            })) && self.get_total_room_resource_counts () [mineral]) {
                                return mineral;
                            }
                            return null;
                        }, 'get_lab_target_mineral');},
                        get get_lab2_target_mineral () {return __get__ (this, function (self) {
                            var mineral = 'XLHO2';
                            if (_.find (self.labs (), (function __lambda__ (l) {
                                return l.mineralType == mineral || !(l.mineralType);
                            })) && self.get_total_room_resource_counts () [mineral]) {
                                return mineral;
                            }
                            return null;
                        }, 'get_lab2_target_mineral');},
                        get get_total_room_resource_counts () {return __get__ (this, function (self) {
                            if (self._total_resource_counts !== undefined) {
                                return self._total_resource_counts;
                            }
                            var counts = {};
                            var __iterable0__ = _.pairs (self.storage.store);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var rtype = __left0__ [0];
                                var amount = __left0__ [1];
                                if ((rtype in counts)) {
                                    counts [rtype] += amount;
                                }
                                else {
                                    counts [rtype] = amount;
                                }
                            }
                            if (self.terminal) {
                                var __iterable0__ = _.pairs (self.terminal.store);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var __left0__ = __iterable0__ [__index0__];
                                    var rtype = __left0__ [0];
                                    var amount = __left0__ [1];
                                    if ((rtype in counts)) {
                                        counts [rtype] += amount;
                                    }
                                    else {
                                        counts [rtype] = amount;
                                    }
                                }
                            }
                            var creep_carry = self.mineral_hauler_carry ();
                            var __iterable0__ = _.pairs (creep_carry);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var rtype = __left0__ [0];
                                var amount = __left0__ [1];
                                if ((rtype in counts)) {
                                    counts [rtype] += amount;
                                }
                                else {
                                    counts [rtype] = amount;
                                }
                            }
                            if (self.room.rcl >= 6 && self.terminal) {
                                var __iterable0__ = self.room.find (FIND_MY_STRUCTURES);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var lab = __iterable0__ [__index0__];
                                    if (lab.structureType == STRUCTURE_LAB) {
                                        if (lab.mineralAmount) {
                                            if ((lab.mineralType in counts)) {
                                                counts [lab.mineralType] += lab.mineralAmount;
                                            }
                                            else {
                                                counts [lab.mineralType] = lab.mineralAmount;
                                            }
                                        }
                                        if (lab.energy) {
                                            if ((RESOURCE_ENERGY in counts)) {
                                                counts [RESOURCE_ENERGY] += lab.energy;
                                            }
                                            else {
                                                counts [RESOURCE_ENERGY] = lab.energy;
                                            }
                                        }
                                    }
                                }
                            }
                            self._total_resource_counts = counts;
                            return counts;
                        }, 'get_total_room_resource_counts');},
                        get get_estimate_total_energy () {return __get__ (this, function (self) {
                            if (self._total_resource_counts !== undefined) {
                                return self._total_resource_counts [RESOURCE_ENERGY] || 0;
                            }
                            if (self._estimate_energy !== undefined) {
                                return self._estimate_energy;
                            }
                            var energy = 0;
                            if ((RESOURCE_ENERGY in self.storage.store)) {
                                energy += self.storage.store [RESOURCE_ENERGY];
                            }
                            if (self.terminal && (RESOURCE_ENERGY in self.terminal.store)) {
                                energy += self.terminal.store [RESOURCE_ENERGY];
                            }
                            self._estimate_energy = energy;
                            return energy;
                        }, 'get_estimate_total_energy');},
                        get get_estimate_total_non_energy () {return __get__ (this, function (self) {
                            if (self._estimate_non_energy !== undefined) {
                                return self._estimate_non_energy;
                            }
                            if (self._total_resource_counts !== undefined) {
                                var amounts = self._total_resource_counts;
                                var result = 0;
                                var __iterable0__ = amounts;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var key = __iterable0__ [__index0__];
                                    if (key != RESOURCE_ENERGY) {
                                        result += amounts [key];
                                    }
                                }
                                self._estimate_non_energy = result;
                                return result;
                            }
                            var result = 0;
                            var __iterable0__ = self.storage.store;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var resource = __iterable0__ [__index0__];
                                if (resource != RESOURCE_ENERGY) {
                                    result += self.storage.store [resource];
                                }
                            }
                            if (self.terminal) {
                                var __iterable0__ = self.terminal.store;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var resource = __iterable0__ [__index0__];
                                    if (resource != RESOURCE_ENERGY) {
                                        result += self.terminal.store [resource];
                                    }
                                }
                            }
                            self._estimate_non_energy = result;
                            return result;
                        }, 'get_estimate_total_non_energy');},
                        get sell_orders_by_mineral () {return __get__ (this, function (self) {
                            var vmem = volatile_cache.mem ('market');
                            if (vmem.has ('grouped_sell_orders')) {
                                return vmem.get ('grouped_sell_orders') [self.room.name] || {};
                            }
                            else {
                                var all_sell_orders = {};
                                var __iterable0__ = _.values (Game.market.orders);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var order = __iterable0__ [__index0__];
                                    if (order.type == ORDER_SELL) {
                                        if ((order.roomName in all_sell_orders)) {
                                            var room_orders = all_sell_orders [order.roomName];
                                        }
                                        else {
                                            var __left0__ = {};
                                            var room_orders = __left0__;
                                            all_sell_orders [order.roomName] = __left0__;
                                        }
                                        if ((order.resourceType in room_orders)) {
                                            room_orders [order.resourceType].push (order);
                                        }
                                        else {
                                            room_orders [order.resourceType] = [order];
                                        }
                                    }
                                }
                                vmem.set ('grouped_sell_orders', all_sell_orders);
                                return all_sell_orders [self.room.name] || {};
                            }
                        }, 'sell_orders_by_mineral');},
                        get _terminal_target_for_resource () {return __get__ (this, function (self, mineral, currently_have) {
                            if (mineral == RESOURCE_ENERGY) {
                                if (currently_have < 20 * 1000) {
                                    return 0;
                                }
                                else if (currently_have <= 30 * 1000) {
                                    return currently_have - 20 * 1000;
                                }
                                if (self.room.mem [rmem_key_empty_all_resources_into_room]) {
                                    var min_via_empty_to = self.find_emptying_mineral_and_cost () [1];
                                }
                                else {
                                    var min_via_empty_to = 0;
                                }
                                if (!('ten_without_self_orders' in self.mem)) {
                                    self.recalculate_energy_needed ();
                                }
                                var min_via_fulfillment = min (currently_have - 120 * 1000, self.mem ['total_energy_needed']);
                                var spending_state = self.room.main_spending_expenditure ();
                                if (spending_state == room_spending_state_supporting) {
                                    var min_via_spending = currently_have - energy_to_keep_always_in_reserve;
                                }
                                else if (spending_state == room_spending_state_supporting_sieged) {
                                    var min_via_spending = currently_have - energy_to_keep_always_in_reserve_when_supporting_sieged;
                                }
                                else {
                                    var min_via_spending = 0;
                                }
                                return min (currently_have - 50 * 1000, max (0, min_via_empty_to, min_via_fulfillment, min_via_spending));
                            }
                            else if (mineral == self.get_lab_target_mineral () || mineral == self.get_lab2_target_mineral ()) {
                                return 0;
                            }
                            else {
                                if (self.my_mineral_deposit_minerals ().includes (mineral)) {
                                    return min (currently_have, _KEEP_IN_TERMINAL_MY_MINERAL);
                                }
                                var fulfilling = self.fulfilling [mineral];
                                if (fulfilling && len (fulfilling)) {
                                    return min (_SINGLE_MINERAL_FULFILLMENT_MAX, _.sum (fulfilling, 'amount'));
                                }
                                var sell_orders = self.sell_orders_by_mineral () [mineral];
                                if (sell_orders && len (sell_orders)) {
                                    var biggest_order = 0;
                                    var __iterable0__ = sell_orders;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var order = __iterable0__ [__index0__];
                                        if (order.amountRemaining > biggest_order) {
                                            var biggest_order = order.amountRemaining;
                                        }
                                    }
                                    return biggest_order;
                                }
                                if (currently_have >= 1000 && (mineral != RESOURCE_POWER || self.room.mem [rmem_key_empty_all_resources_into_room])) {
                                    return 1000 * min (math.floor (currently_have / 1000), 20);
                                }
                                else {
                                    return 0;
                                }
                            }
                        }, '_terminal_target_for_resource');},
                        get tick_terminal () {return __get__ (this, function (self) {
                            if (__mod__ (Game.time, 5) == 0 && self.room.main_spending_expenditure () == room_spending_state_supporting_sieged) {
                                self.run_support ();
                            }
                            if (self.has_no_terminal_or_storage () || Game.cpu.bucket < 4300 && !(__mod__ (Game.time, 1020) == 3 || __mod__ (Game.time, 765) == 8 || __mod__ (Game.time, 595) == 15)) {
                                return ;
                            }
                            var py_split = __mod__ (Game.time, 85);
                            if (py_split == 8 && !(_.isEmpty (self.fulfilling))) {
                                self.run_fulfillment ();
                                if (self.room.main_spending_expenditure () == room_spending_state_supporting) {
                                    self.run_support ();
                                }
                            }
                            else if (py_split == 3 && len (self.my_mineral_deposit_minerals ())) {
                                self.check_orders ();
                            }
                            else if (py_split == 15 && (rmem_key_empty_all_resources_into_room in self.room.mem)) {
                                self.run_emptying_terminal ();
                            }
                        }, 'tick_terminal');},
                        get find_emptying_mineral_and_cost () {return __get__ (this, function (self) {
                            if (self._next_mineral_to_empty === null) {
                                var energy = self.terminal.store.energy;
                                var minerals = _.sum (self.terminal.store) - energy;
                                if (minerals > 1000 || _.sum (self.storage.store) == self.storage.store.energy) {
                                    var mineral_chosen = _.find (Object.keys (self.terminal.store), (function __lambda__ (r) {
                                        return r != RESOURCE_ENERGY && self.terminal.store [r] >= 100;
                                    }));
                                    if (!(mineral_chosen)) {
                                        return ;
                                    }
                                    var amount = self.terminal.store [mineral_chosen];
                                    var cost = Game.market.calcTransactionCost (amount, self.room.name, self.room.mem [rmem_key_empty_all_resources_into_room]);
                                    self._next_mineral_to_empty = [mineral_chosen, cost];
                                }
                                else {
                                    self._next_mineral_to_empty = [null, 0];
                                }
                            }
                            return self._next_mineral_to_empty;
                        }, 'find_emptying_mineral_and_cost');},
                        get run_emptying_terminal () {return __get__ (this, function (self) {
                            var energy = self.terminal.store.energy;
                            var __left0__ = self.find_emptying_mineral_and_cost ();
                            var mineral = __left0__ [0];
                            var cost = __left0__ [1];
                            if (energy < cost) {
                                return ;
                            }
                            self.terminal.send (mineral, self.terminal.store [mineral], self.room.mem [rmem_key_empty_all_resources_into_room], 'Emptying to {}'.format (self.room.mem [rmem_key_empty_all_resources_into_room]));
                        }, 'run_emptying_terminal');},
                        get run_fulfillment () {return __get__ (this, function (self) {
                            var vmem = volatile_cache.mem ('market');
                            var __iterable0__ = Object.keys (self.fulfilling);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var mineral = __iterable0__ [__index0__];
                                if ((mineral in self.terminal.store)) {
                                    var target_list = self.fulfilling [mineral];
                                    if (!(len (target_list))) {
                                        delete self.fulfilling [mineral];
                                        continue;
                                    }
                                    if (vmem.get ('market_orders_executed') >= 10) {
                                        break;
                                    }
                                    var __iterable1__ = target_list;
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var target = __iterable1__ [__index1__];
                                        var held = self.terminal.store [mineral];
                                        if (held >= 1000 || held >= target.amount) {
                                            var result = self.fulfill_now (mineral, target);
                                            if (result == OK) {
                                                if (vmem.has ('market_orders_executed')) {
                                                    vmem.set ('market_orders_executed', vmem.get ('market_orders_executed') + 1);
                                                }
                                                else {
                                                    vmem.set ('market_orders_executed', 1);
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                                else if (!(self.my_mineral_deposit_minerals ().includes (mineral))) {
                                    if (len (self.fulfilling [mineral])) {
                                        self.log ('Used up all of our {}: removing {} remaining orders!'.format (mineral, len (self.fulfilling [mineral])));
                                    }
                                    delete self.fulfilling [mineral];
                                }
                            }
                        }, 'run_fulfillment');},
                        get run_support () {return __get__ (this, function (self) {
                            if (!(self.terminal) || !(self.terminal.store [RESOURCE_ENERGY]) || self.terminal.store [RESOURCE_ENERGY] < 5000) {
                                return ;
                            }
                            var spending_state = self.room.main_spending_expenditure ();
                            if (spending_state == room_spending_state_supporting) {
                                var min_via_spending = self.get_estimate_total_energy () - energy_to_keep_always_in_reserve;
                            }
                            else if (spending_state == room_spending_state_supporting_sieged) {
                                var min_via_spending = self.get_estimate_total_energy () - energy_to_keep_always_in_reserve_when_supporting_sieged;
                            }
                            else {
                                return ;
                            }
                            var sending_to = self.room.mem [rmem_key_now_supporting];
                            var to_send = min (self.terminal.store [RESOURCE_ENERGY], min_via_spending);
                            var distance = Game.map.getRoomLinearDistance (self.room.name, sending_to, true);
                            var total_cost_of_1_energy = 1 + 1 * (math.log ((distance + 9) * 0.1) + 0.1);
                            var amount = math.floor (to_send / total_cost_of_1_energy);
                            if (amount >= 100) {
                                var result = self.terminal.send (RESOURCE_ENERGY, amount, sending_to, 'Sending support!');
                                if (result != OK) {
                                    self.log ("ERROR: Unknown result from terminal.send(RESOURCE_ENERGY, {}, '{}', 'Sending support!'): {}".format (amount, sending_to, result));
                                }
                            }
                        }, 'run_support');},
                        get fulfill_now () {return __get__ (this, function (self, mineral, target_obj) {
                            if ((self.terminal.store [mineral] < 1000 && 1000 <= target_obj.amount)) {
                                self.log ('WARNING: fulfill_now() called with mineral: {}, target: {},but {} < {}'.format (mineral, JSON.stringify (target_obj), self.terminal.store [mineral], 1000));
                                return ERR_NOT_ENOUGH_RESOURCES;
                            }
                            if (mineral == RESOURCE_ENERGY) {
                                var energy_here = min (_SINGLE_MINERAL_FULFILLMENT_MAX, self.terminal.store [mineral]);
                                var amount = min (target_obj.amount, energy_here);
                                var energy_cost = amount + Game.market.calcTransactionCost (amount, self.room.name, target_obj.room);
                                if (energy_cost > energy_here) {
                                    var distance = Game.map.getRoomLinearDistance (self.room.name, target_obj.room, true);
                                    var total_cost_of_1_energy = 1 + 1 * (math.log ((distance + 9) * 0.1) + 0.1);
                                    var amount = math.floor (energy_here / total_cost_of_1_energy);
                                    var energy_cost = math.ceil (amount * total_cost_of_1_energy);
                                }
                            }
                            else {
                                var amount = min (target_obj.amount, _SINGLE_MINERAL_FULFILLMENT_MAX, self.terminal.store [mineral]);
                                var energy_cost = Game.market.calcTransactionCost (amount, self.room.name, target_obj.room);
                            }
                            if (self.terminal.store [RESOURCE_ENERGY] < energy_cost) {
                                if (energy_cost > self.mem ['total_energy_needed']) {
                                    self.log ('WARNING: Error correction! Total energy needed should have been at least {},but it was only {}.'.format (energy_cost, self.mem ['total_energy_needed']));
                                    self.recalculate_energy_needed ();
                                }
                                return ERR_NOT_ENOUGH_RESOURCES;
                            }
                            if (('order_id' in target_obj)) {
                                var result = Game.market.deal (target_obj.order_id, amount, self.room.name);
                            }
                            else {
                                if (target_obj.amount < 100) {
                                    self.log ('WARNING: Error correction! Extending order of {} to {} from {} to {} {} (too small to fill)'.format (mineral, target_obj.room, target_obj.amount, 100, mineral));
                                    target_obj.amount = 100;
                                    return ERR_NOT_ENOUGH_RESOURCES;
                                }
                                else if (amount < 100) {
                                    return ERR_NOT_ENOUGH_RESOURCES;
                                }
                                else if (target_obj.amount - amount < 100 && amount < target_obj.amount) {
                                    if (target_obj.amount < 200) {
                                        return ERR_NOT_ENOUGH_RESOURCES;
                                    }
                                    else {
                                        var amount = target_obj.amount - 100;
                                    }
                                }
                                var result = self.terminal.send (mineral, amount, target_obj.room, 'Fulfilling order for {} {}'.format (target_obj.amount, mineral));
                            }
                            if (result == OK) {
                                if (amount < target_obj.amount) {
                                    target_obj.amount -= amount;
                                    self.log ('Sent {} {} to {} successfully, {} left to go.'.format (amount, mineral, target_obj.room, target_obj.amount));
                                }
                                else {
                                    var target_index = self.fulfilling [mineral].indexOf (target_obj);
                                    if (target_index < 0) {
                                        self.log ("ERROR: Couldn't find indexOf target fulfillment {} for mineral {} in room {}".format (JSON.stringify (target_obj), mineral, self.room.name));
                                    }
                                    self.fulfilling [mineral].splice (target_index, 1);
                                    if (!(len (self.fulfilling [mineral]))) {
                                        delete self.fulfilling [mineral];
                                    }
                                    self.log ('Sent {} {} to {} successfully, finishing the transaction.'.format (amount, mineral, target_obj.room));
                                }
                                self.recalculate_energy_needed ();
                            }
                            else if (('order_id' in target_obj)) {
                                if (result == ERR_INVALID_ARGS) {
                                    self.log ('Removing market deal {} (send {} {} to {}): executed by another player.'.format (target_obj.order_id, target_obj.amount, mineral, target_obj.room));
                                    var target_index = self.fulfilling [mineral].indexOf (target_obj);
                                    if (target_index < 0) {
                                        self.log ("ERROR: Couldn't find indexOf target fulfillment {} for mineral {} in room {}".format (JSON.stringify (target_obj), mineral, self.room.name));
                                    }
                                    self.fulfilling [mineral].splice (target_index, 1);
                                    if (!(len (self.fulfilling [mineral]))) {
                                        delete self.fulfilling [mineral];
                                    }
                                }
                                else {
                                    self.log ('ERROR: Unknown result from Game.market.deal({}, {}, {}): {}'.format (target_obj.order_id, amount, self.room.name, result));
                                }
                            }
                            else {
                                self.log ('ERROR: Unknown result from {}.send({}, {}, {}, {}): {}'.format (self.terminal, mineral, amount, self.room.name, "'Fulfilling order for {} {}'".format (target_obj.amount, mineral), result));
                            }
                            return result;
                        }, 'fulfill_now');},
                        get check_orders () {return __get__ (this, function (self) {
                            var __iterable0__ = self.my_mineral_deposit_minerals ();
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var mineral = __iterable0__ [__index0__];
                                if ((mineral in self.fulfilling) && len (self.fulfilling [mineral]) || (self.get_total_room_resource_counts () [mineral] || 0) < _SELL_ORDER_SIZE) {
                                    continue;
                                }
                                var current_sell_orders = self.sell_orders_by_mineral () [mineral];
                                if (current_sell_orders) {
                                    var current_sell_orders = _.filter (current_sell_orders, {'roomName': self.room.name});
                                }
                                if (current_sell_orders && len (current_sell_orders)) {
                                    var to_check = _.min (current_sell_orders, 'price');
                                    self.mem.last_sold_at [mineral] = to_check.price;
                                    if (to_check.remainingAmount < _SELL_ORDER_SIZE) {
                                        if (to_check.remainingAmount <= _SELL_ORDER_SIZE * 0.2) {
                                            if ((mineral in self.mem.last_sold_at)) {
                                                var price = min (max (1.0, sell_at_prices [mineral] - 1.5, self.mem.last_sold_at [mineral] + 0.1), sell_at_prices [mineral]);
                                            }
                                            else {
                                                var price = sell_at_prices [mineral];
                                            }
                                            self.log ('Increasing price on sell order for {} from {} to {}.'.format (mineral, to_check.price, price));
                                            Game.market.changeOrderPrice (to_check.id, price);
                                            Game.market.extendOrder (to_check.id, _SELL_ORDER_SIZE - to_check.remainingAmount);
                                        }
                                        else {
                                            self.log ('Extending sell order for {} at price {} from {} to {} minerals.'.format (mineral, to_check.price, to_check.remainingAmount, _SELL_ORDER_SIZE));
                                            Game.market.extendOrder (to_check.id, _SELL_ORDER_SIZE - to_check.remainingAmount);
                                        }
                                        self.mem.last_sold [mineral] = Game.time;
                                    }
                                    else if (self.mem.last_sold [mineral] < Game.time - 8000 && to_check.price > bottom_prices [mineral] + 0.01) {
                                        var new_price = max (bottom_prices [mineral], to_check.price - 0.1);
                                        self.log ('Reducing price on sell order for {} from {} to {}'.format (mineral, to_check.price, new_price));
                                        Game.market.changeOrderPrice (to_check.id, new_price);
                                        self.mem.last_sold [mineral] = Game.time;
                                    }
                                    else if (to_check.price < bottom_prices [mineral]) {
                                        self.log ('Increasing price on sell order for {} from {} to {}'.format (mineral, to_check.price, bottom_prices [mineral]));
                                        Game.market.changeOrderPrice (to_check.id, bottom_prices [mineral]);
                                    }
                                }
                                else if ((mineral in sell_at_prices) && Game.market.credits >= (MARKET_FEE * _SELL_ORDER_SIZE) * sell_at_prices [mineral] && len (Game.market.orders) < 50) {
                                    if ((mineral in self.mem.last_sold_at)) {
                                        var price = min (max (1.0, sell_at_prices [mineral] - 1.5, self.mem.last_sold_at [mineral] + 0.1), sell_at_prices [mineral]);
                                    }
                                    else {
                                        var price = sell_at_prices [mineral];
                                    }
                                    self.log ('Creating new sell order for {} {} at {} credits/{}'.format (_SELL_ORDER_SIZE, mineral, price, mineral));
                                    Game.market.createOrder (ORDER_SELL, mineral, price, _SELL_ORDER_SIZE, self.room.name);
                                    self.mem.last_sold [mineral] = Game.time;
                                }
                            }
                        }, 'check_orders');},
                        get place_container_construction_site () {return __get__ (this, function (self, deposit) {
                            if (deposit.pos) {
                                var pos = deposit.pos;
                            }
                            else {
                                var pos = deposit;
                            }
                            for (var x = pos.x - 1; x < pos.x + 2; x++) {
                                for (var y = pos.y - 1; y < pos.y + 2; y++) {
                                    if (movement.is_block_clear (self.room, x, y) && !(_.find (self.room.look_at (LOOK_CONSTRUCTION_SITES, x, y), (function __lambda__ (s) {
                                        return s.structureType == STRUCTURE_CONTAINER;
                                    }))) && !(_.find (self.room.look_at (LOOK_STRUCTURES, x, y), (function __lambda__ (s) {
                                        return s.structureType == STRUCTURE_CONTAINER;
                                    })))) {
                                        var result = self.room.room.createConstructionSite (x, y, STRUCTURE_CONTAINER);
                                        if (result == OK) {
                                            return ;
                                        }
                                        else {
                                            self.log ('WARNING: Unknown result from {}.createConstructionSite({}, {}, {}): {}'.format (self.room.room, x, y, STRUCTURE_CONTAINER, result));
                                        }
                                    }
                                }
                            }
                            self.log ("WARNING: Couldn't find any open spots to place a container near {}".format (pos));
                        }, 'place_container_construction_site');},
                        get get_target_mineral_miner_count () {return __get__ (this, function (self) {
                            if (self.has_no_terminal_or_storage () || self.room.mem [rmem_key_empty_all_resources_into_room]) {
                                return 0;
                            }
                            var mineral = self.room.find (FIND_MINERALS) [0];
                            if (mineral && mineral.mineralAmount > 0 && _.find (self.room.look_at (LOOK_STRUCTURES, mineral), {'my': true, 'structureType': STRUCTURE_EXTRACTOR})) {
                                var have_now = self.get_total_room_resource_counts ();
                                if (_.sum (have_now) - (have_now [RESOURCE_ENERGY] || 0) >= max_minerals_to_keep) {
                                    return 0;
                                }
                                var container = _.find (self.room.find_in_range (FIND_STRUCTURES, 2, mineral), (function __lambda__ (s) {
                                    return s.structureType == STRUCTURE_CONTAINER;
                                }));
                                if (container) {
                                    return 1;
                                }
                                else {
                                    var container_site = _.find (self.room.find_in_range (FIND_MY_CONSTRUCTION_SITES, 2, mineral), (function __lambda__ (s) {
                                        return s.structureType == STRUCTURE_CONTAINER;
                                    }));
                                    if (!(container_site)) {
                                        self.place_container_construction_site (mineral);
                                    }
                                }
                            }
                            return 0;
                        }, 'get_target_mineral_miner_count');},
                        get get_target_mineral_hauler_count () {return __get__ (this, function (self) {
                            if (self.has_no_terminal_or_storage ()) {
                                return 0;
                            }
                            else if (self.get_target_mineral_miner_count () || len (self.adding_to_terminal ()) || self.energy_needed_in_labs () || self.amount_needed_in_lab1 () || self.amount_needed_in_lab2 () || _.sum (self.removing_from_terminal (), (function __lambda__ (t) {
                                return t [1];
                            })) > 50 * 1000) {
                                return 1;
                            }
                            else {
                                return 0;
                            }
                        }, 'get_target_mineral_hauler_count');},
                        get mineral_report () {return __get__ (this, function (self) {
                            var minstrings = [];
                            var __iterable0__ = _.pairs (self.get_total_room_resource_counts ());
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var mineral = __left0__ [0];
                                var amount = __left0__ [1];
                                minstrings.append ('{} {}'.format (amount, mineral));
                            }
                            var orderstrings = [];
                            var __iterable0__ = _.pairs (self.fulfilling);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var mineral = __left0__ [0];
                                var target_list = __left0__ [1];
                                var __iterable1__ = target_list;
                                for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                    var order = __iterable1__ [__index1__];
                                    if (order.order_id) {
                                        orderstrings.push ('a market order {} for {} {} to {}'.format (order.order_id, order.amount, mineral, order.room));
                                    }
                                    else {
                                        orderstrings.push ('an order for {} {} to {}'.format (order.amount, mineral, order.room));
                                    }
                                }
                            }
                            if (len (minstrings)) {
                                if (len (orderstrings)) {
                                    return '{} has {}, and is fulfilling {}'.format (self.room.name, ', '.join (minstrings), ', '.join (orderstrings));
                                }
                                else {
                                    return '{} has {}'.format (self.room.name, ', '.join (minstrings));
                                }
                            }
                            else if (len (orderstrings)) {
                                return '{} is empty, and is fulfilling {}'.format (self.room.name, ', '.join (orderstrings));
                            }
                            else {
                                return '{} is empty.'.format (self.room.name);
                            }
                        }, 'mineral_report');}
                    });
                    __pragma__ ('<use>' +
                        'cache.volatile_cache' +
                        'constants' +
                        'jstools.screeps_constants' +
                        'math' +
                        'rooms.room_constants' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.MineralMind = MineralMind;
                        __all__._KEEP_IN_TERMINAL_ENERGY = _KEEP_IN_TERMINAL_ENERGY;
                        __all__._KEEP_IN_TERMINAL_ENERGY_WHEN_SELLING = _KEEP_IN_TERMINAL_ENERGY_WHEN_SELLING;
                        __all__._KEEP_IN_TERMINAL_MY_MINERAL = _KEEP_IN_TERMINAL_MY_MINERAL;
                        __all__._SELL_ORDER_SIZE = _SELL_ORDER_SIZE;
                        __all__._SINGLE_MINERAL_FULFILLMENT_MAX = _SINGLE_MINERAL_FULFILLMENT_MAX;
                        __all__.bottom_prices = bottom_prices;
                        __all__.energy_to_keep_always_in_reserve = energy_to_keep_always_in_reserve;
                        __all__.energy_to_keep_always_in_reserve_when_supporting_sieged = energy_to_keep_always_in_reserve_when_supporting_sieged;
                        __all__.max_minerals_to_keep = max_minerals_to_keep;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
                        __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
                        __all__.rmem_key_now_supporting = rmem_key_now_supporting;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.room_spending_state_supporting = room_spending_state_supporting;
                        __all__.room_spending_state_supporting_sieged = room_spending_state_supporting_sieged;
                        __all__.sell_at_prices = sell_at_prices;
                        __all__.volatile_cache = volatile_cache;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'rooms.mining', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var volatile_cache = __init__ (__world__.cache.volatile_cache);
                    var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var creep_base_1500miner = __init__ (__world__.constants).creep_base_1500miner;
                    var creep_base_3000miner = __init__ (__world__.constants).creep_base_3000miner;
                    var creep_base_4000miner = __init__ (__world__.constants).creep_base_4000miner;
                    var creep_base_carry3000miner = __init__ (__world__.constants).creep_base_carry3000miner;
                    var creep_base_half_move_hauler = __init__ (__world__.constants).creep_base_half_move_hauler;
                    var creep_base_hauler = __init__ (__world__.constants).creep_base_hauler;
                    var creep_base_reserving = __init__ (__world__.constants).creep_base_reserving;
                    var creep_base_work_full_move_hauler = __init__ (__world__.constants).creep_base_work_full_move_hauler;
                    var creep_base_work_half_move_hauler = __init__ (__world__.constants).creep_base_work_half_move_hauler;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_remote_mining_reserve = __init__ (__world__.constants).role_remote_mining_reserve;
                    var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
                    var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
                    var spawning = __init__ (__world__.creep_management.spawning);
                    var fit_num_sections = __init__ (__world__.creep_management.spawning).fit_num_sections;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var defense = __init__ (__world__.rooms.defense);
                    var movement = __init__ (__world__.utilities.movement);
                    var MiningMind = __class__ ('MiningMind', [object], {
                        get __init__ () {return __get__ (this, function (self, room) {
                            self.room = room;
                            self.hive = room.hive;
                            self.targets = self.hive.targets;
                            self._available_mining_flags = null;
                            self._local_mining_flags = null;
                            self._active_mining_flags = null;
                        }, '__init__');},
                        get closest_deposit_point_to_mine () {return __get__ (this, function (self, flag) {
                            var key = 'mine_{}_deposit'.format (flag.name);
                            var target_id = self.room.get_cached_property (key);
                            if (target_id) {
                                var target = Game.getObjectById (target_id);
                                if (target) {
                                    return target;
                                }
                            }
                            if (self.room.links.main_link && flag.pos.roomName == self.room.name) {
                                var main_link_id = self.room.links.main_link.id;
                                var upgrader_link = self.room.get_upgrader_energy_struct ();
                                var upgrader_link_id = upgrader_link && upgrader_link.id || null;
                                var storage = self.room.room.storage;
                                if (storage && storage.storeCapacity > 0) {
                                    var distance = movement.chebyshev_distance_room_pos (storage, flag);
                                    if (distance <= 2) {
                                        var best_priority = -(40);
                                        var best = storage;
                                    }
                                    else {
                                        var best_priority = 0;
                                        var best = storage;
                                    }
                                }
                                else {
                                    var best_priority = Infinity;
                                    var best = null;
                                }
                                if (best_priority > -(40)) {
                                    var __iterable0__ = self.room.links.links;
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var link = __iterable0__ [__index0__];
                                        if (link.energyCapacity <= 0 || link.id == main_link_id) {
                                            continue;
                                        }
                                        var distance = movement.chebyshev_distance_room_pos (link, flag);
                                        if (distance <= 2) {
                                            var priority = -(20);
                                        }
                                        else if (link.id == upgrader_link_id) {
                                            continue;
                                        }
                                        else {
                                            var priority = distance;
                                        }
                                        if (priority < best_priority) {
                                            var best_priority = priority;
                                            var best = link;
                                        }
                                    }
                                }
                                var target = best;
                            }
                            else if (self.room.room.storage && self.room.room.storage.storeCapacity > 0) {
                                var target = self.room.room.storage;
                            }
                            else if (self.room.spawn) {
                                var target = self.room.spawn;
                            }
                            else {
                                return null;
                            }
                            var target_id = target.id;
                            self.room.store_cached_property (key, target_id, 50);
                            return target;
                        }, 'closest_deposit_point_to_mine');},
                        get mine_priority () {return __get__ (this, function (self, flag) {
                            var priority = self.distance_to_mine (flag);
                            if (flag.pos.roomName == self.room.name) {
                                priority -= 50;
                            }
                            if (flag.memory.sk_room) {
                                priority -= 40;
                            }
                            else if (self.should_reserve (flag.pos.roomName)) {
                                priority -= 30;
                            }
                            return priority;
                        }, 'mine_priority');},
                        get distance_to_mine () {return __get__ (this, function (self, flag) {
                            var deposit_point = self.closest_deposit_point_to_mine (flag);
                            if (deposit_point) {
                                if (deposit_point.structureType == STRUCTURE_SPAWN) {
                                    return self.hive.honey.find_path_length (deposit_point, flag) + 20;
                                }
                                else {
                                    return self.hive.honey.find_path_length (deposit_point, flag);
                                }
                            }
                            else {
                                return Infinity;
                            }
                        }, 'distance_to_mine');},
                        get calculate_ideal_mass_for_mine () {return __get__ (this, function (self, flag) {
                            var key = 'mine_{}_ideal_mass'.format (flag.name);
                            var target_mass = self.room.get_cached_property (key);
                            if (target_mass) {
                                return target_mass;
                            }
                            var carry_per_tick = 50.0 / (self.distance_to_mine (flag) * 2.1 + 5);
                            var room = Game.rooms [flag.pos.roomName];
                            if (room && room.controller && room.controller.my) {
                                var mining_per_tick = 10.0;
                            }
                            else if (flag.memory.sk_room || room && !(room.controller)) {
                                var mining_per_tick = 15.0;
                            }
                            else if (self.should_reserve (flag.pos.roomName)) {
                                var mining_per_tick = 10.0;
                            }
                            else {
                                var mining_per_tick = 5.0;
                            }
                            var produce_per_tick = mining_per_tick;
                            var target_mass = math.ceil (produce_per_tick / carry_per_tick) + 1;
                            self.room.store_cached_property (key, target_mass, 50);
                            return target_mass;
                        }, 'calculate_ideal_mass_for_mine');},
                        get calculate_current_target_mass_for_mine () {return __get__ (this, function (self, flag) {
                            var ideal_mass = self.calculate_ideal_mass_for_mine (flag);
                            if (!(self.room.room.storage)) {
                                return ideal_mass;
                            }
                            return ideal_mass;
                        }, 'calculate_current_target_mass_for_mine');},
                        get cleanup_old_flag_sitting_values () {return __get__ (this, function (self) {
                            var __iterable0__ = self.available_mines;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                if (('sitting' in flag.memory) && flag.memory.sitting < Game.time - flag.memory.sitting_set && Game.time - flag.memory.sitting_set > 10) {
                                    delete flag.memory.sitting;
                                    delete flag.memory.sitting_set;
                                    if (!(len (flag.memory))) {
                                        delete Memory.flags [flag.name];
                                    }
                                }
                            }
                        }, 'cleanup_old_flag_sitting_values');},
                        get energy_sitting_at () {return __get__ (this, function (self, flag) {
                            if (!('sitting' in flag.memory) || Game.time > flag.memory.sitting_set + 10) {
                                var room = self.hive.get_room (flag.pos.roomName);
                                if (room) {
                                    flag.memory.sitting = _.sum (room.look_for_in_area_around (LOOK_RESOURCES, flag, 1), 'resource.amount');
                                }
                                else if (('sitting_set' in flag.memory)) {
                                    flag.memory.sitting = max (0, (flag.memory.sitting + flag.memory.sitting_set) - Game.time);
                                }
                                else {
                                    flag.memory.sitting = 0;
                                }
                                flag.memory.sitting_set = Game.time;
                            }
                            return max (0, flag.memory.sitting - (Game.time - flag.memory.sitting_set)) || 0;
                        }, 'energy_sitting_at');},
                        get get_local_mining_flags () {return __get__ (this, function (self) {
                            if (self._local_mining_flags === null) {
                                var result = [];
                                var __iterable0__ = self.room.sources;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var source = __iterable0__ [__index0__];
                                    var flag = flags.look_for (self.room, source, LOCAL_MINE);
                                    if (!(flag)) {
                                        var name = flags.create_flag (source, LOCAL_MINE);
                                        if (!(name)) {
                                            print ("[{}][mining] Warning: Couldn't create local mining flag!".format (self.room.name));
                                            continue;
                                        }
                                        var flag = Game.flags [name];
                                        if (!(flag)) {
                                            print ("[{}][mining] Warning: Couldn't find local mining flag with name {}!".format (self.room.name, name));
                                            continue;
                                        }
                                    }
                                    if (!('sponsor' in flag.memory)) {
                                        flag.memory.sponsor = self.room.name;
                                        flag.memory.active = true;
                                    }
                                    result.append (flag);
                                }
                                self._local_mining_flags = result;
                            }
                            return self._local_mining_flags;
                        }, 'get_local_mining_flags');},
                        get get_available_mining_flags () {return __get__ (this, function (self) {
                            if (self._available_mining_flags === null) {
                                if (self.room.any_remotes_under_siege ()) {
                                    var result = list (_ (self.get_local_mining_flags ()).concat (self.room.possible_remote_mining_operations).filter ((function __lambda__ (f) {
                                        return !(self.room.remote_under_siege (f));
                                    })).sortBy (self.mine_priority).value ());
                                }
                                else {
                                    var result = list (_ (self.get_local_mining_flags ()).concat (self.room.possible_remote_mining_operations).sortBy (self.mine_priority).value ());
                                }
                                self._available_mining_flags = result;
                            }
                            return self._available_mining_flags;
                        }, 'get_available_mining_flags');},
                        get get_active_mining_flags () {return __get__ (this, function (self) {
                            if (self._active_mining_flags === null) {
                                var max_count = len (self.room.sources) + self.room.get_max_mining_op_count ();
                                if (max_count > len (self.available_mines)) {
                                    var max_count = len (self.available_mines);
                                }
                                self._active_mining_flags = self.available_mines.__getslice__ (0, max_count, 1);
                            }
                            return self._active_mining_flags;
                        }, 'get_active_mining_flags');},
                        get calculate_creep_num_sections_for_mine () {return __get__ (this, function (self, flag) {
                            var double = false;
                            if (flag.pos.roomName == self.room.name) {
                                if (self.room.all_paved ()) {
                                    var maximum = spawning.max_sections_of (self.room, creep_base_half_move_hauler);
                                    var double = true;
                                }
                                else {
                                    var maximum = spawning.max_sections_of (self.room, creep_base_hauler);
                                }
                            }
                            else if (self.room.all_paved ()) {
                                var maximum = spawning.max_sections_of (self.room, creep_base_work_half_move_hauler);
                                var double = true;
                            }
                            else if (self.room.paving ()) {
                                var maximum = spawning.max_sections_of (self.room, creep_base_work_full_move_hauler);
                            }
                            else {
                                var maximum = spawning.max_sections_of (self.room, creep_base_hauler);
                            }
                            var needed = self.calculate_ideal_mass_for_mine (flag);
                            if (double) {
                                return fit_num_sections (needed / 2, maximum);
                            }
                            else {
                                return fit_num_sections (needed, maximum);
                            }
                        }, 'calculate_creep_num_sections_for_mine');},
                        get should_reserve () {return __get__ (this, function (self, room_name) {
                            if (self.room.room.energyCapacityAvailable < 1300) {
                                return false;
                            }
                            var flag_list = _.filter (flags.find_flags (room_name, REMOTE_MINE), (function __lambda__ (f) {
                                return f.memory.active;
                            }));
                            if (_.find (flag_list, (function __lambda__ (f) {
                                return f.memory.sk_room;
                            }))) {
                                return false;
                            }
                            if (_.find (flag_list, (function __lambda__ (f) {
                                return f.memory.do_reserve;
                            }))) {
                                return true;
                            }
                            if (len (flag_list) < 2) {
                                return false;
                            }
                            return true;
                        }, 'should_reserve');},
                        get open_spaces_around () {return __get__ (this, function (self, flag) {
                            if (!('osa' in flag.memory)) {
                                var osa = 0;
                                var room = self.hive.get_room (flag.pos.roomName);
                                for (var x = flag.pos.x - 1; x < flag.pos.x + 2; x++) {
                                    for (var y = flag.pos.y - 1; y < flag.pos.y + 2; y++) {
                                        if (room) {
                                            if (movement.is_block_empty (room, x, y)) {
                                                osa++;
                                            }
                                        }
                                        else if (Game.map.getTerrainAt (x, y, flag.pos.roomName) != 'wall') {
                                            osa++;
                                        }
                                    }
                                }
                                flag.memory.osa = osa;
                            }
                            return flag.memory.osa;
                        }, 'open_spaces_around');},
                        get reserver_needed () {return __get__ (this, function (self, flag) {
                            var room_name = flag.pos.roomName;
                            if (flag.memory.sk_room || Memory.no_controller && Memory.no_controller [room_name] || !(self.should_reserve (room_name))) {
                                return null;
                            }
                            if ((room_name in Game.rooms)) {
                                var controller = Game.rooms [room_name].controller;
                                if (!(controller)) {
                                    if (('no_controller' in Memory)) {
                                        Memory.no_controller [room_name] = true;
                                    }
                                    else {
                                        Memory.no_controller = {[room_name]: true};
                                    }
                                    return null;
                                }
                                else if (controller.my) {
                                    return null;
                                }
                            }
                            if (!(Memory.reserving)) {
                                Memory.reserving = {};
                            }
                            if ((room_name in Memory.rooms) && (rmem_key_room_reserved_up_until_tick in Memory.rooms [room_name])) {
                                var ticks_to_end = Memory.rooms [room_name] [rmem_key_room_reserved_up_until_tick] - Game.time;
                                if (ticks_to_end >= 1000) {
                                    var max_sections = min (5, spawning.max_sections_of (self.room, creep_base_reserving));
                                    if (5000 - ticks_to_end < max_sections * 600) {
                                        return null;
                                    }
                                }
                            }
                            var claimer = Game.creeps [Memory.reserving [room_name]];
                            if (!(claimer) || self.room.replacement_time_of (claimer) <= Game.time && !(Game.creeps [claimer.memory.replacement])) {
                                var room = Game.rooms [room_name];
                                if (room && !(room.controller)) {
                                    Memory.no_controller [room_name] = true;
                                }
                                else {
                                    return {'role': role_remote_mining_reserve, 'base': creep_base_reserving, 'num_sections': min (5, spawning.max_sections_of (self.room, creep_base_reserving)), 'memory': {'claiming': room_name}, 'run_after': "(name) => Memory.reserving['{}'] = name".format (room_name)};
                                }
                            }
                            else {
                                return null;
                            }
                        }, 'reserver_needed');},
                        get get_ideal_miner_workmass_for () {return __get__ (this, function (self, flag) {
                            if (flag.memory.sk_room) {
                                return 7;
                            }
                            else if (flag.pos.roomName == self.room.name || self.should_reserve (flag.pos.roomName)) {
                                return 5;
                            }
                            else {
                                return 3;
                            }
                        }, 'get_ideal_miner_workmass_for');},
                        get haulers_can_target_mine () {return __get__ (this, function (self, flag) {
                            var miner_carry_no_haulers = flag.pos.roomName == self.room.name && self.room.room.energyCapacityAvailable >= 600 && flag.pos.inRangeTo (self.closest_deposit_point_to_mine (flag), 2);
                            var no_haulers = flag.pos.roomName == self.room.name && (self.room.rcl < 4 || !(self.room.room.storage));
                            return !(miner_carry_no_haulers) && !(no_haulers);
                        }, 'haulers_can_target_mine');},
                        get is_mine_linked () {return __get__ (this, function (self, source) {
                            var flag = flags.look_for (self.room, source, LOCAL_MINE);
                            if (flag) {
                                var miner_carry_no_haulers = flag.pos.roomName == self.room.name && self.room.room.energyCapacityAvailable >= 600 && flag.pos.inRangeTo (self.closest_deposit_point_to_mine (flag), 2);
                                return miner_carry_no_haulers;
                            }
                            else {
                                print ("[mining] Warning: can't find local flag for mine {}!".format (source));
                                return false;
                            }
                        }, 'is_mine_linked');},
                        get get_next_needed_mining_role_for () {return __get__ (this, function (self, flag) {
                            var flag_id = 'flag-{}'.format (flag.name);
                            var miner_carry_no_haulers = flag.pos.roomName == self.room.name && self.room.room.energyCapacityAvailable >= 600 && flag.pos.inRangeTo (self.closest_deposit_point_to_mine (flag), 2);
                            var no_haulers = flag.pos.roomName == self.room.name && (self.room.rcl < 4 || !(self.room.room.storage));
                            if (len (defense.stored_hostiles_in (flag.pos.roomName))) {
                                return null;
                            }
                            var miners = self.targets.creeps_now_targeting (target_energy_miner_mine, flag_id);
                            var miner_needed = false;
                            if (len (miners)) {
                                if (self.room.rcl < 4) {
                                    var work_mass_needed = self.get_ideal_miner_workmass_for (flag);
                                    if (flag.pos.roomName == self.room.name) {
                                        var workers_needed = self.open_spaces_around (flag);
                                    }
                                    else {
                                        var workers_needed = 1;
                                    }
                                }
                                else {
                                    var work_mass_needed = null;
                                    var workers_needed = null;
                                }
                                var __break0__ = false;
                                var __iterable0__ = miners;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var miner_name = __iterable0__ [__index0__];
                                    var creep = Game.creeps [miner_name];
                                    if (!(creep)) {
                                        continue;
                                    }
                                    if (self.room.replacement_time_of (creep) > Game.time) {
                                        if (work_mass_needed === null) {
                                            __break0__ = true;
                                            break;
                                        }
                                        work_mass_needed -= spawning.work_count (creep);
                                        if (work_mass_needed <= 0) {
                                            __break0__ = true;
                                            break;
                                        }
                                        workers_needed--;
                                        if (workers_needed <= 0) {
                                            __break0__ = true;
                                            break;
                                        }
                                    }
                                }
                                if (!__break0__) {
                                    var miner_needed = true;
                                }
                            }
                            else {
                                var miner_needed = true;
                            }
                            if (miner_needed) {
                                if (miner_carry_no_haulers) {
                                    var base = creep_base_carry3000miner;
                                    var num_sections = min (5, spawning.max_sections_of (self.room, base));
                                }
                                else if (flag.memory.sk_room) {
                                    var base = creep_base_4000miner;
                                    var num_sections = min (7, spawning.max_sections_of (self.room, base));
                                }
                                else if (flag.pos.roomName == self.room.name || self.should_reserve (flag.pos.roomName)) {
                                    var base = creep_base_3000miner;
                                    var num_sections = min (5, spawning.max_sections_of (self.room, base));
                                }
                                else {
                                    var base = creep_base_1500miner;
                                    var num_sections = min (3, spawning.max_sections_of (self.room, base));
                                }
                                if (self.room.all_paved ()) {
                                    var num_sections = spawning.ceil_sections (num_sections / 2, base);
                                }
                                return {'role': role_miner, 'base': base, 'num_sections': num_sections, 'targets': [[target_energy_miner_mine, flag_id]]};
                            }
                            var reserver_needed = self.reserver_needed (flag);
                            if (reserver_needed) {
                                return reserver_needed;
                            }
                            if (miner_carry_no_haulers || no_haulers) {
                                return null;
                            }
                            var current_noneol_hauler_mass = 0;
                            var __iterable0__ = self.targets.creeps_now_targeting (target_energy_hauler_mine, flag_id);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var hauler_name = __iterable0__ [__index0__];
                                var creep = Game.creeps [hauler_name];
                                if (!(creep)) {
                                    continue;
                                }
                                if (self.room.replacement_time_of (creep) > Game.time) {
                                    current_noneol_hauler_mass += spawning.carry_count (creep);
                                }
                            }
                            if (current_noneol_hauler_mass < self.calculate_current_target_mass_for_mine (flag)) {
                                if (flag.pos.roomName == self.room.name) {
                                    if (self.room.all_paved ()) {
                                        var base = creep_base_half_move_hauler;
                                    }
                                    else {
                                        var base = creep_base_hauler;
                                    }
                                }
                                else if (self.room.all_paved ()) {
                                    var base = creep_base_work_half_move_hauler;
                                }
                                else if (self.room.paving ()) {
                                    var base = creep_base_work_full_move_hauler;
                                }
                                else {
                                    var base = creep_base_hauler;
                                }
                                return {'role': role_hauler, 'base': base, 'num_sections': self.calculate_creep_num_sections_for_mine (flag), 'targets': [[target_energy_hauler_mine, flag_id]]};
                            }
                            return null;
                        }, 'get_next_needed_mining_role_for');},
                        get next_mining_role () {return __get__ (this, function (self, max_to_check) {
                            if (typeof max_to_check == 'undefined' || (max_to_check != null && max_to_check .hasOwnProperty ("__kwargtrans__"))) {;
                                var max_to_check = Infinity;
                            };
                            if (max_to_check <= 0) {
                                return null;
                            }
                            var mines = self.active_mines;
                            if (len (mines) <= 0) {
                                return null;
                            }
                            if (self.room.room.storage && self.room.room.storage.store.energy > self.room.room.storage.storeCapacity) {
                                return null;
                            }
                            var known_nothing_needed = volatile_cache.setmem ('rolechecked_mines');
                            var checked_count = 0;
                            var __iterable0__ = mines;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var mining_flag = __iterable0__ [__index0__];
                                if (!(known_nothing_needed.has (mining_flag.name))) {
                                    var role = self.get_next_needed_mining_role_for (mining_flag);
                                    if (role) {
                                        return role;
                                    }
                                    else {
                                        known_nothing_needed.add (mining_flag.name);
                                    }
                                }
                                checked_count++;
                                if (checked_count >= max_to_check) {
                                    break;
                                }
                            }
                            return null;
                        }, 'next_mining_role');}
                    });
                    Object.defineProperty (MiningMind, 'local_mines', property.call (MiningMind, MiningMind.get_local_mining_flags));;
                    Object.defineProperty (MiningMind, 'available_mines', property.call (MiningMind, MiningMind.get_available_mining_flags));;
                    Object.defineProperty (MiningMind, 'active_mines', property.call (MiningMind, MiningMind.get_active_mining_flags));;
                    __pragma__ ('<use>' +
                        'cache.volatile_cache' +
                        'constants' +
                        'creep_management.spawning' +
                        'jstools.screeps_constants' +
                        'math' +
                        'position_management.flags' +
                        'rooms.defense' +
                        'utilities.movement' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.MiningMind = MiningMind;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.creep_base_1500miner = creep_base_1500miner;
                        __all__.creep_base_3000miner = creep_base_3000miner;
                        __all__.creep_base_4000miner = creep_base_4000miner;
                        __all__.creep_base_carry3000miner = creep_base_carry3000miner;
                        __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
                        __all__.creep_base_hauler = creep_base_hauler;
                        __all__.creep_base_reserving = creep_base_reserving;
                        __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
                        __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
                        __all__.defense = defense;
                        __all__.fit_num_sections = fit_num_sections;
                        __all__.flags = flags;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.role_hauler = role_hauler;
                        __all__.role_miner = role_miner;
                        __all__.role_remote_mining_reserve = role_remote_mining_reserve;
                        __all__.spawning = spawning;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                        __all__.volatile_cache = volatile_cache;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'rooms.room_constants', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var min_total_pause_remote_mining = 950 * 1000;
                    var min_energy_pause_remote_mining = 150 * 1000;
                    var max_total_resume_remote_mining = 700 * 1000;
                    var max_energy_resume_remote_mining = 50 * 1000;
                    var min_work_mass_per_source_for_full_storage_use = 15;
                    var min_energy_enable_full_storage_use = 10 * 1000;
                    var max_energy_disable_full_storage_use = 5 * 1000;
                    var energy_to_resume_upgrading = 14 * 1000;
                    var energy_to_pause_upgrading = 8 * 1000;
                    var rcl8_energy_to_resume_upgrading = 100 * 1000;
                    var rcl8_energy_to_pause_upgrading = 50 * 1000;
                    var energy_to_pause_building = 14 * 1000;
                    var energy_to_resume_building = 28 * 1000;
                    var min_stored_energy_to_draw_from_before_refilling = 20 * 1000;
                    var rcl_to_target_wall_hits = [1, 20 * 1000, 50 * 1000, 150 * 1000, 500 * 1000, 1000 * 1000, (3 * 1000) * 1000, (10 * 1000) * 1000];
                    var rcl_to_max_wall_hits = [2, 40 * 1000, 80 * 1000, 250 * 1000, 1000 * 1000, 1500 * 1000, (5 * 1000) * 1000, WALL_HITS_MAX];
                    var energy_to_keep_always_in_reserve = STORAGE_CAPACITY / 2;
                    var energy_to_keep_always_in_reserve_when_supporting_sieged = energy_to_keep_always_in_reserve * 0.25;
                    var energy_pre_rcl8_scaling_balance_point = energy_to_keep_always_in_reserve * 1.1;
                    var energy_balance_point_for_rcl8_upgrading = energy_to_keep_always_in_reserve * 1.1;
                    var energy_balance_point_for_rcl8_building = energy_balance_point_for_rcl8_upgrading * 1.05;
                    var max_minerals_to_keep = STORAGE_CAPACITY / 4;
                    var room_spending_state_building = 'b';
                    var room_spending_state_upgrading = 'u';
                    var room_spending_state_rcl8_building = '8';
                    var room_spending_state_saving = 's';
                    var room_spending_state_supporting = 'p';
                    var room_spending_state_supporting_sieged = 'r';
                    var room_spending_state_under_siege = 'n';
                    var room_spending_state_selling = 'l';
                    var room_spending_state_visual = {'b': 'building', 'u': 'upgrading', '8': 'rcl8_building', 's': 'saving', 'p': 'supporting', 'r': 'supporting_sieged', 'n': 'under_siege', 'l': 'selling'};
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.energy_balance_point_for_rcl8_building = energy_balance_point_for_rcl8_building;
                        __all__.energy_balance_point_for_rcl8_upgrading = energy_balance_point_for_rcl8_upgrading;
                        __all__.energy_pre_rcl8_scaling_balance_point = energy_pre_rcl8_scaling_balance_point;
                        __all__.energy_to_keep_always_in_reserve = energy_to_keep_always_in_reserve;
                        __all__.energy_to_keep_always_in_reserve_when_supporting_sieged = energy_to_keep_always_in_reserve_when_supporting_sieged;
                        __all__.energy_to_pause_building = energy_to_pause_building;
                        __all__.energy_to_pause_upgrading = energy_to_pause_upgrading;
                        __all__.energy_to_resume_building = energy_to_resume_building;
                        __all__.energy_to_resume_upgrading = energy_to_resume_upgrading;
                        __all__.max_energy_disable_full_storage_use = max_energy_disable_full_storage_use;
                        __all__.max_energy_resume_remote_mining = max_energy_resume_remote_mining;
                        __all__.max_minerals_to_keep = max_minerals_to_keep;
                        __all__.max_total_resume_remote_mining = max_total_resume_remote_mining;
                        __all__.min_energy_enable_full_storage_use = min_energy_enable_full_storage_use;
                        __all__.min_energy_pause_remote_mining = min_energy_pause_remote_mining;
                        __all__.min_stored_energy_to_draw_from_before_refilling = min_stored_energy_to_draw_from_before_refilling;
                        __all__.min_total_pause_remote_mining = min_total_pause_remote_mining;
                        __all__.min_work_mass_per_source_for_full_storage_use = min_work_mass_per_source_for_full_storage_use;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.rcl8_energy_to_pause_upgrading = rcl8_energy_to_pause_upgrading;
                        __all__.rcl8_energy_to_resume_upgrading = rcl8_energy_to_resume_upgrading;
                        __all__.rcl_to_max_wall_hits = rcl_to_max_wall_hits;
                        __all__.rcl_to_target_wall_hits = rcl_to_target_wall_hits;
                        __all__.room_spending_state_building = room_spending_state_building;
                        __all__.room_spending_state_rcl8_building = room_spending_state_rcl8_building;
                        __all__.room_spending_state_saving = room_spending_state_saving;
                        __all__.room_spending_state_selling = room_spending_state_selling;
                        __all__.room_spending_state_supporting = room_spending_state_supporting;
                        __all__.room_spending_state_supporting_sieged = room_spending_state_supporting_sieged;
                        __all__.room_spending_state_under_siege = room_spending_state_under_siege;
                        __all__.room_spending_state_upgrading = room_spending_state_upgrading;
                        __all__.room_spending_state_visual = room_spending_state_visual;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'rooms.room_mind', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var consistency = __init__ (__world__.cache.consistency);
                    var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
                    var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
                    var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
                    var DEPOT = __init__ (__world__.constants).DEPOT;
                    var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
                    var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
                    var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
                    var PYFIND_BUILDABLE_ROADS = __init__ (__world__.constants).PYFIND_BUILDABLE_ROADS;
                    var PYFIND_HURT_CREEPS = __init__ (__world__.constants).PYFIND_HURT_CREEPS;
                    var PYFIND_REPAIRABLE_ROADS = __init__ (__world__.constants).PYFIND_REPAIRABLE_ROADS;
                    var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
                    var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
                    var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
                    var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
                    var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
                    var REROUTE = __init__ (__world__.constants).REROUTE;
                    var REROUTE_DESTINATION = __init__ (__world__.constants).REROUTE_DESTINATION;
                    var RESERVE_NOW = __init__ (__world__.constants).RESERVE_NOW;
                    var SCOUT = __init__ (__world__.constants).SCOUT;
                    var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
                    var SK_USERNAME = __init__ (__world__.constants).SK_USERNAME;
                    var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
                    var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
                    var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
                    var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
                    var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
                    var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
                    var creep_base_1500miner = __init__ (__world__.constants).creep_base_1500miner;
                    var creep_base_3000miner = __init__ (__world__.constants).creep_base_3000miner;
                    var creep_base_3h = __init__ (__world__.constants).creep_base_3h;
                    var creep_base_4000miner = __init__ (__world__.constants).creep_base_4000miner;
                    var creep_base_carry3000miner = __init__ (__world__.constants).creep_base_carry3000miner;
                    var creep_base_claim_attack = __init__ (__world__.constants).creep_base_claim_attack;
                    var creep_base_claiming = __init__ (__world__.constants).creep_base_claiming;
                    var creep_base_defender = __init__ (__world__.constants).creep_base_defender;
                    var creep_base_dismantler = __init__ (__world__.constants).creep_base_dismantler;
                    var creep_base_full_move_dismantler = __init__ (__world__.constants).creep_base_full_move_dismantler;
                    var creep_base_full_move_goader = __init__ (__world__.constants).creep_base_full_move_goader;
                    var creep_base_full_move_healer = __init__ (__world__.constants).creep_base_full_move_healer;
                    var creep_base_full_move_power_attack = __init__ (__world__.constants).creep_base_full_move_power_attack;
                    var creep_base_full_upgrader = __init__ (__world__.constants).creep_base_full_upgrader;
                    var creep_base_goader = __init__ (__world__.constants).creep_base_goader;
                    var creep_base_half_move_hauler = __init__ (__world__.constants).creep_base_half_move_hauler;
                    var creep_base_half_move_healer = __init__ (__world__.constants).creep_base_half_move_healer;
                    var creep_base_hauler = __init__ (__world__.constants).creep_base_hauler;
                    var creep_base_mammoth_miner = __init__ (__world__.constants).creep_base_mammoth_miner;
                    var creep_base_power_attack = __init__ (__world__.constants).creep_base_power_attack;
                    var creep_base_rampart_defense = __init__ (__world__.constants).creep_base_rampart_defense;
                    var creep_base_ranged_offense = __init__ (__world__.constants).creep_base_ranged_offense;
                    var creep_base_reserving = __init__ (__world__.constants).creep_base_reserving;
                    var creep_base_scout = __init__ (__world__.constants).creep_base_scout;
                    var creep_base_work_full_move_hauler = __init__ (__world__.constants).creep_base_work_full_move_hauler;
                    var creep_base_work_half_move_hauler = __init__ (__world__.constants).creep_base_work_half_move_hauler;
                    var creep_base_worker = __init__ (__world__.constants).creep_base_worker;
                    var default_roles = __init__ (__world__.constants).default_roles;
                    var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
                    var gmem_key_last_room_state_refresh = __init__ (__world__.constants).gmem_key_last_room_state_refresh;
                    var gmem_key_room_mining_paths = __init__ (__world__.constants).gmem_key_room_mining_paths;
                    var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
                    var max_repave_mine_roads_every = __init__ (__world__.constants).max_repave_mine_roads_every;
                    var min_repath_mine_roads_every = __init__ (__world__.constants).min_repath_mine_roads_every;
                    var min_repave_mine_roads_every = __init__ (__world__.constants).min_repave_mine_roads_every;
                    var old_role_names = __init__ (__world__.constants).old_role_names;
                    var recycle_time = __init__ (__world__.constants).recycle_time;
                    var request_priority_economy = __init__ (__world__.constants).request_priority_economy;
                    var request_priority_helping_party = __init__ (__world__.constants).request_priority_helping_party;
                    var request_priority_imminent_threat_defense = __init__ (__world__.constants).request_priority_imminent_threat_defense;
                    var request_priority_low = __init__ (__world__.constants).request_priority_low;
                    var rmem_key_building_paused = __init__ (__world__.constants).rmem_key_building_paused;
                    var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
                    var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
                    var rmem_key_cache = __init__ (__world__.constants).rmem_key_cache;
                    var rmem_key_carry_parts_by_role = __init__ (__world__.constants).rmem_key_carry_parts_by_role;
                    var rmem_key_creeps_by_role = __init__ (__world__.constants).rmem_key_creeps_by_role;
                    var rmem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants).rmem_key_creeps_by_role_and_replacement_time;
                    var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
                    var rmem_key_defense_mind_storage = __init__ (__world__.constants).rmem_key_defense_mind_storage;
                    var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants).rmem_key_empty_all_resources_into_room;
                    var rmem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants).rmem_key_flag_for_testing_spawning_in_simulation;
                    var rmem_key_focusing_home = __init__ (__world__.constants).rmem_key_focusing_home;
                    var rmem_key_linking_mind_storage = __init__ (__world__.constants).rmem_key_linking_mind_storage;
                    var rmem_key_metadata = __init__ (__world__.constants).rmem_key_metadata;
                    var rmem_key_mineral_mind_storage = __init__ (__world__.constants).rmem_key_mineral_mind_storage;
                    var rmem_key_now_supporting = __init__ (__world__.constants).rmem_key_now_supporting;
                    var rmem_key_pause_all_room_operations = __init__ (__world__.constants).rmem_key_pause_all_room_operations;
                    var rmem_key_planned_role_to_spawn = __init__ (__world__.constants).rmem_key_planned_role_to_spawn;
                    var rmem_key_prepping_defenses = __init__ (__world__.constants).rmem_key_prepping_defenses;
                    var rmem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants).rmem_key_remotes_explicitly_marked_under_attack;
                    var rmem_key_remotes_safe_when_under_siege = __init__ (__world__.constants).rmem_key_remotes_safe_when_under_siege;
                    var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
                    var rmem_key_spawn_requests = __init__ (__world__.constants).rmem_key_spawn_requests;
                    var rmem_key_sponsor = __init__ (__world__.constants).rmem_key_sponsor;
                    var rmem_key_storage_use_enabled = __init__ (__world__.constants).rmem_key_storage_use_enabled;
                    var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
                    var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants).rmem_key_there_might_be_energy_lying_around;
                    var rmem_key_total_open_source_spaces = __init__ (__world__.constants).rmem_key_total_open_source_spaces;
                    var rmem_key_upgrading_paused = __init__ (__world__.constants).rmem_key_upgrading_paused;
                    var rmem_key_work_parts_by_role = __init__ (__world__.constants).rmem_key_work_parts_by_role;
                    var role_bases = __init__ (__world__.constants).role_bases;
                    var role_builder = __init__ (__world__.constants).role_builder;
                    var role_cleanup = __init__ (__world__.constants).role_cleanup;
                    var role_colonist = __init__ (__world__.constants).role_colonist;
                    var role_defender = __init__ (__world__.constants).role_defender;
                    var role_energy_grab = __init__ (__world__.constants).role_energy_grab;
                    var role_hauler = __init__ (__world__.constants).role_hauler;
                    var role_link_manager = __init__ (__world__.constants).role_link_manager;
                    var role_miner = __init__ (__world__.constants).role_miner;
                    var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
                    var role_mineral_miner = __init__ (__world__.constants).role_mineral_miner;
                    var role_mineral_steal = __init__ (__world__.constants).role_mineral_steal;
                    var role_power_attack = __init__ (__world__.constants).role_power_attack;
                    var role_power_cleanup = __init__ (__world__.constants).role_power_cleanup;
                    var role_ranged_offense = __init__ (__world__.constants).role_ranged_offense;
                    var role_recycling = __init__ (__world__.constants).role_recycling;
                    var role_remote_mining_reserve = __init__ (__world__.constants).role_remote_mining_reserve;
                    var role_room_reserve = __init__ (__world__.constants).role_room_reserve;
                    var role_scout = __init__ (__world__.constants).role_scout;
                    var role_simple_claim = __init__ (__world__.constants).role_simple_claim;
                    var role_simple_dismantle = __init__ (__world__.constants).role_simple_dismantle;
                    var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
                    var role_spawn_fill_backup = __init__ (__world__.constants).role_spawn_fill_backup;
                    var role_td_goad = __init__ (__world__.constants).role_td_goad;
                    var role_td_healer = __init__ (__world__.constants).role_td_healer;
                    var role_temporary_replacing = __init__ (__world__.constants).role_temporary_replacing;
                    var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
                    var role_tower_fill_once = __init__ (__world__.constants).role_tower_fill_once;
                    var role_upgrade_fill = __init__ (__world__.constants).role_upgrade_fill;
                    var role_upgrader = __init__ (__world__.constants).role_upgrader;
                    var role_wall_defender = __init__ (__world__.constants).role_wall_defender;
                    var target_big_big_repair = __init__ (__world__.constants).target_big_big_repair;
                    var target_big_repair = __init__ (__world__.constants).target_big_repair;
                    var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
                    var target_construction = __init__ (__world__.constants).target_construction;
                    var target_destruction_site = __init__ (__world__.constants).target_destruction_site;
                    var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
                    var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
                    var target_home_flag = __init__ (__world__.constants).target_home_flag;
                    var target_rampart_defense = __init__ (__world__.constants).target_rampart_defense;
                    var target_refill = __init__ (__world__.constants).target_refill;
                    var target_repair = __init__ (__world__.constants).target_repair;
                    var target_reserve_now = __init__ (__world__.constants).target_reserve_now;
                    var target_single_flag = __init__ (__world__.constants).target_single_flag;
                    var target_single_flag2 = __init__ (__world__.constants).target_single_flag2;
                    var target_source = __init__ (__world__.constants).target_source;
                    var target_spawn_deposit = __init__ (__world__.constants).target_spawn_deposit;
                    var target_tower_fill = __init__ (__world__.constants).target_tower_fill;
                    var cache_key_spending_now = __init__ (__world__.constants.memkeys.room).cache_key_spending_now;
                    var mem_key_building_paused = __init__ (__world__.constants.memkeys.room).mem_key_building_paused;
                    var mem_key_building_priority_spawn = __init__ (__world__.constants.memkeys.room).mem_key_building_priority_spawn;
                    var mem_key_building_priority_walls = __init__ (__world__.constants.memkeys.room).mem_key_building_priority_walls;
                    var mem_key_cache = __init__ (__world__.constants.memkeys.room).mem_key_cache;
                    var mem_key_carry_parts_by_role = __init__ (__world__.constants.memkeys.room).mem_key_carry_parts_by_role;
                    var mem_key_creeps_by_role = __init__ (__world__.constants.memkeys.room).mem_key_creeps_by_role;
                    var mem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants.memkeys.room).mem_key_creeps_by_role_and_replacement_time;
                    var mem_key_currently_under_siege = __init__ (__world__.constants.memkeys.room).mem_key_currently_under_siege;
                    var mem_key_defense_mind_storage = __init__ (__world__.constants.memkeys.room).mem_key_defense_mind_storage;
                    var mem_key_empty_all_resources_into_room = __init__ (__world__.constants.memkeys.room).mem_key_empty_all_resources_into_room;
                    var mem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants.memkeys.room).mem_key_flag_for_testing_spawning_in_simulation;
                    var mem_key_focusing_home = __init__ (__world__.constants.memkeys.room).mem_key_focusing_home;
                    var mem_key_linking_mind_storage = __init__ (__world__.constants.memkeys.room).mem_key_linking_mind_storage;
                    var mem_key_metadata = __init__ (__world__.constants.memkeys.room).mem_key_metadata;
                    var mem_key_mineral_mind_storage = __init__ (__world__.constants.memkeys.room).mem_key_mineral_mind_storage;
                    var mem_key_now_supporting = __init__ (__world__.constants.memkeys.room).mem_key_now_supporting;
                    var mem_key_pause_all_room_operations = __init__ (__world__.constants.memkeys.room).mem_key_pause_all_room_operations;
                    var mem_key_planned_role_to_spawn = __init__ (__world__.constants.memkeys.room).mem_key_planned_role_to_spawn;
                    var mem_key_prepping_defenses = __init__ (__world__.constants.memkeys.room).mem_key_prepping_defenses;
                    var mem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants.memkeys.room).mem_key_remotes_explicitly_marked_under_attack;
                    var mem_key_remotes_safe_when_under_siege = __init__ (__world__.constants.memkeys.room).mem_key_remotes_safe_when_under_siege;
                    var mem_key_room_reserved_up_until_tick = __init__ (__world__.constants.memkeys.room).mem_key_room_reserved_up_until_tick;
                    var mem_key_spawn_requests = __init__ (__world__.constants.memkeys.room).mem_key_spawn_requests;
                    var mem_key_sponsor = __init__ (__world__.constants.memkeys.room).mem_key_sponsor;
                    var mem_key_storage_use_enabled = __init__ (__world__.constants.memkeys.room).mem_key_storage_use_enabled;
                    var mem_key_stored_hostiles = __init__ (__world__.constants.memkeys.room).mem_key_stored_hostiles;
                    var mem_key_there_might_be_energy_lying_around = __init__ (__world__.constants.memkeys.room).mem_key_there_might_be_energy_lying_around;
                    var mem_key_total_open_source_spaces = __init__ (__world__.constants.memkeys.room).mem_key_total_open_source_spaces;
                    var mem_key_upgrading_paused = __init__ (__world__.constants.memkeys.room).mem_key_upgrading_paused;
                    var mem_key_work_parts_by_role = __init__ (__world__.constants.memkeys.room).mem_key_work_parts_by_role;
                    var creep_wrappers = __init__ (__world__.creep_management.creep_wrappers);
                    var spawning = __init__ (__world__.creep_management.spawning);
                    var fit_num_sections = __init__ (__world__.creep_management.spawning).fit_num_sections;
                    var RoleBase = __init__ (__world__.creeps.base).RoleBase;
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var flags = __init__ (__world__.position_management.flags);
                    var ConstructionMind = __init__ (__world__.rooms.building).ConstructionMind;
                    var RoomDefense = __init__ (__world__.rooms.defense).RoomDefense;
                    var LinkingMind = __init__ (__world__.rooms.links).LinkingMind;
                    var MineralMind = __init__ (__world__.rooms.minerals).MineralMind;
                    var MiningMind = __init__ (__world__.rooms.mining).MiningMind;
                    var energy_balance_point_for_rcl8_building = __init__ (__world__.rooms.room_constants).energy_balance_point_for_rcl8_building;
                    var energy_balance_point_for_rcl8_upgrading = __init__ (__world__.rooms.room_constants).energy_balance_point_for_rcl8_upgrading;
                    var energy_pre_rcl8_scaling_balance_point = __init__ (__world__.rooms.room_constants).energy_pre_rcl8_scaling_balance_point;
                    var energy_to_keep_always_in_reserve = __init__ (__world__.rooms.room_constants).energy_to_keep_always_in_reserve;
                    var energy_to_keep_always_in_reserve_when_supporting_sieged = __init__ (__world__.rooms.room_constants).energy_to_keep_always_in_reserve_when_supporting_sieged;
                    var energy_to_pause_building = __init__ (__world__.rooms.room_constants).energy_to_pause_building;
                    var energy_to_pause_upgrading = __init__ (__world__.rooms.room_constants).energy_to_pause_upgrading;
                    var energy_to_resume_building = __init__ (__world__.rooms.room_constants).energy_to_resume_building;
                    var energy_to_resume_upgrading = __init__ (__world__.rooms.room_constants).energy_to_resume_upgrading;
                    var max_energy_disable_full_storage_use = __init__ (__world__.rooms.room_constants).max_energy_disable_full_storage_use;
                    var max_energy_resume_remote_mining = __init__ (__world__.rooms.room_constants).max_energy_resume_remote_mining;
                    var max_minerals_to_keep = __init__ (__world__.rooms.room_constants).max_minerals_to_keep;
                    var max_total_resume_remote_mining = __init__ (__world__.rooms.room_constants).max_total_resume_remote_mining;
                    var min_energy_enable_full_storage_use = __init__ (__world__.rooms.room_constants).min_energy_enable_full_storage_use;
                    var min_energy_pause_remote_mining = __init__ (__world__.rooms.room_constants).min_energy_pause_remote_mining;
                    var min_stored_energy_to_draw_from_before_refilling = __init__ (__world__.rooms.room_constants).min_stored_energy_to_draw_from_before_refilling;
                    var min_total_pause_remote_mining = __init__ (__world__.rooms.room_constants).min_total_pause_remote_mining;
                    var min_work_mass_per_source_for_full_storage_use = __init__ (__world__.rooms.room_constants).min_work_mass_per_source_for_full_storage_use;
                    var new_map = __init__ (__world__.rooms.room_constants).new_map;
                    var new_set = __init__ (__world__.rooms.room_constants).new_set;
                    var rcl8_energy_to_pause_upgrading = __init__ (__world__.rooms.room_constants).rcl8_energy_to_pause_upgrading;
                    var rcl8_energy_to_resume_upgrading = __init__ (__world__.rooms.room_constants).rcl8_energy_to_resume_upgrading;
                    var rcl_to_max_wall_hits = __init__ (__world__.rooms.room_constants).rcl_to_max_wall_hits;
                    var rcl_to_target_wall_hits = __init__ (__world__.rooms.room_constants).rcl_to_target_wall_hits;
                    var room_spending_state_building = __init__ (__world__.rooms.room_constants).room_spending_state_building;
                    var room_spending_state_rcl8_building = __init__ (__world__.rooms.room_constants).room_spending_state_rcl8_building;
                    var room_spending_state_saving = __init__ (__world__.rooms.room_constants).room_spending_state_saving;
                    var room_spending_state_selling = __init__ (__world__.rooms.room_constants).room_spending_state_selling;
                    var room_spending_state_supporting = __init__ (__world__.rooms.room_constants).room_spending_state_supporting;
                    var room_spending_state_supporting_sieged = __init__ (__world__.rooms.room_constants).room_spending_state_supporting_sieged;
                    var room_spending_state_under_siege = __init__ (__world__.rooms.room_constants).room_spending_state_under_siege;
                    var room_spending_state_upgrading = __init__ (__world__.rooms.room_constants).room_spending_state_upgrading;
                    var room_spending_state_visual = __init__ (__world__.rooms.room_constants).room_spending_state_visual;
                    var movement = __init__ (__world__.utilities.movement);
                    var speech = __init__ (__world__.utilities.speech);
                    var clamp_room_x_or_y = __init__ (__world__.utilities.positions).clamp_room_x_or_y;
                    var parse_xy_arguments = __init__ (__world__.utilities.positions).parse_xy_arguments;
                    var RoomMind = __class__ ('RoomMind', [object], {
                        get __init__ () {return __get__ (this, function (self, hive, room) {
                            self.hive = hive;
                            self.room = room;
                            Object.defineProperty (self, 'name', {'value': self.room.name});
                            self.my = room.controller && room.controller.my;
                            if (self.my) {
                                self.rcl = self.room.controller.level;
                                self.building = ConstructionMind (self);
                                self.links = LinkingMind (self);
                                self.mining = MiningMind (self);
                                self.minerals = MineralMind (self);
                            }
                            else {
                                self.rcl = 0;
                            }
                            self.defense = RoomDefense (self);
                            self.subsidiaries = [];
                            self._find_cache = new_map ();
                            self.hostile = !(room.controller) || room.controller.owner && !(room.controller.my);
                            if (room.controller && room.controller.owner) {
                                var enemy_structures = _.find (self.find (FIND_HOSTILE_STRUCTURES), (function __lambda__ (s) {
                                    return s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_TOWER;
                                }));
                                self.enemy = !(room.controller.my) && !(Memory.meta.friends.includes (self.room.controller.owner.username)) && enemy_structures;
                                if (self.enemy) {
                                    if (!(Memory.enemy_rooms.includes (self.name))) {
                                        Memory.enemy_rooms.push (room.name);
                                    }
                                }
                                else if (Memory.enemy_rooms.includes (self.name) && !(enemy_structures)) {
                                    Memory.enemy_rooms.splice (Memory.enemy_rooms.indexOf (self.name), 1);
                                }
                            }
                            else {
                                self.enemy = false;
                            }
                            if ((mem_key_sponsor in self.mem)) {
                                self.sponsor_name = self.mem [mem_key_sponsor];
                            }
                            else {
                                self.sponsor_name = null;
                            }
                        });},
                        get _get_mem () {return __get__ (this, function (self) {
                            return self.room.memory;
                        }, '_get_mem');},
                        get get_cached_property () {return __get__ (this, function (self, name) {
                            if (!(self.mem [mem_key_cache])) {
                                return null;
                            }
                            var prop_mem = self.mem [mem_key_cache] [name];
                            if (prop_mem && prop_mem.dead_at > Game.time) {
                                return prop_mem.value;
                            }
                            else {
                                return null;
                            }
                        }, 'get_cached_property');},
                        get store_cached_property () {return __get__ (this, function (self, name, value, ttl) {
                            if (!(self.mem [mem_key_cache])) {
                                self.mem [mem_key_cache] = {};
                            }
                            self.mem [mem_key_cache] [name] = {'value': value, 'dead_at': Game.time + ttl};
                        }, 'store_cached_property');},
                        get store_cached_property_at () {return __get__ (this, function (self, name, value, dead_at) {
                            if (!(self.mem [mem_key_cache])) {
                                self.mem [mem_key_cache] = {};
                            }
                            self.mem [mem_key_cache] [name] = {'value': value, 'dead_at': dead_at};
                        }, 'store_cached_property_at');},
                        get delete_cached_property () {return __get__ (this, function (self, name) {
                            if (!(self.mem [mem_key_cache])) {
                                return ;
                            }
                            delete self.mem [mem_key_cache] [name];
                        }, 'delete_cached_property');},
                        get expire_property_next_tick () {return __get__ (this, function (self, name) {
                            if (!(self.mem [mem_key_cache])) {
                                return ;
                            }
                            if (!(name in self.mem [mem_key_cache])) {
                                return ;
                            }
                            self.mem [mem_key_cache] [name].dead_at = Game.time + 1;
                        }, 'expire_property_next_tick');},
                        get find () {return __get__ (this, function (self, parameter) {
                            if (self._find_cache.has (parameter)) {
                                return self._find_cache.get (parameter);
                            }
                            else {
                                if (parameter == FIND_HOSTILE_CREEPS && len (Memory.meta.friends)) {
                                    var result = self.room.find (FIND_HOSTILE_CREEPS, {'filter': (function __lambda__ (c) {
                                        return !(Memory.meta.friends.includes (c.owner.username));
                                    })});
                                }
                                else if (parameter === PYFIND_REPAIRABLE_ROADS) {
                                    var result = _.filter (self.find (FIND_STRUCTURES), (function __lambda__ (s) {
                                        return (s.structureType == STRUCTURE_ROAD && !(flags.look_for (self, s, flags.MAIN_DESTRUCT, flags.SUB_ROAD)) || s.structureType == STRUCTURE_CONTAINER && !(flags.look_for (self, s, flags.MAIN_DESTRUCT, flags.SUB_CONTAINER))) && s.hits < s.hitsMax;
                                    }));
                                }
                                else if (parameter === PYFIND_BUILDABLE_ROADS) {
                                    var result = _.filter (self.find (FIND_CONSTRUCTION_SITES), (function __lambda__ (s) {
                                        return s.structureType == STRUCTURE_ROAD && !(flags.look_for (self, s, flags.MAIN_DESTRUCT, flags.SUB_ROAD)) || s.structureType == STRUCTURE_CONTAINER && !(flags.look_for (self, s, flags.MAIN_DESTRUCT, flags.SUB_CONTAINER));
                                    }));
                                }
                                else if (parameter === PYFIND_HURT_CREEPS) {
                                    var result = _.filter (self.find (FIND_MY_CREEPS), (function __lambda__ (c) {
                                        return c.hits < c.hitsMax;
                                    }));
                                }
                                else {
                                    var result = self.room.find (parameter);
                                }
                                self._find_cache.set (parameter, result);
                                return result;
                            }
                        }, 'find');},
                        get look_at () {return __get__ (this, function (self, look_type, pos, optional_y) {
                            if (typeof optional_y == 'undefined' || (optional_y != null && optional_y .hasOwnProperty ("__kwargtrans__"))) {;
                                var optional_y = null;
                            };
                            var __left0__ = parse_xy_arguments (pos, optional_y);
                            var x = __left0__ [0];
                            var y = __left0__ [1];
                            var room_name = __left0__ [2];
                            if (room_name !== null && room_name != self.name) {
                                var room = self.hive.get_room (room_name);
                                if (room) {
                                    return room.look_at (look_type, x, y);
                                }
                                else {
                                    return [];
                                }
                            }
                            var result = self.room.lookForAt (look_type, x, y);
                            return result;
                        }, 'look_at');},
                        get find_in_range () {return __get__ (this, function (self, find_type, find_range, pos, optional_y) {
                            if (typeof optional_y == 'undefined' || (optional_y != null && optional_y .hasOwnProperty ("__kwargtrans__"))) {;
                                var optional_y = null;
                            };
                            var __left0__ = parse_xy_arguments (pos, optional_y);
                            var x = __left0__ [0];
                            var y = __left0__ [1];
                            var room_name = __left0__ [2];
                            if (room_name !== null && room_name != self.name) {
                                var room = self.hive.get_room (pos.roomName);
                                if (room) {
                                    return room.find_in_range (find_type, find_range, x, y);
                                }
                                else {
                                    return [];
                                }
                            }
                            var raw_find_results = self.find (find_type);
                            var found = [];
                            if (len (raw_find_results)) {
                                var __iterable0__ = raw_find_results;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var element = __iterable0__ [__index0__];
                                    if (abs (element.pos.x - x) <= find_range && abs (element.pos.y - y) <= find_range) {
                                        found.append (element);
                                    }
                                }
                            }
                            return found;
                        }, 'find_in_range');},
                        get find_closest_by_range () {return __get__ (this, function (self, find_type, pos, lodash_filter) {
                            if (typeof lodash_filter == 'undefined' || (lodash_filter != null && lodash_filter .hasOwnProperty ("__kwargtrans__"))) {;
                                var lodash_filter = null;
                            };
                            if (pos.pos) {
                                var pos = pos.pos;
                            }
                            var raw_find_results = self.find (find_type);
                            if (lodash_filter) {
                                var raw_find_results = _.filter (raw_find_results, lodash_filter);
                            }
                            if (!(len (raw_find_results))) {
                                return null;
                            }
                            var closest_distance = Infinity;
                            var closest_element = null;
                            var __iterable0__ = raw_find_results;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var element = __iterable0__ [__index0__];
                                var distance = movement.chebyshev_distance_room_pos (pos, element.pos);
                                if (distance < closest_distance) {
                                    var closest_element = element;
                                    var closest_distance = distance;
                                }
                            }
                            return closest_element;
                        }, 'find_closest_by_range');},
                        get look_for_in_area_around () {return __get__ (this, function (self, look_type, pos, look_range) {
                            if (pos.pos) {
                                var pos = pos.pos;
                            }
                            return self.room.lookForAtArea (look_type, clamp_room_x_or_y (pos.y - look_range), clamp_room_x_or_y (pos.x - look_range), clamp_room_x_or_y (pos.y + look_range), clamp_room_x_or_y (pos.x + look_range), true);
                        }, 'look_for_in_area_around');},
                        get get_position () {return __get__ (this, function (self) {
                            if (!('_position' in self)) {
                                self._position = movement.parse_room_to_xy (self.room.name);
                            }
                            return self._position;
                        }, 'get_position');},
                        get get_sources () {return __get__ (this, function (self) {
                            if (!('_sources' in self)) {
                                self._sources = self.find (FIND_SOURCES);
                            }
                            return self._sources;
                        }, 'get_sources');},
                        get get_spawns () {return __get__ (this, function (self) {
                            if (!('_spawns' in self)) {
                                self._spawns = self.find (FIND_MY_SPAWNS);
                            }
                            return self._spawns;
                        }, 'get_spawns');},
                        get get_spawn () {return __get__ (this, function (self) {
                            if (!('_spawn' in self)) {
                                self._spawn = self.spawns [0] || null;
                            }
                            return self._spawn;
                        }, 'get_spawn');},
                        get get_creeps () {return __get__ (this, function (self) {
                            if (!('_creeps' in self)) {
                                if (self.my && !(self.hive.has_polled_for_creeps)) {
                                    print ('[{}] Warning: tried to retrieve creeps of room {} before calling poll_all_creeps!'.format (self.name, self.name));
                                    var creeps = [];
                                    var __iterable0__ = Object.keys (Game.creeps);
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var name = __iterable0__ [__index0__];
                                        var creep = Game.creeps [name];
                                        if (creep.memory.home == self.name) {
                                            creeps.append (creep);
                                        }
                                    }
                                    self._creeps = creeps;
                                }
                                else {
                                    self._creeps = [];
                                }
                            }
                            return self._creeps;
                        }, 'get_creeps');},
                        get get_unique_owned_index () {return __get__ (this, function (self) {
                            if (!('_unique_owned_index' in self)) {
                                if (self.my) {
                                    if (!('_owned_rooms_index' in Memory.meta)) {
                                        Memory.meta._owned_rooms_index = _ (self.hive.my_rooms).sortByOrder (['rcl', (function __lambda__ (r) {
                                            return r.position [0];
                                        }), (function __lambda__ (r) {
                                            return r.position [1];
                                        })], ['desc', 'asc', 'asc']).pluck ('name').value ();
                                        var index = Memory.meta._owned_rooms_index.indexOf (self.name);
                                    }
                                    else {
                                        var index = Memory.meta._owned_rooms_index.indexOf (self.name);
                                        if (index == -(1)) {
                                            var index = Memory.meta._owned_rooms_index.push (self.name) - 1;
                                        }
                                    }
                                    self._unique_owned_index = index;
                                }
                                else {
                                    self._unique_owned_index = -(1);
                                }
                            }
                            return self._unique_owned_index;
                        }, 'get_unique_owned_index');},
                        get _get_remote_mining_operations () {return __get__ (this, function (self) {
                            if (!('_remote_mining_operations' in self)) {
                                if (self.my) {
                                    self.hive.poll_remote_mining_flags ();
                                }
                                else {
                                    print ('[{}] Warning: accessing remote mining operations of unowned room {}.'.format (self.name, self.name));
                                    self._remote_mining_operations = [];
                                }
                            }
                            return self._remote_mining_operations;
                        }, '_get_remote_mining_operations');},
                        get _get_role_counts () {return __get__ (this, function (self) {
                            if (!(self.mem [mem_key_creeps_by_role])) {
                                self.recalculate_roles_alive ();
                            }
                            return self.mem [mem_key_creeps_by_role];
                        }, '_get_role_counts');},
                        get _get_work_mass () {return __get__ (this, function (self) {
                            if (!(self.mem [mem_key_work_parts_by_role])) {
                                self.recalculate_roles_alive ();
                            }
                            return self.mem [mem_key_work_parts_by_role];
                        }, '_get_work_mass');},
                        get _get_carry_mass () {return __get__ (this, function (self) {
                            if (!(self.mem [mem_key_carry_parts_by_role])) {
                                self.recalculate_roles_alive ();
                            }
                            return self.mem [mem_key_carry_parts_by_role];
                        }, '_get_carry_mass');},
                        get _get_rt_map () {return __get__ (this, function (self) {
                            if (!(self.mem [mem_key_creeps_by_role_and_replacement_time])) {
                                self.recalculate_roles_alive ();
                            }
                            return self.mem [mem_key_creeps_by_role_and_replacement_time];
                        }, '_get_rt_map');},
                        get role_count () {return __get__ (this, function (self, role) {
                            var count = self.role_counts [role];
                            if (count) {
                                return count;
                            }
                            else {
                                return 0;
                            }
                        }, 'role_count');},
                        get carry_mass_of () {return __get__ (this, function (self, role) {
                            var mass = self.carry_mass_map [role];
                            if (mass) {
                                return mass;
                            }
                            else {
                                return 0;
                            }
                        }, 'carry_mass_of');},
                        get work_mass_of () {return __get__ (this, function (self, role) {
                            var mass = self.work_mass_map [role];
                            if (mass) {
                                return mass;
                            }
                            else {
                                return 0;
                            }
                        }, 'work_mass_of');},
                        get register_to_role () {return __get__ (this, function (self, creep) {
                            if (!(isinstance (creep, RoleBase))) {
                                var creep = creep_wrappers.wrap_creep (self.hive, self.hive.targets, self, creep);
                            }
                            var role = creep.memory.role;
                            if ((role in self.role_counts)) {
                                self.role_counts [role]++;
                            }
                            else {
                                self.role_counts [role] = 1;
                            }
                            if ((role in self.carry_mass_map)) {
                                self.carry_mass_map [role] += spawning.carry_count (creep);
                            }
                            else {
                                self.carry_mass_map [role] = spawning.carry_count (creep);
                            }
                            if ((role in self.work_mass_map)) {
                                self.work_mass_map [role] += spawning.work_count (creep);
                            }
                            else {
                                self.work_mass_map [role] = spawning.work_count (creep);
                            }
                            var rt_map = self._get_rt_map ();
                            var rt_pair = [creep.name, creep.get_replacement_time ()];
                            if (!(rt_map [role])) {
                                rt_map [role] = [rt_pair];
                            }
                            else {
                                rt_map [role].splice (_.sortedIndex (rt_map [role], rt_pair, (function __lambda__ (p) {
                                    return p [1];
                                })), 0, rt_pair);
                            }
                        }, 'register_to_role');},
                        get recalculate_roles_alive () {return __get__ (this, function (self) {
                            var roles_alive = {};
                            var roles_work = {};
                            var roles_carry = {};
                            var rt_map = {};
                            var __iterable0__ = self.creeps;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var creep = __iterable0__ [__index0__];
                                var role = creep.memory.role;
                                if (!(role)) {
                                    continue;
                                }
                                if (!(role in roles_alive)) {
                                    roles_alive [role] = 1;
                                }
                                else {
                                    roles_alive [role]++;
                                }
                                if (!(role in roles_work)) {
                                    roles_work [role] = spawning.work_count (creep);
                                }
                                else {
                                    roles_work [role] += spawning.work_count (creep);
                                }
                                if (!(role in roles_carry)) {
                                    roles_carry [role] = spawning.carry_count (creep);
                                }
                                else {
                                    roles_carry [role] += spawning.carry_count (creep);
                                }
                                if (creep.spawning || creep.memory.role == role_temporary_replacing) {
                                    continue;
                                }
                                var creep = creep_wrappers.wrap_creep (self.hive, self.hive.targets, self, creep);
                                var rt_pair = [creep.name, creep.get_replacement_time ()];
                                if (!(rt_map [role])) {
                                    rt_map [role] = [rt_pair];
                                }
                                else {
                                    rt_map [role].splice (_.sortedIndex (rt_map [role], rt_pair, (function __lambda__ (p) {
                                        return p [1];
                                    })), 0, rt_pair);
                                }
                            }
                            self.mem [mem_key_creeps_by_role] = roles_alive;
                            self.mem [mem_key_work_parts_by_role] = roles_work;
                            self.mem [mem_key_carry_parts_by_role] = roles_carry;
                            self.mem [mem_key_creeps_by_role_and_replacement_time] = rt_map;
                        }, 'recalculate_roles_alive');},
                        get get_next_replacement_name () {return __get__ (this, function (self, role) {
                            var rt_map = self.rt_map;
                            if ((role in rt_map) && len (rt_map [role])) {
                                var __iterable0__ = rt_map [role];
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var rt_pair = __iterable0__ [__index0__];
                                    if (rt_pair [1] > Game.time) {
                                        break;
                                    }
                                    var name = rt_pair [0];
                                    if (Memory.creeps [name] && !(Memory.creeps [name].replacement)) {
                                        return name;
                                    }
                                }
                            }
                            return null;
                        }, 'get_next_replacement_name');},
                        get register_new_replacing_creep () {return __get__ (this, function (self, replaced_name, replacing_name) {
                            if (Memory.creeps [replaced_name]) {
                                Memory.creeps [replaced_name].replacement = replacing_name;
                            }
                            else {
                                print ("[{}] Couldn't find creep-needing-replacement {} to register {} as the replacer to!".format (self.name, replaced_name, replacing_name));
                            }
                        }, 'register_new_replacing_creep');},
                        get replacements_currently_needed_for () {return __get__ (this, function (self, role) {
                            var rt_map = self._get_rt_map ();
                            var count = 0;
                            if ((role in rt_map) && len (rt_map [role])) {
                                var __iterable0__ = rt_map [role];
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var __left0__ = __iterable0__ [__index0__];
                                    var creep = __left0__ [0];
                                    var replacement_time = __left0__ [1];
                                    if (Game.creeps [creep] && !(Memory.creeps [creep].replacement) && replacement_time <= Game.time) {
                                        count++;
                                    }
                                }
                            }
                            return count;
                        }, 'replacements_currently_needed_for');},
                        get count_noneol_creeps_targeting () {return __get__ (this, function (self, target_type, target_id) {
                            var count = 0;
                            var targeters = self.hive.targets.creeps_now_targeting (target_type, target_id);
                            var __iterable0__ = targeters;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var name = __iterable0__ [__index0__];
                                var creep = Game.creeps [name];
                                if (creep && Game.time < self.replacement_time_of (creep)) {
                                    count++;
                                }
                            }
                            return count;
                        }, 'count_noneol_creeps_targeting');},
                        get carry_mass_of_replacements_currently_needed_for () {return __get__ (this, function (self, role) {
                            var mass = 0;
                            var rt_map = self._get_rt_map ();
                            if ((role in rt_map) && len (rt_map [role])) {
                                var __iterable0__ = rt_map [role];
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var __left0__ = __iterable0__ [__index0__];
                                    var creep = __left0__ [0];
                                    var replacement_time = __left0__ [1];
                                    if (Game.creeps [creep] && !(Memory.creeps [creep].replacement) && replacement_time <= Game.time) {
                                        mass += spawning.carry_count (Game.creeps [creep]);
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                            return mass;
                        }, 'carry_mass_of_replacements_currently_needed_for');},
                        get work_mass_of_replacements_currently_needed_for () {return __get__ (this, function (self, role) {
                            var mass = 0;
                            var rt_map = self._get_rt_map ();
                            if ((role in rt_map) && len (rt_map [role])) {
                                var __iterable0__ = rt_map [role];
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var __left0__ = __iterable0__ [__index0__];
                                    var creep = __left0__ [0];
                                    var replacement_time = __left0__ [1];
                                    if (Game.creeps [creep] && !(Memory.creeps [creep].replacement) && replacement_time <= Game.time) {
                                        mass += spawning.work_count (Game.creeps [creep]);
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                            return mass;
                        }, 'work_mass_of_replacements_currently_needed_for');},
                        get replacement_time_of () {return __get__ (this, function (self, creep) {
                            if (('get_replacement_time' in creep)) {
                                return creep.get_replacement_time ();
                            }
                            if (creep.memory.home != self.name) {
                                var home_room = self.hive.get_room (creep.memory.home);
                                if (home_room) {
                                    return home_room.replacement_time_of (creep);
                                }
                                else {
                                    console.log ("Couldn't find home of {} ({})!".format (creep.name, creep.memory.home));
                                }
                            }
                            if (('wrapped' in creep)) {
                                var creep = creep.wrapped;
                            }
                            else {
                                var creep = creep_wrappers.wrap_creep (self.hive, self.hive.targets, self, creep);
                                if (!(creep)) {
                                    return Infinity;
                                }
                            }
                            return creep.get_replacement_time ();
                        }, 'replacement_time_of');},
                        get check_all_creeps_next_tick () {return __get__ (this, function (self) {
                            self.mem [mem_key_cache] ['clear_next'] = 0;
                        }, 'check_all_creeps_next_tick');},
                        get precreep_tick_actions () {return __get__ (this, function (self) {
                            var time = Game.time;
                            var meta = self.mem [mem_key_metadata];
                            if (!(meta)) {
                                var __left0__ = {'clear_next': 0, 'reset_spawn_on': 0};
                                self.mem [mem_key_metadata] = __left0__;
                                var meta = __left0__;
                            }
                            if (time >= meta.clear_next) {
                                consistency.clear_memory (self);
                                self.recalculate_roles_alive ();
                                self.reset_planned_role ();
                                delete meta.clear_now;
                            }
                            if (time >= meta.reset_spawn_on) {
                                self.reset_planned_role ();
                                meta.reset_spawn_on = consistency.get_next_replacement_time (self) + 1;
                            }
                            if (__mod__ (Game.time, 10) == 0) {
                                self.reassign_roles ();
                            }
                            if (__mod__ (Game.time, 500) == 0) {
                                self._check_request_expirations ();
                            }
                        }, 'precreep_tick_actions');},
                        get reassign_roles () {return __get__ (this, function (self) {
                            return consistency.reassign_room_roles (self);
                        }, 'reassign_roles');},
                        get paving () {return __get__ (this, function (self) {
                            if (!('_paving' in self)) {
                                if (!(self.my)) {
                                    self._paving = false;
                                }
                                else {
                                    var paving = self.get_cached_property ('paving_here');
                                    if (paving === null) {
                                        var needed_energy_capacity = (BODYPART_COST [WORK] * 2 + BODYPART_COST [MOVE] * 4) + BODYPART_COST [CARRY] * 6;
                                        var paving = (self.room.storage || self.spawn) && (self.get_max_mining_op_count () >= 1 || self.room.storage) && len (self.mining.available_mines) >= 1 && self.room.energyCapacityAvailable >= needed_energy_capacity;
                                        self.store_cached_property ('paving_here', paving, 200);
                                    }
                                    self._paving = paving;
                                }
                            }
                            return self._paving;
                        }, 'paving');},
                        get all_paved () {return __get__ (this, function (self) {
                            return self.paving ();
                        }, 'all_paved');},
                        get any_local_miners () {return __get__ (this, function (self) {
                            if (!('_any_miners' in self)) {
                                var any_miners = false;
                                var __iterable0__ = self.mining.local_mines;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var flag = __iterable0__ [__index0__];
                                    if (self.hive.targets.workforce_of (target_energy_miner_mine, 'flag-{}'.format (flag.name)) > 0) {
                                        var any_miners = true;
                                        break;
                                    }
                                }
                                self._any_miners = any_miners;
                            }
                            return self._any_miners;
                        }, 'any_local_miners');},
                        get all_local_miners () {return __get__ (this, function (self) {
                            if (!('_all_miners' in self)) {
                                var all_miners = true;
                                var __iterable0__ = self.mining.local_mines;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var flag = __iterable0__ [__index0__];
                                    if (self.hive.targets.workforce_of (target_energy_miner_mine, 'flag-{}'.format (flag.name)) <= 0) {
                                        var all_miners = false;
                                        break;
                                    }
                                }
                                self._all_miners = all_miners;
                            }
                            return self._all_miners;
                        }, 'all_local_miners');},
                        get get_work_mass () {return __get__ (this, function (self) {
                            if (!('_work_mass' in self)) {
                                var mass = 0;
                                var __iterable0__ = self.get_creeps ();
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var creep = __iterable0__ [__index0__];
                                    var __iterable1__ = creep.body;
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var part = __iterable1__ [__index1__];
                                        if (part.type == WORK || part.type == CARRY) {
                                            mass++;
                                        }
                                    }
                                }
                                self._work_mass = math.floor (mass / 2);
                            }
                            return self._work_mass;
                        }, 'get_work_mass');},
                        get get_trying_to_get_full_storage_use () {return __get__ (this, function (self) {
                            if (!('_trying_to_get_full_storage_use' in self)) {
                                self._trying_to_get_full_storage_use = self.room.storage && (self.room.storage.store [RESOURCE_ENERGY] >= min_stored_energy_to_draw_from_before_refilling || self.any_local_miners () && self.work_mass >= min_work_mass_per_source_for_full_storage_use * len (self.sources));
                            }
                            return self._trying_to_get_full_storage_use;
                        }, 'get_trying_to_get_full_storage_use');},
                        get get_full_storage_use () {return __get__ (this, function (self) {
                            if (!('_full_storage_use' in self)) {
                                if (self.room.storage && (self.room.storage.store [RESOURCE_ENERGY] >= min_stored_energy_to_draw_from_before_refilling || !(self.spawn) && self.room.storage.store [RESOURCE_ENERGY] > 0)) {
                                    self._full_storage_use = true;
                                }
                                else if (self.room.storage && !(self.room.storage.storeCapacity)) {
                                    if (self.room.storage.store.energy > 0) {
                                        self._full_storage_use = true;
                                    }
                                    else {
                                        self._full_storage_use = false;
                                        if (!(self.room.storage.my)) {
                                            self.room.storage.destroy ();
                                        }
                                    }
                                }
                                else if (self.trying_to_get_full_storage_use) {
                                    if (self.mem [mem_key_storage_use_enabled] && self.room.storage.store [RESOURCE_ENERGY] <= max_energy_disable_full_storage_use) {
                                        print ('[{}] Disabling full storage use.'.format (self.name));
                                        self.mem [mem_key_storage_use_enabled] = false;
                                    }
                                    if (!(self.mem [mem_key_storage_use_enabled]) && self.room.storage.store [RESOURCE_ENERGY] > min_energy_enable_full_storage_use) {
                                        print ('[{}] Enabling full storage use.'.format (self.name));
                                        self.mem [mem_key_storage_use_enabled] = true;
                                    }
                                    self._full_storage_use = self.mem [mem_key_storage_use_enabled];
                                }
                                else {
                                    self._full_storage_use = false;
                                }
                            }
                            return self._full_storage_use;
                        }, 'get_full_storage_use');},
                        get being_bootstrapped () {return __get__ (this, function (self) {
                            if (self.rcl >= 6 || !(self.sponsor_name) || self.spawn) {
                                return false;
                            }
                            var sponsor = self.hive.get_room (self.sponsor_name);
                            if (!(sponsor) || !(sponsor.my) || !(sponsor.spawn)) {
                                return false;
                            }
                            return true;
                        }, 'being_bootstrapped');},
                        get mining_ops_paused () {return __get__ (this, function (self) {
                            if (!(self.full_storage_use)) {
                                return false;
                            }
                            if (self.mem [mem_key_focusing_home] && _.sum (self.room.storage.store) < max_total_resume_remote_mining || self.room.storage.store.energy < max_energy_resume_remote_mining) {
                                self.mem [mem_key_focusing_home] = false;
                            }
                            if (!(self.mem [mem_key_focusing_home]) && _.sum (self.room.storage.store) > min_total_pause_remote_mining && self.room.storage.store.energy > min_energy_pause_remote_mining) {
                                self.mem [mem_key_focusing_home] = true;
                            }
                            return !(!(self.mem [mem_key_focusing_home]));
                        }, 'mining_ops_paused');},
                        get upgrading_paused () {return __get__ (this, function (self) {
                            if (!('_upgrading_paused' in self)) {
                                if (self.rcl < 4 || !(self.room.storage) || self.room.storage.storeCapacity <= 0) {
                                    self._upgrading_paused = false;
                                }
                                else if (self.conducting_siege () && (self.room.storage.store.energy < 100 * 1000 || self.rcl < 7 && self.room.storage.store.energy < 500 * 1000)) {
                                    self._upgrading_paused = true;
                                }
                                else {
                                    if (self.rcl >= 8) {
                                        if (self.mem [mem_key_upgrading_paused] && self.room.storage.store.energy > rcl8_energy_to_resume_upgrading) {
                                            self.mem [mem_key_upgrading_paused] = false;
                                        }
                                        if (!(self.mem [mem_key_upgrading_paused]) && self.room.storage.store.energy < rcl8_energy_to_pause_upgrading) {
                                            self.mem [mem_key_upgrading_paused] = true;
                                        }
                                    }
                                    else {
                                        if (self.mem [mem_key_upgrading_paused] && self.room.storage.store.energy > energy_to_resume_upgrading) {
                                            self.mem [mem_key_upgrading_paused] = false;
                                        }
                                        if (!(self.mem [mem_key_upgrading_paused]) && self.room.storage.store.energy < energy_to_pause_upgrading) {
                                            self.mem [mem_key_upgrading_paused] = true;
                                        }
                                    }
                                    self._upgrading_paused = !(!(self.mem [mem_key_upgrading_paused]));
                                }
                            }
                            return self._upgrading_paused;
                        }, 'upgrading_paused');},
                        get building_paused () {return __get__ (this, function (self) {
                            if (!('_building_paused' in self)) {
                                if (self.rcl < 4 || !(self.room.storage) || self.room.storage.storeCapacity <= 0) {
                                    self._building_paused = false;
                                }
                                else if (self.conducting_siege () && self.rcl < 7) {
                                    self._building_paused = true;
                                }
                                else {
                                    if (self.mem [mem_key_building_paused] && self.room.storage.store.energy > energy_to_resume_building) {
                                        self.mem [mem_key_building_paused] = false;
                                    }
                                    if (!(self.mem [mem_key_building_paused]) && self.room.storage.store.energy < energy_to_pause_building) {
                                        self.mem [mem_key_building_paused] = true;
                                    }
                                    if (self.mem [mem_key_building_paused]) {
                                        self._building_paused = self.spawn && len (_.filter (self.find (FIND_MY_STRUCTURES), (function __lambda__ (s) {
                                            return s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_EXTENSION;
                                        }))) > len (_.filter (self.find (FIND_MY_CONSTRUCTION_SITES), (function __lambda__ (s) {
                                            return s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_EXTENSION;
                                        })));
                                    }
                                    else {
                                        self._building_paused = false;
                                    }
                                }
                            }
                            return self._building_paused;
                        }, 'building_paused');},
                        get overprioritize_building () {return __get__ (this, function (self) {
                            if (!('_overprioritize_building' in self)) {
                                if (self.spawn) {
                                    var prioritize = (self.room.energyCapacityAvailable < BODYPART_COST [WORK] * 5 + BODYPART_COST [MOVE] && self.get_open_source_spaces () < len (self.sources) * 2 || self.rcl >= 3 && !(len (self.defense.towers ())) || self.rcl >= 3 && self.room.energyCapacityAvailable < BODYPART_COST [CLAIM] + BODYPART_COST [MOVE] || self.rcl >= 4 && self.room.energyCapacityAvailable < BODYPART_COST [CLAIM] * 2 + BODYPART_COST [MOVE] * 2) && len (self.building.get_construction_targets ()) && self.room.controller.ticksToDowngrade > 100;
                                }
                                else {
                                    var prioritize = !(self.being_bootstrapped ());
                                }
                                self._overprioritize_building = prioritize;
                            }
                            return self._overprioritize_building;
                        }, 'overprioritize_building');},
                        get upgrading_deprioritized () {return __get__ (this, function (self) {
                            var deprioritized = self.get_cached_property ('upgrading_deprioritized');
                            if (deprioritized !== null) {
                                return deprioritized;
                            }
                            var deprioritized = !(!((self.upgrading_paused () || self.rcl < 4 && len (self.subsidiaries) && !(self.being_bootstrapped ()) || !(self.spawn) && !(self.being_bootstrapped ()) || self.under_siege () && (!(self.room.storage) || self.room.storage.storeCapacity)) && self.room.controller.ticksToDowngrade >= 1000 && (!(self.room.storage) || self.room.storage.store.energy < 700 * 1000)));
                            self.store_cached_property ('upgrading_deprioritized', deprioritized, 15);
                            return deprioritized;
                        }, 'upgrading_deprioritized');},
                        get under_siege () {return __get__ (this, function (self) {
                            return !(!(self.mem [mem_key_currently_under_siege]));
                        }, 'under_siege');},
                        get any_remotes_under_siege () {return __get__ (this, function (self) {
                            return self.mem [mem_key_currently_under_siege] || self.mem [mem_key_remotes_explicitly_marked_under_attack];
                        }, 'any_remotes_under_siege');},
                        get remote_under_siege () {return __get__ (this, function (self, flag) {
                            return self.any_remotes_under_siege () && flag.pos.roomName != self.name && (!(self.mem [mem_key_remotes_safe_when_under_siege]) || !(self.mem [mem_key_remotes_safe_when_under_siege].includes (flag.pos.roomName)));
                        }, 'remote_under_siege');},
                        get conducting_siege () {return __get__ (this, function (self) {
                            if (!('_conducting_siege' in self)) {
                                self._conducting_siege = Game.cpu.bucket > 4500 && !(!((self._any_closest_to_me (TD_D_GOAD) || self._any_closest_to_me (ATTACK_POWER_BANK) || self._any_closest_to_me (ATTACK_DISMANTLE)) && self._any_closest_to_me (TD_H_H_STOP) && self._any_closest_to_me (TD_H_D_STOP)));
                            }
                            return self._conducting_siege;
                        }, 'conducting_siege');},
                        get get_max_mining_op_count () {return __get__ (this, function (self) {
                            if (!(self.my)) {
                                print ('[{}] WARNING: get_max_mining_op_count called for non-owned room!'.format (self.name));
                                return 0;
                            }
                            var sources = len (self.sources);
                            if (sources <= 1) {
                                if (len (self.spawns) < 2) {
                                    return 5;
                                }
                                else if (self.rcl == 7) {
                                    return 7;
                                }
                                else if (self.mining_ops_paused ()) {
                                    return 0;
                                }
                                else {
                                    return 9;
                                }
                            }
                            else if (len (self.spawns) < 2) {
                                return 5;
                            }
                            else if (self.rcl == 7) {
                                return 6;
                            }
                            else if (self.mining_ops_paused ()) {
                                return 0;
                            }
                            else {
                                return 9;
                            }
                        }, 'get_max_mining_op_count');},
                        get get_max_sane_wall_hits () {return __get__ (this, function (self) {
                            return rcl_to_max_wall_hits [self.rcl - 1] || 0;
                        }, 'get_max_sane_wall_hits');},
                        get get_min_sane_wall_hits () {return __get__ (this, function (self) {
                            return rcl_to_target_wall_hits [self.rcl - 1] || 0;
                        }, 'get_min_sane_wall_hits');},
                        get get_upgrader_energy_struct () {return __get__ (this, function (self) {
                            if (self._upgrader_source === undefined) {
                                var structure_id = self.get_cached_property ('upgrader_source_id');
                                if (structure_id) {
                                    if (structure_id == -(1)) {
                                        self._upgrader_source = null;
                                        return null;
                                    }
                                    else {
                                        var structure = Game.getObjectById (structure_id);
                                        if (structure) {
                                            self._upgrader_source = structure;
                                            return structure;
                                        }
                                    }
                                }
                                var structure = null;
                                if (self.room.storage && !(self.being_bootstrapped ())) {
                                    if (self.room.storage.pos.inRangeTo (self.room.controller, 4)) {
                                        var structure = self.room.storage;
                                    }
                                    else {
                                        var all_structs_near = _ (self.find_in_range (FIND_STRUCTURES, 4, self.room.controller.pos));
                                        if (self.links.main_link && all_structs_near.find ({'structureType': STRUCTURE_LINK, 'my': true})) {
                                            var structure = all_structs_near.filter ({'structureType': STRUCTURE_LINK}).min ((function __lambda__ (s) {
                                                return movement.chebyshev_distance_room_pos (s, self.room.controller);
                                            }));
                                        }
                                        else if (all_structs_near.find ({'structureType': STRUCTURE_CONTAINER})) {
                                            var structure = all_structs_near.filter ({'structureType': STRUCTURE_CONTAINER}).min ((function __lambda__ (s) {
                                                return movement.chebyshev_distance_room_pos (s, self.room.controller);
                                            }));
                                        }
                                    }
                                }
                                else {
                                    var structure = _ (self.find_in_range (FIND_STRUCTURES, 4, self.room.controller.pos)).filter ({'structureType': STRUCTURE_CONTAINER}).min ((function __lambda__ (s) {
                                        return movement.chebyshev_distance_room_pos (s, self.room.controller);
                                    }));
                                    if (structure == Infinity || structure == -(Infinity)) {
                                        var structure = null;
                                    }
                                }
                                if (structure) {
                                    var structure_id = structure.id;
                                }
                                else {
                                    var structure_id = -(1);
                                }
                                self._upgrader_source = structure;
                                self.store_cached_property ('upgrader_source_id', structure_id, 15);
                            }
                            return self._upgrader_source;
                        }, 'get_upgrader_energy_struct');},
                        get get_extra_fill_targets () {return __get__ (this, function (self) {
                            if (!('_extra_fill_targets' in self)) {
                                var extra_targets = [];
                                var cont = self.get_upgrader_energy_struct ();
                                if (cont && cont.structureType == STRUCTURE_CONTAINER) {
                                    extra_targets.push (cont);
                                }
                                self._extra_fill_targets = _.filter (extra_targets, (function __lambda__ (s) {
                                    return s.storeCapacity && _.sum (s.store) < s.storeCapacity || s.energyCapacity && s.energy < s.energyCapacity;
                                }));
                            }
                            return self._extra_fill_targets;
                        }, 'get_extra_fill_targets');},
                        get get_open_source_spaces () {return __get__ (this, function (self) {
                            if (!('oss' in self.mem)) {
                                var oss = 0;
                                var __iterable0__ = self.sources;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var source = __iterable0__ [__index0__];
                                    for (var x = source.pos.x - 1; x < source.pos.x + 2; x++) {
                                        for (var y = source.pos.y - 1; y < source.pos.y + 2; y++) {
                                            if (movement.is_block_empty (self, x, y)) {
                                                oss++;
                                            }
                                        }
                                    }
                                }
                                self.mem [mem_key_total_open_source_spaces] = oss;
                            }
                            return self.mem [mem_key_total_open_source_spaces];
                        }, 'get_open_source_spaces');},
                        get get_open_source_spaces_around () {return __get__ (this, function (self, source) {
                            var key = 'oss-{}'.format (source.id);
                            if (!(key in self.mem)) {
                                var oss = 0;
                                for (var x = source.pos.x - 1; x < source.pos.x + 2; x++) {
                                    for (var y = source.pos.y - 1; y < source.pos.y + 2; y++) {
                                        if (movement.is_block_empty (self, x, y)) {
                                            oss++;
                                        }
                                    }
                                }
                                self.mem [key] = oss;
                            }
                            return self.mem [key];
                        }, 'get_open_source_spaces_around');},
                        get calculate_smallest_wall () {return __get__ (this, function (self) {
                            if (self._smallest_wall_hits === undefined) {
                                var least_hits = Infinity;
                                var __iterable0__ = self.find (FIND_STRUCTURES);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var struct = __iterable0__ [__index0__];
                                    if (struct.structureType == STRUCTURE_WALL || struct.structureType == STRUCTURE_RAMPART) {
                                        if (struct.hits < least_hits) {
                                            var least_hits = struct.hits;
                                        }
                                    }
                                }
                                if (least_hits === Infinity) {
                                    var least_hits = 0;
                                }
                                self._smallest_wall_hits = least_hits;
                            }
                            return self._smallest_wall_hits;
                        }, 'calculate_smallest_wall');},
                        get set_supporting_room () {return __get__ (this, function (self, target) {
                            var old_target = self.mem [mem_key_now_supporting];
                            self.mem [mem_key_now_supporting] = target;
                            if (target != old_target || target !== null && _.get (Memory, ['rooms', target, mem_key_currently_under_siege]) && self.main_spending_expenditure () != room_spending_state_supporting_sieged) {
                                self.reset_spending_state ();
                            }
                        }, 'set_supporting_room');},
                        get reset_spending_state () {return __get__ (this, function (self) {
                            self.delete_cached_property (cache_key_spending_now);
                            self.reset_planned_role ();
                        }, 'reset_spending_state');},
                        get main_spending_expenditure () {return __get__ (this, function (self) {
                            var cached = self.get_cached_property (cache_key_spending_now);
                            if (cached) {
                                return cached;
                            }
                            if (!(self.full_storage_use)) {
                                self.store_cached_property (cache_key_spending_now, room_spending_state_saving, 500);
                                return room_spending_state_saving;
                            }
                            if (self.mem [mem_key_now_supporting]) {
                                var room = self.hive.get_room (self.mem [mem_key_now_supporting]);
                                if (room.mem [mem_key_currently_under_siege]) {
                                    var state = room_spending_state_supporting_sieged;
                                }
                                else {
                                    var energy = self.minerals.get_estimate_total_energy ();
                                    if (energy < energy_to_keep_always_in_reserve) {
                                        var state = room_spending_state_saving;
                                    }
                                    else {
                                        var state = room_spending_state_supporting;
                                    }
                                }
                            }
                            else {
                                var energy = self.minerals.get_estimate_total_energy ();
                                var non_energy = self.room.terminal && self.minerals.get_estimate_total_non_energy ();
                                if (energy < energy_to_keep_always_in_reserve) {
                                    var state = room_spending_state_saving;
                                }
                                else if (self.rcl >= 8) {
                                    var state = room_spending_state_building;
                                }
                                else if (self.building.get_target_num_builders () > 1 && self.building.get_max_builder_work_parts () > 5) {
                                    var state = room_spending_state_building;
                                }
                                else {
                                    var least_hits = self.calculate_smallest_wall ();
                                    if (least_hits < self.min_sane_wall_hits) {
                                        var state = room_spending_state_building;
                                    }
                                    else {
                                        var state = room_spending_state_upgrading;
                                    }
                                }
                            }
                            self.store_cached_property (cache_key_spending_now, state, 500);
                            return state;
                        }, 'main_spending_expenditure');},
                        get _any_closest_to_me () {return __get__ (this, function (self, flag_type) {
                            var __iterable0__ = flags.find_flags_global (flag_type);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                if (('sponsor' in flag.memory)) {
                                    if (flag.memory.sponsor == self.name) {
                                        return true;
                                    }
                                }
                                else {
                                    var possible_sponsor = str (flag.name).py_split ('_') [0];
                                    if ((possible_sponsor in Game.rooms)) {
                                        if (possible_sponsor == self.name) {
                                            return true;
                                        }
                                    }
                                    else if (self.hive.get_closest_owned_room (flag.pos.roomName).name == self.name) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        });},
                        get flags_without_target () {return __get__ (this, function (self, flag_type) {
                            var result = [];
                            var __iterable0__ = flags.find_flags_global (flag_type);
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var flag = __iterable0__ [__index0__];
                                if (flag.memory.sponsor) {
                                    var ours = flag.memory.sponsor == self.name;
                                }
                                else {
                                    var possible_sponsor = str (flag.name).py_split ('_') [0];
                                    if ((possible_sponsor in Game.rooms)) {
                                        var ours = possible_sponsor == self.name;
                                    }
                                    else {
                                        var ours = self.hive.get_closest_owned_room (flag.pos.roomName).name == self.name;
                                    }
                                }
                                if (ours) {
                                    var flag_id = 'flag-{}'.format (flag.name);
                                    var noneol_targeting_count = self.count_noneol_creeps_targeting (target_single_flag, flag_id);
                                    if (noneol_targeting_count < 1) {
                                        result.append (flag);
                                    }
                                }
                            }
                            return result;
                        });},
                        get get_spawn_for_flag () {return __get__ (this, function (self, role, half_move_base, full_move_base, flag, max_sections) {
                            if (typeof max_sections == 'undefined' || (max_sections != null && max_sections .hasOwnProperty ("__kwargtrans__"))) {;
                                var max_sections = 0;
                            };
                            if (movement.distance_squared_room_pos (self.spawn, flag) > math.pow (200, 2)) {
                                var base = full_move_base;
                            }
                            else {
                                var base = half_move_base;
                            }
                            var sections = spawning.max_sections_of (self, base);
                            if (max_sections) {
                                var sections = min (sections, max_sections);
                            }
                            if (flag.memory.size) {
                                var sections = min (sections, flag.memory.size);
                            }
                            var obj = {'role': role, 'base': base, 'num_sections': sections, 'targets': [[target_single_flag, 'flag-{}'.format (flag.name)]]};
                            if (('boosted' in flag.memory) && !(flag.memory.boosted)) {
                                obj.memory = {'boosted': 2};
                            }
                            return obj;
                        });},
                        get spawn_one_creep_per_flag () {return __get__ (this, function (self, flag_type, role, half_move_base, full_move_base, max_sections) {
                            if (typeof max_sections == 'undefined' || (max_sections != null && max_sections .hasOwnProperty ("__kwargtrans__"))) {;
                                var max_sections = 0;
                            };
                            var flag_list = self.flags_without_target (flag_type);
                            if (len (flag_list)) {
                                return self.get_spawn_for_flag (role, half_move_base, full_move_base, flag_list [0], max_sections);
                            }
                            return null;
                        });},
                        get get_target_link_manager_count () {return __get__ (this, function (self) {
                            if (!('_target_link_managers' in self)) {
                                var links = 0;
                                var __iterable0__ = self.find (FIND_STRUCTURES);
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var s = __iterable0__ [__index0__];
                                    if (s.structureType == STRUCTURE_LINK) {
                                        links++;
                                    }
                                }
                                if (links >= 2 && self.trying_to_get_full_storage_use) {
                                    self._target_link_managers = 1;
                                }
                                else {
                                    self._target_link_managers = 0;
                                }
                            }
                            return self._target_link_managers;
                        });},
                        get get_target_wall_defender_count () {return __get__ (this, function (self) {
                            if (self.under_siege ()) {
                                var __left0__ = self.defense.get_current_defender_spots ();
                                var hot = __left0__ [0];
                                var cold = __left0__ [1];
                                return len (hot) + len (cold) / 2;
                            }
                        });},
                        get get_target_simple_defender_count () {return __get__ (this, function (self, first) {
                            if (typeof first == 'undefined' || (first != null && first .hasOwnProperty ("__kwargtrans__"))) {;
                                var first = false;
                            };
                            if (self.under_siege ()) {
                                return 0;
                            }
                            if (!((first ? '_first_simple_target_defender_count' : '_target_defender_count') in self)) {
                                var needed_local = math.ceil (_.sum (self.defense.dangerous_hostiles (), (function __lambda__ (h) {
                                    return self.defense.danger_level (h) >= 2;
                                })) / 3);
                                if (first) {
                                    self._first_simple_target_defender_count = needed_local;
                                }
                                else {
                                    var invaded_rooms = new_map ();
                                    var __iterable0__ = self.defense.remote_hostiles ();
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var h = __iterable0__ [__index0__];
                                        if (h.user == INVADER_USERNAME) {
                                            if (h.heal) {
                                                var need = 8;
                                            }
                                            else if (h.ranged && !(h.attack)) {
                                                var need = -(100);
                                            }
                                            else {
                                                var need = 1;
                                            }
                                            if (invaded_rooms.has (h.room)) {
                                                invaded_rooms.set (h.room, invaded_rooms.get (h.room) + need);
                                            }
                                            else {
                                                invaded_rooms.set (h.room, need);
                                            }
                                        }
                                    }
                                    var needed_for_mines = _.sum (list (invaded_rooms.values ()), (function __lambda__ (v) {
                                        return max (0, math.ceil (v / 3));
                                    }));
                                    self._target_defender_count = needed_local + needed_for_mines;
                                }
                            }
                            return (first ? self._first_simple_target_defender_count : self._target_defender_count);
                        });},
                        get get_target_colonist_work_mass () {return __get__ (this, function (self) {
                            if (self.under_siege ()) {
                                return 0;
                            }
                            if (!('_target_colonist_work_mass' in self)) {
                                var worker_mass = spawning.max_sections_of (self, creep_base_worker);
                                var hauler_mass = spawning.max_sections_of (self, creep_base_half_move_hauler);
                                var needed = 0;
                                var mineral_steal = 0;
                                var __iterable0__ = self.subsidiaries;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var room = __iterable0__ [__index0__];
                                    if (!(room.room.controller.safeMode) && _.find (room.defense.dangerous_hostiles (), (function __lambda__ (c) {
                                        return c.hasBodyparts (ATTACK) || c.hasBodyparts (RANGED_ATTACK);
                                    }))) {
                                        continue;
                                    }
                                    var distance = self.hive.honey.find_path_length (self.spawn, movement.center_pos (room.name), {'range': 15});
                                    var room_work_mass = 0;
                                    var rt_map = room.rt_map;
                                    var __iterable1__ = Object.keys (room.work_mass_map);
                                    for (var __index1__ = 0; __index1__ < __iterable1__.length; __index1__++) {
                                        var role = __iterable1__ [__index1__];
                                        room_work_mass += room.work_mass_map [role];
                                        if ((role in rt_map) && len (rt_map [role])) {
                                            var __iterable2__ = rt_map [role];
                                            for (var __index2__ = 0; __index2__ < __iterable2__.length; __index2__++) {
                                                var __left0__ = __iterable2__ [__index2__];
                                                var creep = __left0__ [0];
                                                var replacement_time = __left0__ [1];
                                                if (Game.creeps [creep] && !(Memory.creeps [creep].replacement) && replacement_time + distance <= Game.time) {
                                                    room_work_mass -= spawning.work_count (Game.creeps [creep]);
                                                }
                                                else {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (room.room.storage) {
                                        var target = min (10, 5 + (room.room.storage.store.energy / 20) * 1000) * worker_mass;
                                    }
                                    else if (len (room.sources) >= 2) {
                                        var target = 5 * worker_mass;
                                    }
                                    else {
                                        var target = 10;
                                    }
                                    needed += max (0, target - room_work_mass);
                                    if (room.room.storage && _.sum (room.room.storage.store) > room.room.storage.store.energy && room.room.storage.storeCapacity <= 0) {
                                        mineral_steal += hauler_mass;
                                    }
                                }
                                if (Game.cpu.bucket < 4000) {
                                    var needed = 0;
                                }
                                self._target_colonist_work_mass = needed;
                                self._target_mineral_steal_mass = mineral_steal;
                            }
                            return self._target_colonist_work_mass;
                        });},
                        get get_target_mineral_steal_mass () {return __get__ (this, function (self) {
                            if (!('_target_mineral_steal_mass' in self)) {
                                self.get_target_colonist_work_mass ();
                            }
                            return self._target_mineral_steal_mass;
                        });},
                        get get_target_spawn_fill_backup_carry_mass () {return __get__ (this, function (self) {
                            if (self.full_storage_use || self.all_local_miners ()) {
                                if (self.full_storage_use && (self.any_local_miners () || self.work_mass > 25 && self.role_count (role_tower_fill) > 0 && self.role_count (role_spawn_fill) > 0)) {
                                    return 0;
                                }
                                else {
                                    return 3;
                                }
                            }
                            else if (self.rcl < 3) {
                                return len (self.sources) * spawning.max_sections_of (self, creep_base_worker);
                            }
                            else {
                                return math.floor (self.get_target_total_spawn_fill_mass () / 2);
                            }
                        });},
                        get get_target_spawn_fill_mass () {return __get__ (this, function (self) {
                            if (!('_target_spawn_fill_mass' in self)) {
                                if (self.full_storage_use || self.any_local_miners ()) {
                                    var tower_fill = self.carry_mass_of (role_tower_fill);
                                    var total_mass = math.ceil (self.get_target_total_spawn_fill_mass ());
                                    if (self.rcl < 4 || !(self.room.storage)) {
                                        var fill_size = fit_num_sections (total_mass, spawning.max_sections_of (self, creep_base_hauler), 0, 2);
                                        var __iterable0__ = self.mining.local_mines;
                                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                            var flag = __iterable0__ [__index0__];
                                            var sitting = self.mining.energy_sitting_at (flag);
                                            if (sitting > 1000) {
                                                total_mass += math.ceil (sitting / 500) * fill_size;
                                            }
                                        }
                                    }
                                    if (self.under_siege () || self.mem [mem_key_prepping_defenses]) {
                                        self._target_spawn_fill_mass = total_mass;
                                    }
                                    else {
                                        self._target_spawn_fill_mass = max (0, min (1, total_mass), total_mass - tower_fill);
                                    }
                                }
                                else {
                                    self._target_spawn_fill_mass = 0;
                                }
                            }
                            return self._target_spawn_fill_mass;
                        });},
                        get get_target_total_spawn_fill_mass () {return __get__ (this, function (self) {
                            if (!('_total_needed_spawn_fill_mass' in self)) {
                                if (self.room.energyCapacityAvailable < 550 && self.get_open_source_spaces () < len (self.sources) * 2) {
                                    self._total_needed_spawn_fill_mass = 3;
                                }
                                else {
                                    self._total_needed_spawn_fill_mass = math.pow ((self.room.energyCapacityAvailable / 50.0) * 200, 0.3);
                                    if (self.under_siege () || self.mem [mem_key_prepping_defenses]) {
                                        self._total_needed_spawn_fill_mass *= 1.5;
                                    }
                                    else if (len (self.mining.active_mines) < 2) {
                                        self._total_needed_spawn_fill_mass /= 2;
                                    }
                                }
                            }
                            return self._total_needed_spawn_fill_mass;
                        });},
                        get get_target_builder_work_mass () {return __get__ (this, function (self) {
                            if (('_target_builder_work_mass' in self)) {
                                return self._target_builder_work_mass;
                            }
                            self._target_builder_work_mass = 0;
                            if (self.building_paused ()) {
                                self._target_builder_work_mass = 0;
                                return 0;
                            }
                            var base_num = self.building.get_target_num_builders ();
                            if (base_num <= 0) {
                                self._target_builder_work_mass = 0;
                                return 0;
                            }
                            if (self.full_storage_use) {
                                var spending = self.main_spending_expenditure ();
                                if (spending == room_spending_state_building) {
                                    var extra = self.minerals.get_estimate_total_energy () - energy_pre_rcl8_scaling_balance_point;
                                    var wm = spawning.max_sections_of (self, creep_base_worker);
                                    if (extra > 0) {
                                        wm += math.floor (extra / (20 * 1000));
                                    }
                                }
                                else if (spending == room_spending_state_rcl8_building) {
                                    var extra = self.minerals.get_estimate_total_energy () - energy_balance_point_for_rcl8_building;
                                    var wm = min (4, spawning.max_sections_of (self, creep_base_worker));
                                    if (extra > 0) {
                                        wm += math.floor (extra / (20 * 1000));
                                    }
                                }
                                else if (spending == room_spending_state_supporting_sieged) {
                                    var wm = self.building.get_max_builder_work_parts_urgent ();
                                }
                                else if (spending == room_spending_state_under_siege) {
                                    if (self.minerals.get_estimate_total_energy () < energy_to_keep_always_in_reserve / 2) {
                                        var wm = self.building.get_max_builder_work_parts_urgent ();
                                    }
                                    else {
                                        var extra = self.minerals.get_estimate_total_energy () - energy_balance_point_for_rcl8_building;
                                        var wm = spawning.max_sections_of (self, creep_base_worker) * 3;
                                        if (extra > 0) {
                                            wm += math.floor (extra / (20 * 1000));
                                        }
                                    }
                                }
                                else {
                                    var wm = min (self.building.get_max_builder_work_parts_noextra (), spawning.max_sections_of (self, creep_base_worker) * 3);
                                }
                            }
                            else if (self.trying_to_get_full_storage_use) {
                                var wm = spawning.max_sections_of (self, creep_base_worker) * 2;
                            }
                            else if (self.room.energyCapacityAvailable < 550) {
                                var wm = base_num;
                            }
                            else {
                                var wm = base_num * max (2, min (8, spawning.max_sections_of (self, creep_base_worker)));
                            }
                            var wm = min (wm, self.building.get_max_builder_work_parts ());
                            self._target_builder_work_mass = wm;
                            return wm;
                        });},
                        get get_target_upgrade_fill_mass () {return __get__ (this, function (self) {
                            if (!('_target_upgrade_fill_work_mass' in self)) {
                                var target = self.get_upgrader_energy_struct ();
                                if (!(target) || target.structureType != STRUCTURE_CONTAINER) {
                                    self._target_upgrade_fill_work_mass = 0;
                                }
                                else {
                                    var upgrader_work_mass = self.get_target_upgrader_work_mass ();
                                    if (upgrader_work_mass <= 0) {
                                        self._target_upgrade_fill_work_mass = 0;
                                    }
                                    else if (upgrader_work_mass <= 1) {
                                        self._target_upgrade_fill_work_mass = 1;
                                    }
                                    else {
                                        if (self.room.storage) {
                                            var distance = self.hive.honey.find_path_length (self.room.storage, target, {'use_roads': false});
                                        }
                                        else {
                                            var distance = 0;
                                            var __iterable0__ = self.sources;
                                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                                var source = __iterable0__ [__index0__];
                                                distance += self.hive.honey.find_path_length (source, target, {'use_roads': false});
                                            }
                                            distance /= len (self.sources);
                                        }
                                        var carry_per_tick_per_part = CARRY_CAPACITY / (distance * 2) + 5;
                                        var need_per_tick = upgrader_work_mass * UPGRADE_CONTROLLER_POWER;
                                        self._target_upgrade_fill_work_mass = math.ceil (need_per_tick / carry_per_tick_per_part);
                                    }
                                }
                            }
                            return self._target_upgrade_fill_work_mass;
                        });},
                        get get_target_upgrader_work_mass () {return __get__ (this, function (self) {
                            if (('_target_upgrader_work_mass' in self)) {
                                return self._target_upgrader_work_mass;
                            }
                            var base = self.get_variable_base (role_upgrader);
                            var sections = spawning.max_sections_of (self, base);
                            if (base === creep_base_full_upgrader) {
                                var worker_size = max (4, 2 * sections);
                            }
                            else {
                                var worker_size = max (1, math.ceil (sections));
                            }
                            if (self.upgrading_deprioritized () || self.overprioritize_building ()) {
                                if (self.room.controller.ticksToDowngrade <= 5000) {
                                    var wm = 1;
                                }
                                else {
                                    var wm = 0;
                                }
                                self._target_upgrader_work_mass = wm;
                                return wm;
                            }
                            else if (self.get_full_storage_use ()) {
                                var spending = self.main_spending_expenditure ();
                                if (spending == room_spending_state_upgrading) {
                                    var wm = 4;
                                    var extra = self.minerals.get_estimate_total_energy () - energy_to_keep_always_in_reserve;
                                    if (extra > 0) {
                                        wm += math.floor (extra / 2000);
                                        if (extra >= STORAGE_CAPACITY / 5) {
                                            wm += math.ceil ((extra - STORAGE_CAPACITY / 5) / 400);
                                        }
                                    }
                                }
                                else if (spending == room_spending_state_rcl8_building || spending == room_spending_state_supporting) {
                                    var extra = self.minerals.get_estimate_total_energy () - energy_balance_point_for_rcl8_upgrading;
                                    if (extra < 0) {
                                        var wm = 4;
                                    }
                                    else {
                                        var wm = 15;
                                    }
                                }
                                else if (spending == room_spending_state_supporting) {
                                    var extra = self.minerals.get_estimate_total_energy () - energy_balance_point_for_rcl8_upgrading;
                                    if (extra < 0) {
                                        var wm = 4;
                                    }
                                    else if (len (self.possible_remote_mining_operations) >= 3) {
                                        var wm = 15;
                                    }
                                    else {
                                        var wm = 10;
                                    }
                                }
                                else if (spending == room_spending_state_supporting_sieged || spending == room_spending_state_under_siege) {
                                    if (self.room.controller.ticksToDowngrade <= 10 * 1000) {
                                        var wm = 1;
                                    }
                                    else {
                                        var wm = 0;
                                    }
                                }
                                else {
                                    var wm = 4;
                                }
                            }
                            else if (self.room.energyCapacityAvailable < 550) {
                                var wm = self.get_open_source_spaces () * worker_size;
                                var __iterable0__ = self.sources;
                                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                    var source = __iterable0__ [__index0__];
                                    var energy = _.sum (self.find_in_range (FIND_DROPPED_ENERGY, 1, source.pos), 'amount');
                                    wm += energy / 200.0;
                                }
                            }
                            else {
                                var wm = (len (self.sources) * 2) * worker_size;
                            }
                            if (base === creep_base_full_upgrader) {
                                var max_upgraders = max (4, len (flags.find_flags (self, UPGRADER_SPOT)));
                                self._target_upgrader_work_mass = min (wm, worker_size * max_upgraders);
                            }
                            else if (self.room.storage && !(self.room.storage.storeCapacity)) {
                                self._target_upgrader_work_mass = min (wm, worker_size * 15);
                            }
                            else {
                                var max_upgraders = max (8, len (flags.find_flags (self, UPGRADER_SPOT)));
                                self._target_upgrader_work_mass = min (wm, worker_size * max_upgraders);
                            }
                            return self._target_upgrader_work_mass;
                        });},
                        get get_target_tower_fill_mass () {return __get__ (this, function (self) {
                            if (!(self.get_target_spawn_fill_mass ())) {
                                return 0;
                            }
                            var towers = self.defense.towers ();
                            if (len (towers)) {
                                var size = max (1, min (5, spawning.max_sections_of (self, creep_base_hauler))) * 0.75;
                                return math.ceil (min (size * len (towers), self.get_target_total_spawn_fill_mass ()));
                            }
                            else {
                                return 0;
                            }
                        });},
                        get get_target_room_reserve_count () {return __get__ (this, function (self) {
                            if (!('_target_room_reserve_count' in self)) {
                                var count = 0;
                                if (self.room.energyCapacityAvailable >= 650) {
                                    var __iterable0__ = flags.find_flags_global (RESERVE_NOW);
                                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                        var flag = __iterable0__ [__index0__];
                                        var room_name = flag.pos.roomName;
                                        var room = Game.rooms [room_name];
                                        if (!(room) || room.controller && !(room.controller.my) && !(room.controller.owner)) {
                                            if (self.hive.get_closest_owned_room (flag.pos.roomName).name != self.name) {
                                                continue;
                                            }
                                            count++;
                                        }
                                    }
                                }
                                self._target_room_reserve_count = count;
                            }
                            return self._target_room_reserve_count;
                        });},
                        get get_target_spawn_fill_size () {return __get__ (this, function (self) {
                            if (self.under_siege () || self.mem [mem_key_prepping_defenses]) {
                                return fit_num_sections (self.get_target_total_spawn_fill_mass (), spawning.max_sections_of (self, creep_base_hauler));
                            }
                            else {
                                return fit_num_sections (self.get_target_total_spawn_fill_mass (), spawning.max_sections_of (self, creep_base_hauler), 0, 2);
                            }
                        });},
                        get get_upgrader_size () {return __get__ (this, function (self) {
                            var base = self.get_variable_base (role_upgrader);
                            var sections = self.get_target_upgrader_work_mass ();
                            var target = self.get_target_upgrader_work_mass ();
                            if (base == creep_base_full_upgrader && target > 1) {
                                return spawning.ceil_sections (min (sections, target / 2), base);
                            }
                            else {
                                return spawning.ceil_sections (min (sections, target), base);
                            }
                        });},
                        get get_builder_size () {return __get__ (this, function (self) {
                            var base = self.get_variable_base (role_builder);
                            return min (spawning.max_sections_of (self, base), self.building.get_max_builder_work_parts ());
                        });},
                        get get_upgrade_fill_size () {return __get__ (this, function (self) {
                            var mass = self.get_target_upgrade_fill_mass ();
                            if (mass <= 0) {
                                return 1;
                            }
                            else {
                                return fit_num_sections (mass + 2, spawning.max_sections_of (self, creep_base_hauler));
                            }
                        });},
                        get request_creep () {return __get__ (this, function (self, role, opts) {
                            if (typeof opts == 'undefined' || (opts != null && opts .hasOwnProperty ("__kwargtrans__"))) {;
                                var opts = null;
                            };
                            var req_key = Math.floor ((1 + Math.random ()) * 65536).toString (16).substring (1);
                            if ((mem_key_spawn_requests in self.mem)) {
                                while ((req_key in self.mem [mem_key_spawn_requests] ['s'])) {
                                    req_key += Math.floor ((1 + Math.random ()) * 65536).toString (16).substring (1);
                                }
                            }
                            self.register_creep_request (req_key, request_priority_low, Game.time + 50 * 1000, _.merge ({'role': role, 'base': self.get_variable_base (role), 'num_sections': self.get_max_sections_for_role (role)}, opts));
                        });},
                        get register_creep_request () {return __get__ (this, function (self, specific_key, priority, expire_at, role_obj) {
                            if (!(mem_key_spawn_requests in self.mem)) {
                                self.mem [mem_key_spawn_requests] = {'q': [], 's': {}};
                            }
                            var req = self.mem [mem_key_spawn_requests];
                            var old_priority = _.get (req, ['s', specific_key, 'p'], null);
                            req ['s'] [specific_key] = {'e': expire_at, 'p': priority, 'o': JSON.stringify (role_obj)};
                            if (req ['q'].includes (specific_key)) {
                                if (old_priority === null || old_priority == priority) {
                                    return ;
                                }
                                else {
                                    req ['q'].splice (req ['q'].indexOf (specific_key), 1);
                                }
                            }
                            req ['q'].splice (_.sortedIndex (req ['q'], specific_key, (function __lambda__ (key) {
                                return req ['s'] [key] ['p'];
                            })), 0, specific_key);
                            if (len (req ['q']) <= 1 && self.get_next_role () === null) {
                                self.reset_planned_role ();
                            }
                        });},
                        get _get_next_requested_creep () {return __get__ (this, function (self, max_priority) {
                            if (typeof max_priority == 'undefined' || (max_priority != null && max_priority .hasOwnProperty ("__kwargtrans__"))) {;
                                var max_priority = Infinity;
                            };
                            if (!(mem_key_spawn_requests in self.mem)) {
                                return ;
                            }
                            var requests = self.mem [mem_key_spawn_requests];
                            while (len (requests ['q']) > 0) {
                                var request_key = requests ['q'] [0];
                                var request = requests ['s'] [request_key];
                                if (request.e < Game.time) {
                                    requests ['q'].shift ();
                                    continue;
                                }
                                if (request.p > max_priority) {
                                    break;
                                }
                                var role_obj = JSON.parse (request.o);
                                role_obj ['rkey'] = request_key;
                                return role_obj;
                            }
                            return null;
                        });},
                        get successfully_spawned_request () {return __get__ (this, function (self, request_key) {
                            if (!(mem_key_spawn_requests in self.mem)) {
                                return ;
                            }
                            var requests = self.mem [mem_key_spawn_requests];
                            var index = requests ['q'].indexOf (request_key);
                            if (index != -(1)) {
                                requests ['q'].splice (index, 1);
                            }
                            delete requests ['s'] [request_key];
                        });},
                        get _check_request_expirations () {return __get__ (this, function (self) {
                            if (!(mem_key_spawn_requests in self.mem)) {
                                return ;
                            }
                            var requests = self.mem [mem_key_spawn_requests];
                            var __iterable0__ = _.remove (requests ['q'], (function __lambda__ (key) {
                                return _.get (requests ['s'], [key, 'e'], 0) < Game.time;
                            }));
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var key = __iterable0__ [__index0__];
                                delete requests ['s'] [key];
                            }
                            if (!(len (requests ['q']))) {
                                delete self.mem [mem_key_spawn_requests];
                            }
                        });},
                        get _check_role_reqs () {return __get__ (this, function (self, role_list) {
                            var role_needed = null;
                            var __iterable0__ = role_list;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var __left0__ = __iterable0__ [__index0__];
                                var role = __left0__ [0];
                                var get_ideal = __left0__ [1];
                                var count_carry = __left0__ [2];
                                var count_work = __left0__ [3];
                                if (count_carry) {
                                    if (self.carry_mass_of (role) - self.carry_mass_of_replacements_currently_needed_for (role) < get_ideal ()) {
                                        var role_needed = role;
                                        break;
                                    }
                                }
                                else if (count_work) {
                                    if (self.work_mass_of (role) - self.work_mass_of_replacements_currently_needed_for (role) < get_ideal ()) {
                                        var role_needed = role;
                                        break;
                                    }
                                }
                                else if (self.role_count (role) - self.replacements_currently_needed_for (role) < get_ideal ()) {
                                    var role_needed = role;
                                    break;
                                }
                            }
                            if (role_needed) {
                                return {'role': role_needed, 'base': self.get_variable_base (role_needed), 'replacing': self.get_next_replacement_name (role_needed), 'num_sections': self.get_max_sections_for_role (role_needed)};
                            }
                            else {
                                return null;
                            }
                        });},
                        get get_variable_base () {return __get__ (this, function (self, role) {
                            if (role == role_hauler) {
                                if (self.all_paved ()) {
                                    return creep_base_work_half_move_hauler;
                                }
                                else if (self.paving ()) {
                                    return creep_base_work_full_move_hauler;
                                }
                                else {
                                    return creep_base_hauler;
                                }
                            }
                            else if (role == role_upgrader) {
                                if (self.get_upgrader_energy_struct ()) {
                                    return creep_base_full_upgrader;
                                }
                                else {
                                    return creep_base_worker;
                                }
                            }
                            else {
                                return role_bases [role];
                            }
                        });},
                        get get_max_sections_for_role () {return __get__ (this, function (self, role) {
                            var max_mass = {[role_spawn_fill_backup]: (function __lambda__ () {
                                return fit_num_sections ((spawning.using_lower_energy_section (self, creep_base_worker) ? self.get_target_spawn_fill_backup_carry_mass () : spawning.ceil_sections (self.get_target_spawn_fill_backup_carry_mass () / 3, creep_base_worker)), spawning.max_sections_of (self, creep_base_worker));
                            }), [role_link_manager]: (function __lambda__ () {
                                return min (self.get_target_link_manager_count () * 8, spawning.max_sections_of (self, creep_base_hauler));
                            }), [role_spawn_fill]: self.get_target_spawn_fill_size, [role_tower_fill]: self.get_target_spawn_fill_size, [role_upgrader]: self.get_upgrader_size, [role_upgrade_fill]: self.get_target_upgrade_fill_mass, [role_defender]: (function __lambda__ () {
                                return min (4, spawning.max_sections_of (self, creep_base_defender));
                            }), [role_wall_defender]: (function __lambda__ () {
                                return spawning.max_sections_of (self, creep_base_rampart_defense);
                            }), [role_room_reserve]: (function __lambda__ () {
                                return min (2, spawning.max_sections_of (self, creep_base_reserving));
                            }), [role_colonist]: (function __lambda__ () {
                                return spawning.max_sections_of (self, creep_base_worker);
                            }), [role_builder]: self.get_builder_size, [role_mineral_miner]: (function __lambda__ () {
                                return min (4, spawning.max_sections_of (self, creep_base_mammoth_miner));
                            }), [role_mineral_hauler]: (function __lambda__ () {
                                return min (10, spawning.max_sections_of (self, creep_base_hauler));
                            }), [role_td_goad]: (function __lambda__ () {
                                return spawning.max_sections_of (self, creep_base_goader);
                            }), [role_td_healer]: (function __lambda__ () {
                                return spawning.max_sections_of (self, creep_base_half_move_healer);
                            }), [role_simple_dismantle]: (function __lambda__ () {
                                return spawning.max_sections_of (self, creep_base_dismantler);
                            })};
                            if ((role in max_mass)) {
                                return max_mass [role] ();
                            }
                            else {
                                print ("[{}] Can't find max section function for role {}!".format (self.name, role));
                                return Infinity;
                            }
                        });},
                        get _next_needed_local_mining_role () {return __get__ (this, function (self) {
                            if (spawning.would_be_emergency (self)) {
                                if (!(self.full_storage_use) && !(self.any_local_miners ())) {
                                    var next_role = self._check_role_reqs ([[role_spawn_fill_backup, self.get_target_spawn_fill_backup_carry_mass, true]]);
                                    if (next_role !== null) {
                                        return next_role;
                                    }
                                }
                                var next_role = self._check_role_reqs ([[role_tower_fill, self.get_target_tower_fill_mass, true], [role_spawn_fill, self.get_target_spawn_fill_mass, true]]);
                                if (next_role !== null) {
                                    return next_role;
                                }
                            }
                            var next_role = self._check_role_reqs ([[role_defender, (function __lambda__ () {
                                return self.get_target_simple_defender_count (true);
                            })], [role_link_manager, self.get_target_link_manager_count]]);
                            if (next_role !== null) {
                                return next_role;
                            }
                            var mining_role = self.mining.next_mining_role (len (self.sources));
                            if (mining_role !== null && mining_role.role == role_miner) {
                                return mining_role;
                            }
                            var next_role = self._check_role_reqs ([[role_tower_fill, self.get_target_tower_fill_mass, true], [role_spawn_fill, self.get_target_spawn_fill_mass, true], [role_wall_defender, self.get_target_wall_defender_count], [role_defender, self.get_target_simple_defender_count], [role_colonist, self.get_target_colonist_work_mass, false, true]]);
                            if (next_role !== null) {
                                return next_role;
                            }
                            if (self.room.controller.ticksToDowngrade < 2000) {
                                var upgrader = self._check_role_reqs ([[role_upgrade_fill, self.get_target_upgrade_fill_mass, true], [role_upgrader, self.get_target_upgrader_work_mass, false, true]]);
                                if (upgrader !== null) {
                                    return upgrader;
                                }
                            }
                            else if (_.get (self, 'room.storage.store.energy', 0) > 800 * 1000) {
                                var overflow_role = self._check_role_reqs ([[role_builder, self.get_target_builder_work_mass, false, true], [role_upgrade_fill, self.get_target_upgrade_fill_mass, true], [role_upgrader, self.get_target_upgrader_work_mass, false, true]]);
                                if (overflow_role !== null) {
                                    return overflow_role;
                                }
                            }
                            if (mining_role !== null) {
                                return mining_role;
                            }
                            return null;
                        });},
                        get _next_needed_local_role () {return __get__ (this, function (self) {
                            var requirements = [[role_upgrade_fill, self.get_target_upgrade_fill_mass, true], [role_builder, self.get_target_builder_work_mass, false, true], [role_upgrader, self.get_target_upgrader_work_mass, false, true], [role_room_reserve, self.get_target_room_reserve_count], [role_colonist, self.get_target_colonist_work_mass, false, true], [role_mineral_steal, self.get_target_mineral_steal_mass, true], [role_mineral_hauler, self.minerals.get_target_mineral_hauler_count], [role_mineral_miner, self.minerals.get_target_mineral_miner_count]];
                            return self._check_role_reqs (requirements);
                        });},
                        get _next_cheap_military_role () {return __get__ (this, function (self) {
                            return self.spawn_one_creep_per_flag (SCOUT, role_scout, creep_base_scout, creep_base_scout, 1);
                        });},
                        get wall_defense () {return __get__ (this, function (self) {
                            return self._check_role_reqs ([[role_wall_defender, self.get_target_wall_defender_count]]);
                        });},
                        get _next_complex_defender () {return __get__ (this, function (self) {
                            if (self.room.energyCapacityAvailable >= 500) {
                                var flag_list = self.flags_without_target (RANGED_DEFENSE);
                                if (len (flag_list)) {
                                    var flag = flag_list [0];
                                    if ((flag.name in Memory.flags) && flag.memory.heal) {
                                        var base = creep_base_3h;
                                    }
                                    else {
                                        var base = creep_base_ranged_offense;
                                    }
                                    return self.get_spawn_for_flag (role_ranged_offense, base, base, flag, 0);
                                }
                                return null;
                            }
                        });},
                        get _next_claim () {return __get__ (this, function (self) {
                            if (self.room.energyCapacityAvailable >= 650) {
                                var flag_list = self.flags_without_target (CLAIM_LATER);
                                var _needs_claim = function (flag) {
                                    if (Memory.enemy_rooms.includes (flag.pos.roomName) && self.room.energyCapacityAvailable < 650 * 5) {
                                        return false;
                                    }
                                    else if (!(flag.pos.roomName in Game.rooms)) {
                                        return true;
                                    }
                                    else {
                                        var room = Game.rooms [flag.pos.roomName];
                                        if (!(room.controller) || room.controller.my) {
                                            return false;
                                        }
                                        else if (room.controller.owner && self.room.energyCapacityAvailable < 650 * 5) {
                                            return false;
                                        }
                                        else {
                                            return true;
                                        }
                                    }
                                };
                                var needed = _.find (flag_list, _needs_claim);
                                if (needed) {
                                    if (Memory.enemy_rooms.includes (needed.pos.roomName)) {
                                        return self.get_spawn_for_flag (role_simple_claim, creep_base_claim_attack, creep_base_claim_attack, needed);
                                    }
                                    else {
                                        return self.get_spawn_for_flag (role_simple_claim, creep_base_claiming, creep_base_claiming, needed, 1);
                                    }
                                }
                            }
                            return null;
                        });},
                        get _next_tower_breaker_role () {return __get__ (this, function (self) {
                            if (!(self.conducting_siege ())) {
                                return null;
                            }
                            var role_obj = self.spawn_one_creep_per_flag (TD_H_H_STOP, role_td_healer, creep_base_half_move_healer, creep_base_full_move_healer);
                            if (role_obj) {
                                return role_obj;
                            }
                            var role_obj = self.spawn_one_creep_per_flag (TD_D_GOAD, role_td_goad, creep_base_goader, creep_base_full_move_goader);
                            if (role_obj) {
                                return role_obj;
                            }
                            var role_obj = self.spawn_one_creep_per_flag (ATTACK_DISMANTLE, role_simple_dismantle, creep_base_dismantler, creep_base_full_move_dismantler);
                            if (role_obj) {
                                return role_obj;
                            }
                            var role_obj = self.spawn_one_creep_per_flag (ENERGY_GRAB, role_energy_grab, creep_base_hauler, creep_base_hauler);
                            if (role_obj) {
                                return role_obj;
                            }
                            var role_obj = self.spawn_one_creep_per_flag (ATTACK_POWER_BANK, role_power_attack, creep_base_power_attack, creep_base_full_move_power_attack);
                            if (role_obj) {
                                return role_obj;
                            }
                            var role_obj = self.spawn_one_creep_per_flag (ATTACK_POWER_BANK, role_power_attack, creep_base_power_attack, creep_base_full_move_power_attack);
                            if (role_obj) {
                                return role_obj;
                            }
                            var role_obj = self.spawn_one_creep_per_flag (REAP_POWER_BANK, role_power_cleanup, creep_base_half_move_hauler, creep_base_hauler);
                            if (role_obj) {
                                return role_obj;
                            }
                            return null;
                        });},
                        get next_cheap_dismantle_goal () {return __get__ (this, function (self) {
                            if (self.conducting_siege () || self.under_siege ()) {
                                return ;
                            }
                            var role_obj = self.spawn_one_creep_per_flag (ENERGY_GRAB, role_energy_grab, creep_base_hauler, creep_base_hauler);
                            if (role_obj) {
                                return role_obj;
                            }
                            var role_obj = self.spawn_one_creep_per_flag (ATTACK_DISMANTLE, role_simple_dismantle, creep_base_dismantler, creep_base_full_move_dismantler);
                            if (role_obj) {
                                return role_obj;
                            }
                        });},
                        get reset_planned_role () {return __get__ (this, function (self) {
                            delete self.mem [mem_key_planned_role_to_spawn];
                            if (!(self.spawn)) {
                                var sponsor = self.hive.get_room (self.sponsor_name);
                                if (sponsor && sponsor.spawn) {
                                    if (_.sum (self.role_counts) < 3 && sponsor.next_role === null) {
                                        sponsor.reset_planned_role ();
                                    }
                                }
                            }
                        });},
                        get plan_next_role () {return __get__ (this, function (self) {
                            if (!(self.my)) {
                                return null;
                            }
                            if (self.mem [mem_key_flag_for_testing_spawning_in_simulation]) {
                                var funcs_to_try = [(function __lambda__ () {
                                    return self._check_role_reqs ([[role_spawn_fill, self.get_target_spawn_fill_mass, true]]);
                                }), self.wall_defense, self._next_cheap_military_role, self._next_tower_breaker_role, self._next_complex_defender, self._get_next_requested_creep];
                            }
                            else {
                                var funcs_to_try = [self._next_needed_local_mining_role, (function __lambda__ () {
                                    return self._get_next_requested_creep (request_priority_imminent_threat_defense);
                                }), self.wall_defense, self._next_cheap_military_role, self.next_cheap_dismantle_goal, self._next_complex_defender, self.mining.next_mining_role, (function __lambda__ () {
                                    return self._get_next_requested_creep (request_priority_economy);
                                }), self._next_tower_breaker_role, self._next_needed_local_role, self._next_claim, self._get_next_requested_creep];
                            }
                            var next_role = null;
                            var __iterable0__ = funcs_to_try;
                            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                                var func = __iterable0__ [__index0__];
                                var next_role = func ();
                                if (next_role) {
                                    var maximum = spawning.max_sections_of (self, next_role.base);
                                    if (next_role.num_sections !== null && next_role.num_sections > maximum) {
                                        print ('[{}] Function decided on {} sections for {} (a {}), which is more than the allowed {}.'.format (self.name, next_role.num_sections, next_role.base, next_role.role, maximum));
                                        next_role.num_sections = maximum;
                                    }
                                    break;
                                }
                            }
                            if (next_role) {
                                self.mem [mem_key_planned_role_to_spawn] = next_role;
                            }
                            else {
                                if (len (self.spawns) <= 1) {
                                    print ('[{}] All creep targets reached!'.format (self.name));
                                }
                                self.mem [mem_key_planned_role_to_spawn] = null;
                            }
                        });},
                        get get_next_role () {return __get__ (this, function (self) {
                            if (self.mem [mem_key_planned_role_to_spawn] === undefined) {
                                self.plan_next_role ();
                                spawning.validate_role (self.mem [mem_key_planned_role_to_spawn]);
                            }
                            return self.mem [mem_key_planned_role_to_spawn];
                        });},
                        get sing () {return __get__ (this, function (self, creeps_here_now) {
                            if (!(self.name in Memory ['_ly'])) {
                                Memory ['_ly'] [self.name] = [_ (speech.songs).keys ().sample (), 0];
                            }
                            var __left0__ = Memory ['_ly'] [self.name];
                            var song_key = __left0__ [0];
                            var position = __left0__ [1];
                            if (!(song_key in speech.songs) || position >= len (speech.songs [song_key])) {
                                var song_key = _ (speech.songs).keys ().sample ();
                                var position = 0;
                            }
                            var note = speech.songs [song_key] [position];
                            if (note !== null) {
                                _.sample (creeps_here_now).say (note, true);
                            }
                            Memory ['_ly'] [self.name] = [song_key, position + 1];
                        });},
                        get toString () {return __get__ (this, function (self) {
                            return 'RoomMind[name: {}, my: {}, using_storage: {}, conducting_siege: {}]'.format (self.name, self.my, self.full_storage_use, self.conducting_siege ());
                        });}
                    });
                    Object.defineProperty (RoomMind, 'mem', property.call (RoomMind, RoomMind._get_mem));;
                    Object.defineProperty (RoomMind, 'possible_remote_mining_operations', property.call (RoomMind, RoomMind._get_remote_mining_operations));;
                    Object.defineProperty (RoomMind, 'role_counts', property.call (RoomMind, RoomMind._get_role_counts));;
                    Object.defineProperty (RoomMind, 'work_mass_map', property.call (RoomMind, RoomMind._get_work_mass));;
                    Object.defineProperty (RoomMind, 'carry_mass_map', property.call (RoomMind, RoomMind._get_carry_mass));;
                    Object.defineProperty (RoomMind, 'position', property.call (RoomMind, RoomMind.get_position));;
                    Object.defineProperty (RoomMind, 'sources', property.call (RoomMind, RoomMind.get_sources));;
                    Object.defineProperty (RoomMind, 'spawns', property.call (RoomMind, RoomMind.get_spawns));;
                    Object.defineProperty (RoomMind, 'spawn', property.call (RoomMind, RoomMind.get_spawn));;
                    Object.defineProperty (RoomMind, 'creeps', property.call (RoomMind, RoomMind.get_creeps));;
                    Object.defineProperty (RoomMind, 'work_mass', property.call (RoomMind, RoomMind.get_work_mass));;
                    Object.defineProperty (RoomMind, 'next_role', property.call (RoomMind, RoomMind.get_next_role));;
                    Object.defineProperty (RoomMind, 'rt_map', property.call (RoomMind, RoomMind._get_rt_map));;
                    Object.defineProperty (RoomMind, 'trying_to_get_full_storage_use', property.call (RoomMind, RoomMind.get_trying_to_get_full_storage_use));;
                    Object.defineProperty (RoomMind, 'full_storage_use', property.call (RoomMind, RoomMind.get_full_storage_use));;
                    Object.defineProperty (RoomMind, 'max_sane_wall_hits', property.call (RoomMind, RoomMind.get_max_sane_wall_hits));;
                    Object.defineProperty (RoomMind, 'min_sane_wall_hits', property.call (RoomMind, RoomMind.get_min_sane_wall_hits));;
                    __pragma__ ('<use>' +
                        'cache.consistency' +
                        'constants' +
                        'constants.memkeys.room' +
                        'creep_management.creep_wrappers' +
                        'creep_management.spawning' +
                        'creeps.base' +
                        'jstools.screeps_constants' +
                        'math' +
                        'position_management.flags' +
                        'rooms.building' +
                        'rooms.defense' +
                        'rooms.links' +
                        'rooms.minerals' +
                        'rooms.mining' +
                        'rooms.room_constants' +
                        'utilities.movement' +
                        'utilities.positions' +
                        'utilities.speech' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
                        __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
                        __all__.CLAIM_LATER = CLAIM_LATER;
                        __all__.ConstructionMind = ConstructionMind;
                        __all__.DEPOT = DEPOT;
                        __all__.ENERGY_GRAB = ENERGY_GRAB;
                        __all__.INVADER_USERNAME = INVADER_USERNAME;
                        __all__.LOCAL_MINE = LOCAL_MINE;
                        __all__.LinkingMind = LinkingMind;
                        __all__.MineralMind = MineralMind;
                        __all__.MiningMind = MiningMind;
                        __all__.PYFIND_BUILDABLE_ROADS = PYFIND_BUILDABLE_ROADS;
                        __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
                        __all__.PYFIND_REPAIRABLE_ROADS = PYFIND_REPAIRABLE_ROADS;
                        __all__.RAID_OVER = RAID_OVER;
                        __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
                        __all__.RANGED_DEFENSE = RANGED_DEFENSE;
                        __all__.REAP_POWER_BANK = REAP_POWER_BANK;
                        __all__.REMOTE_MINE = REMOTE_MINE;
                        __all__.REROUTE = REROUTE;
                        __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
                        __all__.RESERVE_NOW = RESERVE_NOW;
                        __all__.RoleBase = RoleBase;
                        __all__.RoomDefense = RoomDefense;
                        __all__.RoomMind = RoomMind;
                        __all__.SCOUT = SCOUT;
                        __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
                        __all__.SK_USERNAME = SK_USERNAME;
                        __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
                        __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
                        __all__.TD_D_GOAD = TD_D_GOAD;
                        __all__.TD_H_D_STOP = TD_H_D_STOP;
                        __all__.TD_H_H_STOP = TD_H_H_STOP;
                        __all__.UPGRADER_SPOT = UPGRADER_SPOT;
                        __all__.cache_key_spending_now = cache_key_spending_now;
                        __all__.clamp_room_x_or_y = clamp_room_x_or_y;
                        __all__.consistency = consistency;
                        __all__.creep_base_1500miner = creep_base_1500miner;
                        __all__.creep_base_3000miner = creep_base_3000miner;
                        __all__.creep_base_3h = creep_base_3h;
                        __all__.creep_base_4000miner = creep_base_4000miner;
                        __all__.creep_base_carry3000miner = creep_base_carry3000miner;
                        __all__.creep_base_claim_attack = creep_base_claim_attack;
                        __all__.creep_base_claiming = creep_base_claiming;
                        __all__.creep_base_defender = creep_base_defender;
                        __all__.creep_base_dismantler = creep_base_dismantler;
                        __all__.creep_base_full_move_dismantler = creep_base_full_move_dismantler;
                        __all__.creep_base_full_move_goader = creep_base_full_move_goader;
                        __all__.creep_base_full_move_healer = creep_base_full_move_healer;
                        __all__.creep_base_full_move_power_attack = creep_base_full_move_power_attack;
                        __all__.creep_base_full_upgrader = creep_base_full_upgrader;
                        __all__.creep_base_goader = creep_base_goader;
                        __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
                        __all__.creep_base_half_move_healer = creep_base_half_move_healer;
                        __all__.creep_base_hauler = creep_base_hauler;
                        __all__.creep_base_mammoth_miner = creep_base_mammoth_miner;
                        __all__.creep_base_power_attack = creep_base_power_attack;
                        __all__.creep_base_rampart_defense = creep_base_rampart_defense;
                        __all__.creep_base_ranged_offense = creep_base_ranged_offense;
                        __all__.creep_base_reserving = creep_base_reserving;
                        __all__.creep_base_scout = creep_base_scout;
                        __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
                        __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
                        __all__.creep_base_worker = creep_base_worker;
                        __all__.creep_wrappers = creep_wrappers;
                        __all__.default_roles = default_roles;
                        __all__.energy_balance_point_for_rcl8_building = energy_balance_point_for_rcl8_building;
                        __all__.energy_balance_point_for_rcl8_upgrading = energy_balance_point_for_rcl8_upgrading;
                        __all__.energy_pre_rcl8_scaling_balance_point = energy_pre_rcl8_scaling_balance_point;
                        __all__.energy_to_keep_always_in_reserve = energy_to_keep_always_in_reserve;
                        __all__.energy_to_keep_always_in_reserve_when_supporting_sieged = energy_to_keep_always_in_reserve_when_supporting_sieged;
                        __all__.energy_to_pause_building = energy_to_pause_building;
                        __all__.energy_to_pause_upgrading = energy_to_pause_upgrading;
                        __all__.energy_to_resume_building = energy_to_resume_building;
                        __all__.energy_to_resume_upgrading = energy_to_resume_upgrading;
                        __all__.fit_num_sections = fit_num_sections;
                        __all__.flags = flags;
                        __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
                        __all__.gmem_key_last_room_state_refresh = gmem_key_last_room_state_refresh;
                        __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
                        __all__.max_energy_disable_full_storage_use = max_energy_disable_full_storage_use;
                        __all__.max_energy_resume_remote_mining = max_energy_resume_remote_mining;
                        __all__.max_minerals_to_keep = max_minerals_to_keep;
                        __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
                        __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
                        __all__.max_total_resume_remote_mining = max_total_resume_remote_mining;
                        __all__.mem_key_building_paused = mem_key_building_paused;
                        __all__.mem_key_building_priority_spawn = mem_key_building_priority_spawn;
                        __all__.mem_key_building_priority_walls = mem_key_building_priority_walls;
                        __all__.mem_key_cache = mem_key_cache;
                        __all__.mem_key_carry_parts_by_role = mem_key_carry_parts_by_role;
                        __all__.mem_key_creeps_by_role = mem_key_creeps_by_role;
                        __all__.mem_key_creeps_by_role_and_replacement_time = mem_key_creeps_by_role_and_replacement_time;
                        __all__.mem_key_currently_under_siege = mem_key_currently_under_siege;
                        __all__.mem_key_defense_mind_storage = mem_key_defense_mind_storage;
                        __all__.mem_key_empty_all_resources_into_room = mem_key_empty_all_resources_into_room;
                        __all__.mem_key_flag_for_testing_spawning_in_simulation = mem_key_flag_for_testing_spawning_in_simulation;
                        __all__.mem_key_focusing_home = mem_key_focusing_home;
                        __all__.mem_key_linking_mind_storage = mem_key_linking_mind_storage;
                        __all__.mem_key_metadata = mem_key_metadata;
                        __all__.mem_key_mineral_mind_storage = mem_key_mineral_mind_storage;
                        __all__.mem_key_now_supporting = mem_key_now_supporting;
                        __all__.mem_key_pause_all_room_operations = mem_key_pause_all_room_operations;
                        __all__.mem_key_planned_role_to_spawn = mem_key_planned_role_to_spawn;
                        __all__.mem_key_prepping_defenses = mem_key_prepping_defenses;
                        __all__.mem_key_remotes_explicitly_marked_under_attack = mem_key_remotes_explicitly_marked_under_attack;
                        __all__.mem_key_remotes_safe_when_under_siege = mem_key_remotes_safe_when_under_siege;
                        __all__.mem_key_room_reserved_up_until_tick = mem_key_room_reserved_up_until_tick;
                        __all__.mem_key_spawn_requests = mem_key_spawn_requests;
                        __all__.mem_key_sponsor = mem_key_sponsor;
                        __all__.mem_key_storage_use_enabled = mem_key_storage_use_enabled;
                        __all__.mem_key_stored_hostiles = mem_key_stored_hostiles;
                        __all__.mem_key_there_might_be_energy_lying_around = mem_key_there_might_be_energy_lying_around;
                        __all__.mem_key_total_open_source_spaces = mem_key_total_open_source_spaces;
                        __all__.mem_key_upgrading_paused = mem_key_upgrading_paused;
                        __all__.mem_key_work_parts_by_role = mem_key_work_parts_by_role;
                        __all__.min_energy_enable_full_storage_use = min_energy_enable_full_storage_use;
                        __all__.min_energy_pause_remote_mining = min_energy_pause_remote_mining;
                        __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
                        __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
                        __all__.min_stored_energy_to_draw_from_before_refilling = min_stored_energy_to_draw_from_before_refilling;
                        __all__.min_total_pause_remote_mining = min_total_pause_remote_mining;
                        __all__.min_work_mass_per_source_for_full_storage_use = min_work_mass_per_source_for_full_storage_use;
                        __all__.movement = movement;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.old_role_names = old_role_names;
                        __all__.parse_xy_arguments = parse_xy_arguments;
                        __all__.rcl8_energy_to_pause_upgrading = rcl8_energy_to_pause_upgrading;
                        __all__.rcl8_energy_to_resume_upgrading = rcl8_energy_to_resume_upgrading;
                        __all__.rcl_to_max_wall_hits = rcl_to_max_wall_hits;
                        __all__.rcl_to_target_wall_hits = rcl_to_target_wall_hits;
                        __all__.recycle_time = recycle_time;
                        __all__.request_priority_economy = request_priority_economy;
                        __all__.request_priority_helping_party = request_priority_helping_party;
                        __all__.request_priority_imminent_threat_defense = request_priority_imminent_threat_defense;
                        __all__.request_priority_low = request_priority_low;
                        __all__.rmem_key_building_paused = rmem_key_building_paused;
                        __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
                        __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
                        __all__.rmem_key_cache = rmem_key_cache;
                        __all__.rmem_key_carry_parts_by_role = rmem_key_carry_parts_by_role;
                        __all__.rmem_key_creeps_by_role = rmem_key_creeps_by_role;
                        __all__.rmem_key_creeps_by_role_and_replacement_time = rmem_key_creeps_by_role_and_replacement_time;
                        __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
                        __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
                        __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
                        __all__.rmem_key_flag_for_testing_spawning_in_simulation = rmem_key_flag_for_testing_spawning_in_simulation;
                        __all__.rmem_key_focusing_home = rmem_key_focusing_home;
                        __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
                        __all__.rmem_key_metadata = rmem_key_metadata;
                        __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
                        __all__.rmem_key_now_supporting = rmem_key_now_supporting;
                        __all__.rmem_key_pause_all_room_operations = rmem_key_pause_all_room_operations;
                        __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
                        __all__.rmem_key_prepping_defenses = rmem_key_prepping_defenses;
                        __all__.rmem_key_remotes_explicitly_marked_under_attack = rmem_key_remotes_explicitly_marked_under_attack;
                        __all__.rmem_key_remotes_safe_when_under_siege = rmem_key_remotes_safe_when_under_siege;
                        __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
                        __all__.rmem_key_spawn_requests = rmem_key_spawn_requests;
                        __all__.rmem_key_sponsor = rmem_key_sponsor;
                        __all__.rmem_key_storage_use_enabled = rmem_key_storage_use_enabled;
                        __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
                        __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
                        __all__.rmem_key_total_open_source_spaces = rmem_key_total_open_source_spaces;
                        __all__.rmem_key_upgrading_paused = rmem_key_upgrading_paused;
                        __all__.rmem_key_work_parts_by_role = rmem_key_work_parts_by_role;
                        __all__.role_bases = role_bases;
                        __all__.role_builder = role_builder;
                        __all__.role_cleanup = role_cleanup;
                        __all__.role_colonist = role_colonist;
                        __all__.role_defender = role_defender;
                        __all__.role_energy_grab = role_energy_grab;
                        __all__.role_hauler = role_hauler;
                        __all__.role_link_manager = role_link_manager;
                        __all__.role_miner = role_miner;
                        __all__.role_mineral_hauler = role_mineral_hauler;
                        __all__.role_mineral_miner = role_mineral_miner;
                        __all__.role_mineral_steal = role_mineral_steal;
                        __all__.role_power_attack = role_power_attack;
                        __all__.role_power_cleanup = role_power_cleanup;
                        __all__.role_ranged_offense = role_ranged_offense;
                        __all__.role_recycling = role_recycling;
                        __all__.role_remote_mining_reserve = role_remote_mining_reserve;
                        __all__.role_room_reserve = role_room_reserve;
                        __all__.role_scout = role_scout;
                        __all__.role_simple_claim = role_simple_claim;
                        __all__.role_simple_dismantle = role_simple_dismantle;
                        __all__.role_spawn_fill = role_spawn_fill;
                        __all__.role_spawn_fill_backup = role_spawn_fill_backup;
                        __all__.role_td_goad = role_td_goad;
                        __all__.role_td_healer = role_td_healer;
                        __all__.role_temporary_replacing = role_temporary_replacing;
                        __all__.role_tower_fill = role_tower_fill;
                        __all__.role_tower_fill_once = role_tower_fill_once;
                        __all__.role_upgrade_fill = role_upgrade_fill;
                        __all__.role_upgrader = role_upgrader;
                        __all__.role_wall_defender = role_wall_defender;
                        __all__.room_spending_state_building = room_spending_state_building;
                        __all__.room_spending_state_rcl8_building = room_spending_state_rcl8_building;
                        __all__.room_spending_state_saving = room_spending_state_saving;
                        __all__.room_spending_state_selling = room_spending_state_selling;
                        __all__.room_spending_state_supporting = room_spending_state_supporting;
                        __all__.room_spending_state_supporting_sieged = room_spending_state_supporting_sieged;
                        __all__.room_spending_state_under_siege = room_spending_state_under_siege;
                        __all__.room_spending_state_upgrading = room_spending_state_upgrading;
                        __all__.room_spending_state_visual = room_spending_state_visual;
                        __all__.spawning = spawning;
                        __all__.speech = speech;
                        __all__.target_big_big_repair = target_big_big_repair;
                        __all__.target_big_repair = target_big_repair;
                        __all__.target_closest_energy_site = target_closest_energy_site;
                        __all__.target_construction = target_construction;
                        __all__.target_destruction_site = target_destruction_site;
                        __all__.target_energy_hauler_mine = target_energy_hauler_mine;
                        __all__.target_energy_miner_mine = target_energy_miner_mine;
                        __all__.target_home_flag = target_home_flag;
                        __all__.target_rampart_defense = target_rampart_defense;
                        __all__.target_refill = target_refill;
                        __all__.target_repair = target_repair;
                        __all__.target_reserve_now = target_reserve_now;
                        __all__.target_single_flag = target_single_flag;
                        __all__.target_single_flag2 = target_single_flag2;
                        __all__.target_source = target_source;
                        __all__.target_spawn_deposit = target_spawn_deposit;
                        __all__.target_tower_fill = target_tower_fill;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'utilities.hostile_utils', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var is_offensive = function (creep) {
                        return !(!(_.find (creep.body, (function __lambda__ (p) {
                            return p.type == ATTACK || p.type == RANGED_ATTACK;
                        }))));
                    };
                    var not_sk = function (creep) {
                        return creep.owner.username != 'Source Keeper';
                    };
                    var enemy_room = function (name) {
                        return ('enemy_rooms' in Memory) && Memory.enemy_rooms.indexOf (name) != -(1);
                    };
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.enemy_room = enemy_room;
                        __all__.is_offensive = is_offensive;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.not_sk = not_sk;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'utilities.movement', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var math = {};
                    __nest__ (math, '', __init__ (__world__.math));
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var positions = __init__ (__world__.utilities.positions);
                    var room_regex = new RegExp ('(W|E)([0-9]{1,2})(N|S)([0-9]{1,2})');
                    var squared_distance = function (xy1, xy2) {
                        var x_diff = xy1 [0] - xy2 [0];
                        var y_diff = xy1 [1] - xy2 [1];
                        return x_diff * x_diff + y_diff * y_diff;
                    };
                    var parse_room_to_xy = function (room_name) {
                        var matches = room_regex.exec (room_name);
                        if (!(matches)) {
                            return [0, 0];
                        }
                        if (matches [1] == 'W') {
                            var x = -(int (matches [2])) - 1;
                        }
                        else {
                            var x = +(int (matches [2]));
                        }
                        if (matches [3] == 'N') {
                            var y = -(int (matches [4])) - 1;
                        }
                        else {
                            var y = +(int (matches [4]));
                        }
                        return [x, y];
                    };
                    var is_valid_room_name = function (room_name) {
                        var matches = room_regex.exec (room_name);
                        return !(!(matches));
                    };
                    var room_xy_to_name = function (room_x, room_y) {
                        return '{}{}{}{}'.format ((room_x > 0 ? 'E' : 'W'), (room_x < 0 ? -(room_x) - 1 : room_x), (room_y > 0 ? 'S' : 'N'), (room_y < 0 ? -(room_y) - 1 : room_y));
                    };
                    var center_pos = function (room_name) {
                        return new RoomPosition (25, 25, room_name);
                    };
                    var find_an_open_space = function (room_name) {
                        var x = 0;
                        var y = 0;
                        var dx = 0;
                        var dy = -(1);
                        for (var _ = 0; _ < 50 * 50; _++) {
                            if (Game.map.getTerrainAt (24 + x, 24 + y, room_name) != 'wall') {
                                return new RoomPosition (24 + x, 24 + y, room_name);
                            }
                            if (x == y || x < 0 && x == -(y) || x > 0 && x == -(y) + 1) {
                                var __left0__ = [-(dy), dx];
                                var dx = __left0__ [0];
                                var dy = __left0__ [1];
                            }
                            x += dx;
                            y += dy;
                        }
                        print ('[movement] WARNING: Could not find open space in {}'.format (room_name));
                        return new RoomPosition (25, 25, room_name);
                    };
                    var find_clear_inbetween_spaces = function (room, pos1, pos2) {
                        if (pos1.pos) {
                            var pos1 = pos1.pos;
                        }
                        if (pos2.pos) {
                            var pos2 = pos2.pos;
                        }
                        var distance = chebyshev_distance_room_pos (pos1, pos2);
                        var result = [];
                        if (distance > 2 || pos1.roomName != pos2.roomName) {
                            return result;
                        }
                        for (var x = pos1.x - 1; x < pos1.x + 2; x++) {
                            for (var y = pos1.y - 1; y < pos1.y + 2; y++) {
                                var xdiff = abs (x - pos2.x);
                                var ydiff = abs (y - pos2.y);
                                if (xdiff < 2 && ydiff < 2) {
                                    if (is_block_empty (room, x, y)) {
                                        result.push (positions.serialize_xy (x, y));
                                    }
                                }
                            }
                        }
                        return result;
                    };
                    var room_pos_of_closest_serialized = function (here_pos, list_of_serialized) {
                        if (here_pos.pos) {
                            var here_pos = here_pos.pos;
                        }
                        var length = len (list_of_serialized);
                        var room_name = here_pos.roomName;
                        if (length == 1) {
                            return positions.deserialize_xy_to_pos (list_of_serialized [0], room_name);
                        }
                        var here_x = here_pos.x;
                        var here_y = here_pos.y;
                        var closest = null;
                        var closest_length = Infinity;
                        var __iterable0__ = list_of_serialized;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var xy = __iterable0__ [__index0__];
                            var __left0__ = positions.deserialize_xy (xy);
                            var x = __left0__ [0];
                            var y = __left0__ [1];
                            var distance = max (abs (here_x - x), abs (here_y - y));
                            if (distance < closest_length) {
                                var closest_length = distance;
                                var closest = xy;
                            }
                        }
                        return positions.deserialize_xy_to_pos (closest, room_name);
                    };
                    var distance_squared_room_pos = function (room_position_1, room_position_2) {
                        if (room_position_1.pos) {
                            var room_position_1 = room_position_1.pos;
                        }
                        if (room_position_2.pos) {
                            var room_position_2 = room_position_2.pos;
                        }
                        if (room_position_1.roomName == room_position_2.roomName) {
                            return squared_distance ([room_position_1.x, room_position_1.y], [room_position_2.x, room_position_2.y]);
                        }
                        var room_1_pos = parse_room_to_xy (room_position_1.roomName);
                        var room_2_pos = parse_room_to_xy (room_position_2.roomName);
                        var full_pos_1 = [room_1_pos [0] * 50 + room_position_1.x, room_1_pos [1] * 50 + room_position_1.y];
                        var full_pos_2 = [room_2_pos [0] * 50 + room_position_2.x, room_2_pos [1] * 50 + room_position_2.y];
                        return squared_distance (full_pos_1, full_pos_2);
                    };
                    var chebyshev_distance_room_pos = function (pos1, pos2) {
                        if (pos1.pos) {
                            var pos1 = pos1.pos;
                        }
                        if (pos2.pos) {
                            var pos2 = pos2.pos;
                        }
                        if (pos1.roomName == pos2.roomName) {
                            return max (abs (pos1.x - pos2.x), abs (pos1.y - pos2.y));
                        }
                        var room_1_pos = parse_room_to_xy (pos1.roomName);
                        var room_2_pos = parse_room_to_xy (pos2.roomName);
                        var world_pos_1 = [room_1_pos [0] * 49 + pos1.x, room_1_pos [1] * 49 + pos1.y];
                        var world_pos_2 = [room_2_pos [0] * 49 + pos2.x, room_2_pos [1] * 49 + pos2.y];
                        return max (abs (world_pos_1 [0] - world_pos_2 [0]), abs (world_pos_1 [1] - world_pos_2 [1]));
                    };
                    var chebyshev_distance_xy = function (x1, y1, x2, y2) {
                        return max (abs (x1 - x2), abs (y1 - y2));
                    };
                    var minimum_chebyshev_distance = function (comparison_pos, targets) {
                        var min_distance = Infinity;
                        var __iterable0__ = targets;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var target = __iterable0__ [__index0__];
                            var distance = chebyshev_distance_room_pos (comparison_pos, target);
                            if (distance < min_distance) {
                                var min_distance = distance;
                            }
                        }
                        if (min_distance === Infinity) {
                            return 0;
                        }
                        else {
                            return min_distance;
                        }
                    };
                    var distance_room_pos = function (room_pos_1, room_pos_2) {
                        return math.sqrt (distance_squared_room_pos (room_pos_1, room_pos_2));
                    };
                    var is_block_clear = function (room, x, y) {
                        if (x > 49 || y > 49 || x < 0 || y < 0) {
                            return false;
                        }
                        if (Game.map.getTerrainAt (x, y, room.room.name) == 'wall') {
                            return false;
                        }
                        if (len (room.look_at (LOOK_CREEPS, x, y)) != 0) {
                            return false;
                        }
                        var __iterable0__ = room.look_at (LOOK_STRUCTURES, x, y);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var struct = __iterable0__ [__index0__];
                            if ((struct.structureType != STRUCTURE_RAMPART || !(struct.my)) && struct.structureType != STRUCTURE_CONTAINER && struct.structureType != STRUCTURE_ROAD) {
                                return false;
                            }
                        }
                        var __iterable0__ = room.look_at (LOOK_CONSTRUCTION_SITES, x, y);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var site = __iterable0__ [__index0__];
                            if (site.my && site.structureType != STRUCTURE_RAMPART && site.structureType != STRUCTURE_CONTAINER && site.structureType != STRUCTURE_ROAD) {
                                return false;
                            }
                        }
                        return true;
                    };
                    var is_block_empty = function (room, x, y) {
                        if (x > 49 || y > 49 || x < 0 || y < 0) {
                            return false;
                        }
                        if (Game.map.getTerrainAt (x, y, room.room.name) == 'wall') {
                            return false;
                        }
                        var __iterable0__ = room.look_at (LOOK_STRUCTURES, x, y);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var struct = __iterable0__ [__index0__];
                            if ((struct.structureType != STRUCTURE_RAMPART || !(struct.my)) && struct.structureType != STRUCTURE_CONTAINER && struct.structureType != STRUCTURE_ROAD) {
                                return false;
                            }
                        }
                        var __iterable0__ = room.look_at (LOOK_CONSTRUCTION_SITES, x, y);
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var site = __iterable0__ [__index0__];
                            if (site.my && site.structureType != STRUCTURE_RAMPART && site.structureType != STRUCTURE_CONTAINER && site.structureType != STRUCTURE_ROAD) {
                                return false;
                            }
                        }
                        return true;
                    };
                    var get_entrance_for_exit_pos = function (exit_pos) {
                        if (exit_pos.pos) {
                            var exit_pos = exit_pos.pos;
                        }
                        var room_xy = parse_room_to_xy (exit_pos.roomName);
                        return get_entrance_for_exit_pos_with_room (exit_pos, room_xy);
                    };
                    var get_entrance_for_exit_pos_with_room = function (exit_pos, current_room_xy) {
                        if (exit_pos.pos) {
                            var exit_pos = exit_pos.pos;
                        }
                        var entrance_pos = new RoomPosition (exit_pos.x, exit_pos.y, exit_pos.roomName);
                        var __left0__ = current_room_xy;
                        var room_x = __left0__ [0];
                        var room_y = __left0__ [1];
                        if (exit_pos.y == 0) {
                            entrance_pos.y = 49;
                            room_y--;
                        }
                        else if (exit_pos.y == 49) {
                            entrance_pos.y = 0;
                            room_y++;
                        }
                        else if (exit_pos.x == 0) {
                            entrance_pos.x = 49;
                            room_x--;
                        }
                        else if (exit_pos.x == 49) {
                            entrance_pos.x = 0;
                            room_x++;
                        }
                        else {
                            print ('[movement][get_entrance_for_exit_pos] Exit position given ({}) is not an exit position.'.format (JSON.stringify (exit_pos)));
                            return -(1);
                        }
                        entrance_pos.roomName = room_xy_to_name (room_x, room_y);
                        return entrance_pos;
                    };
                    var dxdy_to_direction = function (dx, dy) {
                        var direction = null;
                        if (dx < 0) {
                            if (dy < 0) {
                                var direction = TOP_LEFT;
                            }
                            else if (dy == 0) {
                                var direction = LEFT;
                            }
                            else if (dy > 0) {
                                var direction = BOTTOM_LEFT;
                            }
                        }
                        else if (dx == 0) {
                            if (dy < 0) {
                                var direction = TOP;
                            }
                            else if (dy > 0) {
                                var direction = BOTTOM;
                            }
                        }
                        else if (dx > 0) {
                            if (dy < 0) {
                                var direction = TOP_RIGHT;
                            }
                            else if (dy == 0) {
                                var direction = RIGHT;
                            }
                            else if (dy > 0) {
                                var direction = BOTTOM_RIGHT;
                            }
                        }
                        if (direction === null) {
                            print ('[honey][direction] ERROR: Unknown dx/dy: {},{}!'.format (dx, dy));
                            return null;
                        }
                        else {
                            return direction;
                        }
                    };
                    var diff_as_direction = function (origin, destination) {
                        if (origin.pos !== undefined) {
                            var origin = origin.pos;
                        }
                        if (destination.pos !== undefined) {
                            var destination = destination.pos;
                        }
                        var direction = dxdy_to_direction (destination.x - origin.x, destination.y - origin.y);
                        if (direction === null) {
                            print ('[movement][direction_to] No direction found for get_direction({} - {}, {} - {}).'.format (destination.x, origin.x, destination.y, origin.y));
                        }
                        return direction;
                    };
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                        'math' +
                        'utilities.positions' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.center_pos = center_pos;
                        __all__.chebyshev_distance_room_pos = chebyshev_distance_room_pos;
                        __all__.chebyshev_distance_xy = chebyshev_distance_xy;
                        __all__.diff_as_direction = diff_as_direction;
                        __all__.distance_room_pos = distance_room_pos;
                        __all__.distance_squared_room_pos = distance_squared_room_pos;
                        __all__.dxdy_to_direction = dxdy_to_direction;
                        __all__.find_an_open_space = find_an_open_space;
                        __all__.find_clear_inbetween_spaces = find_clear_inbetween_spaces;
                        __all__.get_entrance_for_exit_pos = get_entrance_for_exit_pos;
                        __all__.get_entrance_for_exit_pos_with_room = get_entrance_for_exit_pos_with_room;
                        __all__.is_block_clear = is_block_clear;
                        __all__.is_block_empty = is_block_empty;
                        __all__.is_valid_room_name = is_valid_room_name;
                        __all__.minimum_chebyshev_distance = minimum_chebyshev_distance;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.parse_room_to_xy = parse_room_to_xy;
                        __all__.positions = positions;
                        __all__.room_pos_of_closest_serialized = room_pos_of_closest_serialized;
                        __all__.room_regex = room_regex;
                        __all__.room_xy_to_name = room_xy_to_name;
                        __all__.squared_distance = squared_distance;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'utilities.naming', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var random_digits = function () {
                        return Math.floor ((1 + Math.random ()) * 65536).toString (16).substring (1);
                    };
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.random_digits = random_digits;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'utilities.positions', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var parse_xy_arguments = function (pos, optional_y) {
                        if (optional_y !== null && optional_y !== undefined) {
                            return [pos, optional_y, null];
                        }
                        else if (pos.pos) {
                            return [pos.pos.x, pos.pos.y, pos.pos.roomName];
                        }
                        else {
                            return [pos.x, pos.y, pos.roomName];
                        }
                    };
                    var clamp_room_x_or_y = function (coord) {
                        return (coord > 0 ? (coord < 49 ? coord : 49) : 0);
                    };
                    var serialize_xy = function (x, y) {
                        return x | y << 6;
                    };
                    var serialize_pos_xy = function (pos) {
                        var pos = pos.pos || pos;
                        return pos.x | pos.y << 6;
                    };
                    var deserialize_xy = function (xy) {
                        return [xy & 63, xy >> 6 & 63];
                    };
                    var deserialize_xy_to_pos = function (xy, room_name) {
                        return new RoomPosition (xy & 63, xy >> 6 & 63, room_name);
                    };
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.clamp_room_x_or_y = clamp_room_x_or_y;
                        __all__.deserialize_xy = deserialize_xy;
                        __all__.deserialize_xy_to_pos = deserialize_xy_to_pos;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.parse_xy_arguments = parse_xy_arguments;
                        __all__.serialize_pos_xy = serialize_pos_xy;
                        __all__.serialize_xy = serialize_xy;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    __nest__ (
        __all__,
        'utilities.speech', {
            __all__: {
                __inited__: false,
                __init__: function (__all__) {
                    var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
                    var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
                    var translate_lyrics = function (input_str) {
                        var result = [];
                        var next_lyric = [];
                        var __iterable0__ = input_str;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var char = __iterable0__ [__index0__];
                            if (char === '\n' || char === ' ') {
                                if (len (next_lyric)) {
                                    result.push (''.join (next_lyric));
                                    var next_lyric = [];
                                }
                                if (char === '\n') {
                                    result.push (null);
                                }
                            }
                            else {
                                next_lyric.push (char);
                            }
                        }
                        if (len (next_lyric)) {
                            result.push (''.join (next_lyric));
                        }
                        return result;
                    };
                    var we_are_miners = translate_lyrics ("\nWe are miners, hard rock miners\nTo the shaft house we must go\nPour your bottles on our shoulders\nWe are marching to the slow\n\nOn the line boys, on the line boys\nDrill your holes and stand in line\n'til the shift boss comes to tell you\nYou must drill her out on top\n\nCan't you feel the rock dust in your lungs?\nIt'll cut down a miner when he is still young\nTwo years and the silicosis takes hold\nand I feel like I'm dying from mining for gold\n\nYes, I feel like I'm dying from mining for gold\n");
                    var wolf = translate_lyrics ("\nThe modern wolf\nHe's kinder\nBut see him weep\nIt's a reminder\nDon't wear no suits\nWe're talking t-shirts\nSee how he glides\nMakes women shiver\n\nAhoooooo, Ahoooooo\n\nHe ain't no Jack\nHis voice is smoother\nBeen bending notes\nJust like his father\nAhooo but no birds or beasts does he eat\nHe only wants the tenderest meat\nAnd oh the sounds he makes them speak\nUnder all different patterns of sheets\nColors blind\nOh, dopamine\nAnd she looked so good when they were last seen\n\nAhoooooo, Ahoooooo\n\nThe modern wolf, the modern wolf\nDripping in all the lives that he took\nHe'll go on home\nTry to wash them off\nBut when he shaves he hears them call\n\nAhoooooo, Ahoooooo\n");
                    var h_s_t_k = translate_lyrics ("\nI've got a television it's filling with home\nI've got a television it's filling with home\nWherever I end up wherever I roam\nHey I've got a television it's filling with home\nI've got a phone that beeps, let's me know I'm not alone\nI've got a phone that beeps, let's me know I'm not alone\nWherever I end up I sleep like a stone, yeah\nI've got a phone that beeps, let's me know I'm not alone\n\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nThey're running everywhere in fancy clothes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nThey take me to where I want to go\n\nBright\nOh, young\nKinda hurt\nDon't you wanna get some\nEsso\nBright\nYoung\nHurt\nDon't you wanna get some\n\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nThey're running everywhere in fancy clothes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nThey take me to where I need to go\n\nAll around the party, we stand in circles numb\nYeah, all around the party, we stand in circles numb\nOh, who can I find here, who knows where I come from\nAll around the party we stand in circles numb\nI had a thread before now I don't know where it's gone\nI had a thread before now I don't know where it's gone\nOh, how did I get here did it say when I was young\nI had a thread before now I don't know where it's gone\n\nI've got a television it's filling with home\nI've got a television it's filling with home\nWherever I end up wherever I roam\nHey I've got a television it's filling with home\n\nBright\nOh, young\nKinda hurt\nDon't you wanna get some\nEsso\nBright\nYoung\nHurt\nDon't you wanna get some,\n\nWanna get, wanna get, wanna get...\n\nSome, some, some, some\n\nWanna get, wanna get, wanna get...\n\nSome, some, some, some\n\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nThey're running everywhere in fancy clothes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nThey take me to where I need to go\n\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nThey're running everywhere in fancy clothes\nMy head my shoulders knees and toes\nMy head my shoulders knees and toes\nHead my shoulders knees and toes\nThey take me to where I need to go\n");
                    var breeze_blocks = translate_lyrics ("\nShe may contain the urge to run away\nBut hold her down with soggy clothes and breezeblocks\nCetirizine your fever's gripped me again\nNever kisses -all you ever send are full stops, la, la, la\n\nDo you know where the wild things go?\nThey go along to take your honey, la, la, la\nBreak down, now weep,\nBuild up breakfast, now let's eat\nMy love, my love, love, love, la, la, la\n\nMuscle to muscle and toe to toe\nThe fear has gripped me but here I go\nMy heart sinks as I jump up\nYour hand grips hand as my eyes shut\n\nDo you know where the wild things go?\nThey go along to take your honey, la, la, la\nBreak down, now sleep\nBuild up breakfast, now let's eat\nMy love my love, love, love\n\nShe bruises, coughs, she splutters pistol shots\nHold her down with soggy clothes and breezeblocks\nShe's morphine, queen of my vaccine\nMy love, my love, love, love, la, la, la\n\nMuscle to muscle and toe to toe\nThe fear has gripped me but here I go\nMy heart sinks as I jump up\nYour hand grips hand as my eyes shut\n\nShe may contain the urge to run away\nBut hold her down with soggy clothes and breezeblocks\nGermolene, disinfect the scene\nMy love, my love, love, love\nBut please don't go, I love you so, my lovely\n\nPlease don't go, please don't go\nI love you so, I love you so\nPlease don't go, please don't go\nI love you so, I love you so\nPlease break my heart, hey\n\nPlease don't go, please don't go\nI love you so, I love you so\nPlease don't go, please don't go\nI love you so, I love you so\nPlease break my heart\n\nPlease don't go, I'll eat you whole\nI love you so, I love you so, I love you so\nPlease don't go I'll eat you whole\nI love you so, I love you so, I love you so, I love you so\n\nI'll eat you whole\nI love you so, I love you so\nI'll eat you whole\nI love you so, I love you so\n\nI'll eat you whole\nI love you so, I love you so\nPlease don't go, I'll eat you whole\nI love you so, I love you so, I love you so\nPlease don't go, I'll eat you whole\nI love you so, I love you so, I love you so\n");
                    var tessellate = translate_lyrics ("\nBite chunks out of me\nYou're a shark and I'm swimming\nMy heart still thumps as I bleed\nAnd all your friends come sniffing\n\nTriangles are my favorite shape\nThree points where two lines meet\nToe to toe, back to back, let's go, my love; it's very late\n'Til morning comes, let's tessellate\n\nGo alone my flower\nAnd keep my whole lovely you\nWild green stones alone my lover\nAnd keep us on my heart\n\nThree guns and one goes off\nOne's empty, one's not quick enough\nOne burn, one red, one grin\nSearch the graves while the camera spins\n\nChunks of you will sink down to seals\nBlubber rich in mourning, they'll nosh you up\nYes, they'll nosh the love away but it's fair to say\nYou will still haunt me\n\nTriangles are my favorite shape\nThree points where two lines meet\nToe to toe, back to back, let's go my love; it's very late\n'Til morning comes, let's tessellate\n");
                    var songs = {'a': breeze_blocks, 'm': we_are_miners, 'w': wolf, 'h': h_s_t_k, 't': tessellate};
                    __pragma__ ('<use>' +
                        'jstools.screeps_constants' +
                    '</use>')
                    __pragma__ ('<all>')
                        __all__.breeze_blocks = breeze_blocks;
                        __all__.h_s_t_k = h_s_t_k;
                        __all__.new_map = new_map;
                        __all__.new_set = new_set;
                        __all__.songs = songs;
                        __all__.tessellate = tessellate;
                        __all__.translate_lyrics = translate_lyrics;
                        __all__.we_are_miners = we_are_miners;
                        __all__.wolf = wolf;
                    __pragma__ ('</all>')
                }
            }
        }
    );
    (function () {
        var constants = {};
        var math = {};
        var _memory_init = null;
        var init_memory = function () {
            var start = Game.cpu.getUsed ();
            var x = Memory;
            var end = Game.cpu.getUsed ();
            _memory_init = end - start;
        };
        init_memory ();
        var _start_of_compile = Game.cpu.getUsed ();

        if (!global.__customizations_active) {
            require("customizations");
        }
        __nest__ (math, '', __init__ (__world__.math));
        __nest__ (constants, '', __init__ (__world__.constants));
        var consistency = __init__ (__world__.cache.consistency);
        var context = __init__ (__world__.cache.context);
        var global_cache = __init__ (__world__.cache.global_cache);
        var volatile_cache = __init__ (__world__.cache.volatile_cache);
        var ATTACK_DISMANTLE = __init__ (__world__.constants).ATTACK_DISMANTLE;
        var ATTACK_POWER_BANK = __init__ (__world__.constants).ATTACK_POWER_BANK;
        var CLAIM_LATER = __init__ (__world__.constants).CLAIM_LATER;
        var DEPOT = __init__ (__world__.constants).DEPOT;
        var ENERGY_GRAB = __init__ (__world__.constants).ENERGY_GRAB;
        var INVADER_USERNAME = __init__ (__world__.constants).INVADER_USERNAME;
        var LOCAL_MINE = __init__ (__world__.constants).LOCAL_MINE;
        var PYFIND_BUILDABLE_ROADS = __init__ (__world__.constants).PYFIND_BUILDABLE_ROADS;
        var PYFIND_HURT_CREEPS = __init__ (__world__.constants).PYFIND_HURT_CREEPS;
        var PYFIND_REPAIRABLE_ROADS = __init__ (__world__.constants).PYFIND_REPAIRABLE_ROADS;
        var RAID_OVER = __init__ (__world__.constants).RAID_OVER;
        var RAMPART_DEFENSE = __init__ (__world__.constants).RAMPART_DEFENSE;
        var RANGED_DEFENSE = __init__ (__world__.constants).RANGED_DEFENSE;
        var REAP_POWER_BANK = __init__ (__world__.constants).REAP_POWER_BANK;
        var REMOTE_MINE = __init__ (__world__.constants).REMOTE_MINE;
        var REROUTE = __init__ (__world__.constants).REROUTE;
        var REROUTE_DESTINATION = __init__ (__world__.constants).REROUTE_DESTINATION;
        var RESERVE_NOW = __init__ (__world__.constants).RESERVE_NOW;
        var SCOUT = __init__ (__world__.constants).SCOUT;
        var SK_LAIR_SOURCE_NOTED = __init__ (__world__.constants).SK_LAIR_SOURCE_NOTED;
        var SK_USERNAME = __init__ (__world__.constants).SK_USERNAME;
        var SLIGHTLY_AVOID = __init__ (__world__.constants).SLIGHTLY_AVOID;
        var SPAWN_FILL_WAIT = __init__ (__world__.constants).SPAWN_FILL_WAIT;
        var TD_D_GOAD = __init__ (__world__.constants).TD_D_GOAD;
        var TD_H_D_STOP = __init__ (__world__.constants).TD_H_D_STOP;
        var TD_H_H_STOP = __init__ (__world__.constants).TD_H_H_STOP;
        var UPGRADER_SPOT = __init__ (__world__.constants).UPGRADER_SPOT;
        var creep_base_1500miner = __init__ (__world__.constants).creep_base_1500miner;
        var creep_base_3000miner = __init__ (__world__.constants).creep_base_3000miner;
        var creep_base_3h = __init__ (__world__.constants).creep_base_3h;
        var creep_base_4000miner = __init__ (__world__.constants).creep_base_4000miner;
        var creep_base_carry3000miner = __init__ (__world__.constants).creep_base_carry3000miner;
        var creep_base_claim_attack = __init__ (__world__.constants).creep_base_claim_attack;
        var creep_base_claiming = __init__ (__world__.constants).creep_base_claiming;
        var creep_base_defender = __init__ (__world__.constants).creep_base_defender;
        var creep_base_dismantler = __init__ (__world__.constants).creep_base_dismantler;
        var creep_base_full_move_dismantler = __init__ (__world__.constants).creep_base_full_move_dismantler;
        var creep_base_full_move_goader = __init__ (__world__.constants).creep_base_full_move_goader;
        var creep_base_full_move_healer = __init__ (__world__.constants).creep_base_full_move_healer;
        var creep_base_full_move_power_attack = __init__ (__world__.constants).creep_base_full_move_power_attack;
        var creep_base_full_upgrader = __init__ (__world__.constants).creep_base_full_upgrader;
        var creep_base_goader = __init__ (__world__.constants).creep_base_goader;
        var creep_base_half_move_hauler = __init__ (__world__.constants).creep_base_half_move_hauler;
        var creep_base_half_move_healer = __init__ (__world__.constants).creep_base_half_move_healer;
        var creep_base_hauler = __init__ (__world__.constants).creep_base_hauler;
        var creep_base_mammoth_miner = __init__ (__world__.constants).creep_base_mammoth_miner;
        var creep_base_power_attack = __init__ (__world__.constants).creep_base_power_attack;
        var creep_base_rampart_defense = __init__ (__world__.constants).creep_base_rampart_defense;
        var creep_base_ranged_offense = __init__ (__world__.constants).creep_base_ranged_offense;
        var creep_base_reserving = __init__ (__world__.constants).creep_base_reserving;
        var creep_base_scout = __init__ (__world__.constants).creep_base_scout;
        var creep_base_work_full_move_hauler = __init__ (__world__.constants).creep_base_work_full_move_hauler;
        var creep_base_work_half_move_hauler = __init__ (__world__.constants).creep_base_work_half_move_hauler;
        var creep_base_worker = __init__ (__world__.constants).creep_base_worker;
        var default_roles = __init__ (__world__.constants).default_roles;
        var global_cache_mining_roads_suffix = __init__ (__world__.constants).global_cache_mining_roads_suffix;
        var gmem_key_last_room_state_refresh = __init__ (__world__.constants).gmem_key_last_room_state_refresh;
        var gmem_key_room_mining_paths = __init__ (__world__.constants).gmem_key_room_mining_paths;
        var max_repath_mine_roads_every = __init__ (__world__.constants).max_repath_mine_roads_every;
        var max_repave_mine_roads_every = __init__ (__world__.constants).max_repave_mine_roads_every;
        var min_repath_mine_roads_every = __init__ (__world__.constants).min_repath_mine_roads_every;
        var min_repave_mine_roads_every = __init__ (__world__.constants).min_repave_mine_roads_every;
        var old_role_names = __init__ (__world__.constants).old_role_names;
        var recycle_time = __init__ (__world__.constants).recycle_time;
        var request_priority_economy = __init__ (__world__.constants).request_priority_economy;
        var request_priority_helping_party = __init__ (__world__.constants).request_priority_helping_party;
        var request_priority_imminent_threat_defense = __init__ (__world__.constants).request_priority_imminent_threat_defense;
        var request_priority_low = __init__ (__world__.constants).request_priority_low;
        var rmem_key_building_paused = __init__ (__world__.constants).rmem_key_building_paused;
        var rmem_key_building_priority_spawn = __init__ (__world__.constants).rmem_key_building_priority_spawn;
        var rmem_key_building_priority_walls = __init__ (__world__.constants).rmem_key_building_priority_walls;
        var rmem_key_cache = __init__ (__world__.constants).rmem_key_cache;
        var rmem_key_carry_parts_by_role = __init__ (__world__.constants).rmem_key_carry_parts_by_role;
        var rmem_key_creeps_by_role = __init__ (__world__.constants).rmem_key_creeps_by_role;
        var rmem_key_creeps_by_role_and_replacement_time = __init__ (__world__.constants).rmem_key_creeps_by_role_and_replacement_time;
        var rmem_key_currently_under_siege = __init__ (__world__.constants).rmem_key_currently_under_siege;
        var rmem_key_defense_mind_storage = __init__ (__world__.constants).rmem_key_defense_mind_storage;
        var rmem_key_empty_all_resources_into_room = __init__ (__world__.constants).rmem_key_empty_all_resources_into_room;
        var rmem_key_flag_for_testing_spawning_in_simulation = __init__ (__world__.constants).rmem_key_flag_for_testing_spawning_in_simulation;
        var rmem_key_focusing_home = __init__ (__world__.constants).rmem_key_focusing_home;
        var rmem_key_linking_mind_storage = __init__ (__world__.constants).rmem_key_linking_mind_storage;
        var rmem_key_metadata = __init__ (__world__.constants).rmem_key_metadata;
        var rmem_key_mineral_mind_storage = __init__ (__world__.constants).rmem_key_mineral_mind_storage;
        var rmem_key_now_supporting = __init__ (__world__.constants).rmem_key_now_supporting;
        var rmem_key_pause_all_room_operations = __init__ (__world__.constants).rmem_key_pause_all_room_operations;
        var rmem_key_planned_role_to_spawn = __init__ (__world__.constants).rmem_key_planned_role_to_spawn;
        var rmem_key_prepping_defenses = __init__ (__world__.constants).rmem_key_prepping_defenses;
        var rmem_key_remotes_explicitly_marked_under_attack = __init__ (__world__.constants).rmem_key_remotes_explicitly_marked_under_attack;
        var rmem_key_remotes_safe_when_under_siege = __init__ (__world__.constants).rmem_key_remotes_safe_when_under_siege;
        var rmem_key_room_reserved_up_until_tick = __init__ (__world__.constants).rmem_key_room_reserved_up_until_tick;
        var rmem_key_spawn_requests = __init__ (__world__.constants).rmem_key_spawn_requests;
        var rmem_key_sponsor = __init__ (__world__.constants).rmem_key_sponsor;
        var rmem_key_storage_use_enabled = __init__ (__world__.constants).rmem_key_storage_use_enabled;
        var rmem_key_stored_hostiles = __init__ (__world__.constants).rmem_key_stored_hostiles;
        var rmem_key_there_might_be_energy_lying_around = __init__ (__world__.constants).rmem_key_there_might_be_energy_lying_around;
        var rmem_key_total_open_source_spaces = __init__ (__world__.constants).rmem_key_total_open_source_spaces;
        var rmem_key_upgrading_paused = __init__ (__world__.constants).rmem_key_upgrading_paused;
        var rmem_key_work_parts_by_role = __init__ (__world__.constants).rmem_key_work_parts_by_role;
        var role_bases = __init__ (__world__.constants).role_bases;
        var role_builder = __init__ (__world__.constants).role_builder;
        var role_cleanup = __init__ (__world__.constants).role_cleanup;
        var role_colonist = __init__ (__world__.constants).role_colonist;
        var role_defender = __init__ (__world__.constants).role_defender;
        var role_energy_grab = __init__ (__world__.constants).role_energy_grab;
        var role_hauler = __init__ (__world__.constants).role_hauler;
        var role_link_manager = __init__ (__world__.constants).role_link_manager;
        var role_miner = __init__ (__world__.constants).role_miner;
        var role_mineral_hauler = __init__ (__world__.constants).role_mineral_hauler;
        var role_mineral_miner = __init__ (__world__.constants).role_mineral_miner;
        var role_mineral_steal = __init__ (__world__.constants).role_mineral_steal;
        var role_power_attack = __init__ (__world__.constants).role_power_attack;
        var role_power_cleanup = __init__ (__world__.constants).role_power_cleanup;
        var role_ranged_offense = __init__ (__world__.constants).role_ranged_offense;
        var role_recycling = __init__ (__world__.constants).role_recycling;
        var role_remote_mining_reserve = __init__ (__world__.constants).role_remote_mining_reserve;
        var role_room_reserve = __init__ (__world__.constants).role_room_reserve;
        var role_scout = __init__ (__world__.constants).role_scout;
        var role_simple_claim = __init__ (__world__.constants).role_simple_claim;
        var role_simple_dismantle = __init__ (__world__.constants).role_simple_dismantle;
        var role_spawn_fill = __init__ (__world__.constants).role_spawn_fill;
        var role_spawn_fill_backup = __init__ (__world__.constants).role_spawn_fill_backup;
        var role_td_goad = __init__ (__world__.constants).role_td_goad;
        var role_td_healer = __init__ (__world__.constants).role_td_healer;
        var role_temporary_replacing = __init__ (__world__.constants).role_temporary_replacing;
        var role_tower_fill = __init__ (__world__.constants).role_tower_fill;
        var role_tower_fill_once = __init__ (__world__.constants).role_tower_fill_once;
        var role_upgrade_fill = __init__ (__world__.constants).role_upgrade_fill;
        var role_upgrader = __init__ (__world__.constants).role_upgrader;
        var role_wall_defender = __init__ (__world__.constants).role_wall_defender;
        var target_big_big_repair = __init__ (__world__.constants).target_big_big_repair;
        var target_big_repair = __init__ (__world__.constants).target_big_repair;
        var target_closest_energy_site = __init__ (__world__.constants).target_closest_energy_site;
        var target_construction = __init__ (__world__.constants).target_construction;
        var target_destruction_site = __init__ (__world__.constants).target_destruction_site;
        var target_energy_hauler_mine = __init__ (__world__.constants).target_energy_hauler_mine;
        var target_energy_miner_mine = __init__ (__world__.constants).target_energy_miner_mine;
        var target_home_flag = __init__ (__world__.constants).target_home_flag;
        var target_rampart_defense = __init__ (__world__.constants).target_rampart_defense;
        var target_refill = __init__ (__world__.constants).target_refill;
        var target_repair = __init__ (__world__.constants).target_repair;
        var target_reserve_now = __init__ (__world__.constants).target_reserve_now;
        var target_single_flag = __init__ (__world__.constants).target_single_flag;
        var target_single_flag2 = __init__ (__world__.constants).target_single_flag2;
        var target_source = __init__ (__world__.constants).target_source;
        var target_spawn_deposit = __init__ (__world__.constants).target_spawn_deposit;
        var target_tower_fill = __init__ (__world__.constants).target_tower_fill;
        var autoactions = __init__ (__world__.creep_management.autoactions);
        var deathwatch = __init__ (__world__.creep_management.deathwatch);
        var mining_paths = __init__ (__world__.creep_management.mining_paths);
        var spawning = __init__ (__world__.creep_management.spawning);
        var walkby_move = __init__ (__world__.creep_management.walkby_move);
        var wrap_creep = __init__ (__world__.creep_management.creep_wrappers).wrap_creep;
        var RoleBase = __init__ (__world__.creeps.base).RoleBase;
        var HiveMind = __init__ (__world__.empire.hive).HiveMind;
        var TargetMind = __init__ (__world__.empire.targets).TargetMind;
        var errorlog = __init__ (__world__.jstools.errorlog);
        var memory_info = __init__ (__world__.jstools.memory_info);
        var records = __init__ (__world__.jstools.records);
        var new_map = __init__ (__world__.jstools.screeps_constants).new_map;
        var new_set = __init__ (__world__.jstools.screeps_constants).new_set;
        var flags = __init__ (__world__.position_management.flags);
        var locations = __init__ (__world__.position_management.locations);
        var building = __init__ (__world__.rooms.building);
        var defense = __init__ (__world__.rooms.defense);
        var hostile_utils = __init__ (__world__.utilities.hostile_utils);
        var movement = __init__ (__world__.utilities.movement);
        walkby_move.apply_move_prototype ();
        var report_error = function (err, description) {
            return errorlog.report_error ('main', err, description);
        };
        var run_creep = function (hive, targets, creeps_skipped, room, creep) {
            if (Game.cpu.getUsed () > Game.cpu.limit * 0.5 && (Game.cpu.bucket < 3000 && (Game.gcl.level > 1 || Game.cpu.bucket < 1000))) {
                var role = creep.memory.role;
                if (!(role == role_spawn_fill || role == role_tower_fill || role == role_link_manager || role == role_hauler || role == role_miner || role == role_ranged_offense || role == role_wall_defender)) {
                    if (creeps_skipped [room.name]) {
                        creeps_skipped [room.name].append (creep.name);
                    }
                    else {
                        creeps_skipped [room.name] = [creep.name];
                    }
                    return ;
                }
            }
            try {
                if (creep.spawning && creep.memory.role != role_temporary_replacing) {
                    return ;
                }
                if (creep.defense_override) {
                    return ;
                }
                records.start_record ();
                var instance = wrap_creep (hive, targets, room, creep);
                if (!(instance)) {
                    if (creep.memory.role) {
                        print ("[{}][{}] Couldn't find role-type wrapper for role {}!".format (creep.memory.home, creep.name, creep.memory.role));
                    }
                    else {
                        print ("[{}][{}] Couldn't find this creep's role.".format (creep.memory.home, creep.name));
                    }
                    var role = default_roles [spawning.find_base_type (creep)];
                    if (role) {
                        creep.memory.role = role;
                        var instance = wrap_creep (hive, targets, room, creep);
                        room.register_to_role (instance);
                    }
                    else {
                        var instance = RoleBase (hive, targets, room, creep);
                        instance.go_to_depot ();
                    }
                }
                records.finish_record ('hive.wrap-creep');
                creep.wrapped = instance;
                records.start_record ();
                var bef = Game.cpu.getUsed ();
                var rerun = instance.run ();
                if (Game.cpu.bucket >= 7000 || Game.cpu.getUsed () - bef < 0.3) {
                    if (rerun) {
                        var rerun = instance.run ();
                    }
                    if (rerun) {
                        var rerun = instance.run ();
                    }
                    if (rerun) {
                        print ('[{}][{}: {}] Tried to rerun three times!'.format (instance.home.name, creep.name, creep.memory.role));
                    }
                }
                records.finish_record (creep.memory.role);
            }
            catch (__except0__) {
                report_error (__except0__, 'Error running role {}, creep {} at {} from room {} not run this tick.'.format (creep.memory.role, creep.name, creep.pos, creep.memory.home));
            }
        };
        var run_room = function (targets, creeps_skipped, room) {
            try {
                if (room.mem [rmem_key_pause_all_room_operations]) {
                    return ;
                }
                records.start_record ();
                room.defense.tick ();
                records.finish_record ('defense.tick');
                if (('skipped_last_turn' in Memory) && (room.name in Memory.skipped_last_turn)) {
                    var __iterable0__ = room.creeps;
                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                        var creep = __iterable0__ [__index0__];
                        var role = creep.memory.role;
                        if (role == role_spawn_fill || role == role_tower_fill || role == role_link_manager || role == role_hauler || role == role_miner || role == role_ranged_offense || role == role_wall_defender) {
                            run_creep (room.hive, targets, creeps_skipped, room, creep);
                        }
                    }
                    var __iterable0__ = Memory.skipped_last_turn [room.name];
                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                        var name = __iterable0__ [__index0__];
                        var creep = Game.creeps [name];
                        if (creep) {
                            run_creep (room.hive, targets, creeps_skipped, room, creep);
                        }
                    }
                }
                else {
                    records.start_record ();
                    room.precreep_tick_actions ();
                    records.finish_record ('room.tick');
                    var __iterable0__ = room.creeps;
                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                        var creep = __iterable0__ [__index0__];
                        run_creep (room.hive, targets, creeps_skipped, room, creep);
                    }
                    if (Game.cpu.bucket >= 4500 && __mod__ (Game.time + room.get_unique_owned_index (), 50) == 0) {
                        try {
                            records.start_record ();
                            var actually_did_anything = room.building.build_most_needed_road ();
                            if (actually_did_anything) {
                                records.finish_record ('building.roads.check-pavement');
                            }
                            else {
                                records.finish_record ('building.roads.cache-checks-only');
                            }
                        }
                        catch (__except0__) {
                            records.finish_record ('building.roads.errored');
                            report_error (__except0__, 'Error running road building in {}.'.format (room.name));
                        }
                    }
                    records.start_record ();
                    room.building.place_home_ramparts ();
                    records.finish_record ('building.ramparts');
                    var __iterable0__ = room.spawns;
                    for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                        var spawn = __iterable0__ [__index0__];
                        records.start_record ();
                        spawning.run (room, spawn);
                        records.finish_record ('spawn.tick');
                    }
                }
                records.start_record ();
                room.links.tick_links ();
                records.finish_record ('links.tick');
                if (__mod__ (Game.time, 525) == 17) {
                    records.start_record ();
                    room.mining.cleanup_old_flag_sitting_values ();
                    records.finish_record ('mining.cleanup_flags');
                }
                records.start_record ();
                room.minerals.tick_terminal ();
                records.finish_record ('terminal.tick');
            }
            catch (__except0__) {
                report_error (__except0__, 'Error running room {}'.format (room.name));
            }
        };
        var main = function () {
            if (_memory_init === null) {
                init_memory ();
            }
            records.prep_recording ();
            records.start_main_record ();
            records.record_memory_amount (_memory_init);
            _memory_init = null;
            records.start_record ();
            if (!('meta' in Memory)) {
                Memory.meta = {'pause': false, 'quiet': false, 'friends': []};
            }
            var bucket_tier = math.floor ((Game.cpu.bucket - 1) / 1000);
            if (bucket_tier != Memory.meta.last_bucket && bucket_tier) {
                if (bucket_tier > Memory.meta.last_bucket) {
                    print ('[main][bucket] Reached a tier {} bucket.'.format (bucket_tier));
                    if (bucket_tier >= 6) {
                        delete Memory.meta.auto_enable_profiling;
                    }
                }
                else {
                    print ('[main][bucket] Down to a tier {} bucket.'.format (bucket_tier));
                    if (bucket_tier <= 1) {
                        Memory.meta.pause = true;
                        var hive = HiveMind (TargetMind ());
                        var __iterable0__ = hive.my_rooms;
                        for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                            var room = __iterable0__ [__index0__];
                            room.defense.set_ramparts (true);
                        }
                    }
                }
            }
            Memory.meta.last_bucket = bucket_tier;
            if (Memory.meta.pause) {
                if (Memory.meta.waiting_for_bucket) {
                    if (Game.gcl.level <= 2 && Game.cpu.bucket > 2000 || Game.cpu.bucket >= 10000) {
                        print ('[paused] Bucket full, resuming next tick.');
                        delete Memory.meta.pause;
                        delete Memory.meta.waiting_for_bucket;
                    }
                    else {
                        print ('[paused] Bucket accumulated: {} (used loading code: {})'.format (Game.cpu.bucket, math.floor (Game.cpu.getUsed ())));
                    }
                }
                else if (Game.cpu.bucket <= 5000) {
                    Memory.meta.waiting_for_bucket = true;
                }
                return ;
            }
            records.finish_record ('bucket.check');
            records.start_record ();
            flags.move_flags ();
            records.finish_record ('flags.move');
            records.start_record ();
            locations.init ();
            if (__mod__ (Game.time, 320) == 94) {
                locations.clean_old_positions ();
            }
            records.finish_record ('locations.init');
            records.start_record ();
            PathFinder.use (true);
            var targets = TargetMind ();
            var hive = HiveMind (targets);
            context.set_hive (hive);
            records.finish_record ('hive.init');
            if (__mod__ (Game.time, 320) == 53) {
                records.start_record ();
                consistency.clear_cache ();
                records.finish_record ('cache.clean');
            }
            if (__mod__ (Game.time, 100000) == 6798) {
                records.start_record ();
                consistency.complete_refresh (hive);
                records.finish_record ('cache.complete-refresh');
            }
            if (__mod__ (Game.time, 600) == 550) {
                records.start_record ();
                mining_paths.cleanup_old_values (hive);
                records.finish_record ('mining-paths.cleanup');
            }
            if (__mod__ (Game.time, 600) == 551) {
                records.start_record ();
                building.clean_up_all_road_construction_sites ();
                records.finish_record ('building.clean-up-road-construction-sites');
            }
            records.start_record ();
            hive.poll_all_creeps ();
            records.finish_record ('hive.poll-creeps');
            if (__mod__ (Game.time, 5) == 1 || !(_.isEmpty (Memory.hostiles))) {
                records.start_record ();
                deathwatch.start_of_tick_check ();
                records.finish_record ('deathwatch.check');
                records.start_record ();
                defense.poll_hostiles (hive, autoactions.running_check_room);
                records.finish_record ('defense.poll-hostiles');
            }
            if (__mod__ (Game.time, 25) == 7) {
                records.start_record ();
                defense.cleanup_stored_hostiles ();
                records.finish_record ('defense.clean-hostiles');
            }
            if (!(Memory.creeps)) {
                Memory.creeps = {};
                var __iterable0__ = Object.keys (Game.creeps);
                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                    var name = __iterable0__ [__index0__];
                    Memory.creeps [name] = {};
                }
            }
            records.start_record ();
            hive.find_my_rooms ();
            records.finish_record ('hive.poll-rooms');
            if (__mod__ (Game.time, 50) == 40) {
                records.start_record ();
                hive.states.calculate_room_states ();
                records.finish_record ('hive.calc-states');
            }
            var creeps_skipped = {};
            if (('skipped_last_turn' in Memory)) {
                print ('[main] Running {} creeps skipped last tick, to save CPU.'.format (_.sum (Memory.skipped_last_turn, 'length')));
                var __iterable0__ = Object.keys (Memory.skipped_last_turn);
                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                    var room_name = __iterable0__ [__index0__];
                    var room = hive.get_room (room_name);
                    if (!(room)) {
                        print ('[{}] Room no longer visible? skipping re-running creeps skipped last turn from this room.'.format (room_name));
                        continue;
                    }
                    run_room (targets, creeps_skipped, room);
                }
                delete Memory.skipped_last_turn;
            }
            else {
                var rooms = hive.my_rooms;
                if (Game.gcl.level > 1 && Game.cpu.bucket <= 4000) {
                    var rooms = sorted (rooms, (function __lambda__ (r) {
                        return -(r.rcl) - r.room.controller.progress / r.room.controller.progressTotal;
                    }));
                    var rooms = rooms.__getslice__ (0, len (rooms) - 1, 1);
                }
                var used_start = Game.cpu.getUsed ();
                var __iterable0__ = rooms;
                for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                    var room = __iterable0__ [__index0__];
                    run_room (targets, creeps_skipped, room);
                    if (Game.cpu.getUsed () - used_start >= 400) {
                        print ('[main] Used >= 400 CPU this tick! Skipping everything else.');
                        return ;
                    }
                }
            }
            records.start_record ();
            var __iterable0__ = hive.visible_rooms;
            for (var __index0__ = 0; __index0__ < __iterable0__.length; __index0__++) {
                var room = __iterable0__ [__index0__];
                autoactions.pickup_check_room (room);
            }
            records.finish_record ('auto.pickup');
            if (__mod__ (Game.time, 50) == 40) {
                records.start_record ();
                autoactions.cleanup_running_memory ();
                records.finish_record ('auto.running-memory-cleanup');
            }
            if (!(_.isEmpty (creeps_skipped))) {
                var skipped_count = _.sum (creeps_skipped, 'length');
                if (skipped_count) {
                    if (Memory.skipped_last_turn) {
                        var all_creeps = _.sum (Memory.skipped_last_turn, 'length');
                    }
                    else {
                        var all_creeps = len (Object.keys (Game.creeps));
                    }
                    print ('[main] Skipped {}/{} creeps, to save CPU.'.format (skipped_count, all_creeps));
                    print ('[main] Total CPU used: {}. Bucket: {}.'.format (math.floor (Game.cpu.getUsed ()), Game.cpu.bucket));
                    Memory.skipped_last_turn = creeps_skipped;
                }
            }
            if (Game.cpu.bucket === undefined || Game.cpu.bucket >= 6000 && !(Memory.meta.quiet)) {
                records.start_record ();
                hive.sing ();
                records.finish_record ('hive.sing');
            }
            records.finish_main_record ();
        };
        module.exports.loop = main;
        global
        .py = {'context': context, 'consistency': consistency, 'autoactions': autoactions, 'locations': locations, 'defense': defense, 'movement': movement, 'flags': flags, 'constants': constants, 'spawning': spawning, 'volatile': volatile_cache, 'cache': global_cache, 'hostile_utils': hostile_utils, 'building': building, 'mining_paths': mining_paths, 'meminfo': memory_info, 'hive': (function __lambda__ () {
            return context.hive ();
        }), 'get_room': (function __lambda__ (name) {
            return context.hive ().get_room (name);
        }), 'get_creep': (function __lambda__ (name) {
            return ((name in Game.creeps) ? wrap_creep (context.hive (), context.hive ().targets, context.hive ().get_room (Memory.creeps [name].home), Game.creeps [name]) : null);
        }), 'cc': global_cache.clear_values_matching, 'full_refresh': (function __lambda__ () {
            return consistency.complete_refresh (context.hive ());
        }), 'analyse_mem': (function __lambda__ (path) {
            return memory_info.analyse_memory (path);
        }), 'cache_stats': (function __lambda__ () {
            return memory_info.cache_stats ();
        }), 'records': {'start': records.start_recording, 'stop': records.stop_recording, 'start_sub': records.start_sub_recording, 'output': records.output_records, 'output_sub': records.output_sub_records, 'reset': records.reset_records}};
        RoomPosition.prototype.createFlag2 = (function __lambda__ (flag_type) {
            return flags.create_flag (this, flag_type);
        });
        RoomPosition.prototype.cfms = (function __lambda__ (main_type, sub_type) {
            return flags.create_ms_flag (this, main_type, sub_type);
        });
        records.prep_recording ();
        records.record_compile_amount (Game.cpu.getUsed () - _start_of_compile);
        __pragma__ ('<use>' +
            'cache.consistency' +
            'cache.context' +
            'cache.global_cache' +
            'cache.volatile_cache' +
            'constants' +
            'creep_management.autoactions' +
            'creep_management.creep_wrappers' +
            'creep_management.deathwatch' +
            'creep_management.mining_paths' +
            'creep_management.spawning' +
            'creep_management.walkby_move' +
            'creeps.base' +
            'empire.hive' +
            'empire.targets' +
            'jstools.errorlog' +
            'jstools.memory_info' +
            'jstools.records' +
            'jstools.screeps_constants' +
            'math' +
            'position_management.flags' +
            'position_management.locations' +
            'rooms.building' +
            'rooms.defense' +
            'utilities.hostile_utils' +
            'utilities.movement' +
        '</use>')
        __pragma__ ('<all>')
            __all__.ATTACK_DISMANTLE = ATTACK_DISMANTLE;
            __all__.ATTACK_POWER_BANK = ATTACK_POWER_BANK;
            __all__.CLAIM_LATER = CLAIM_LATER;
            __all__.DEPOT = DEPOT;
            __all__.ENERGY_GRAB = ENERGY_GRAB;
            __all__.HiveMind = HiveMind;
            __all__.INVADER_USERNAME = INVADER_USERNAME;
            __all__.LOCAL_MINE = LOCAL_MINE;
            __all__.PYFIND_BUILDABLE_ROADS = PYFIND_BUILDABLE_ROADS;
            __all__.PYFIND_HURT_CREEPS = PYFIND_HURT_CREEPS;
            __all__.PYFIND_REPAIRABLE_ROADS = PYFIND_REPAIRABLE_ROADS;
            __all__.RAID_OVER = RAID_OVER;
            __all__.RAMPART_DEFENSE = RAMPART_DEFENSE;
            __all__.RANGED_DEFENSE = RANGED_DEFENSE;
            __all__.REAP_POWER_BANK = REAP_POWER_BANK;
            __all__.REMOTE_MINE = REMOTE_MINE;
            __all__.REROUTE = REROUTE;
            __all__.REROUTE_DESTINATION = REROUTE_DESTINATION;
            __all__.RESERVE_NOW = RESERVE_NOW;
            __all__.RoleBase = RoleBase;
            __all__.SCOUT = SCOUT;
            __all__.SK_LAIR_SOURCE_NOTED = SK_LAIR_SOURCE_NOTED;
            __all__.SK_USERNAME = SK_USERNAME;
            __all__.SLIGHTLY_AVOID = SLIGHTLY_AVOID;
            __all__.SPAWN_FILL_WAIT = SPAWN_FILL_WAIT;
            __all__.TD_D_GOAD = TD_D_GOAD;
            __all__.TD_H_D_STOP = TD_H_D_STOP;
            __all__.TD_H_H_STOP = TD_H_H_STOP;
            __all__.TargetMind = TargetMind;
            __all__.UPGRADER_SPOT = UPGRADER_SPOT;
            __all__._memory_init = _memory_init;
            __all__._start_of_compile = _start_of_compile;
            __all__.autoactions = autoactions;
            __all__.building = building;
            __all__.consistency = consistency;
            __all__.context = context;
            __all__.creep_base_1500miner = creep_base_1500miner;
            __all__.creep_base_3000miner = creep_base_3000miner;
            __all__.creep_base_3h = creep_base_3h;
            __all__.creep_base_4000miner = creep_base_4000miner;
            __all__.creep_base_carry3000miner = creep_base_carry3000miner;
            __all__.creep_base_claim_attack = creep_base_claim_attack;
            __all__.creep_base_claiming = creep_base_claiming;
            __all__.creep_base_defender = creep_base_defender;
            __all__.creep_base_dismantler = creep_base_dismantler;
            __all__.creep_base_full_move_dismantler = creep_base_full_move_dismantler;
            __all__.creep_base_full_move_goader = creep_base_full_move_goader;
            __all__.creep_base_full_move_healer = creep_base_full_move_healer;
            __all__.creep_base_full_move_power_attack = creep_base_full_move_power_attack;
            __all__.creep_base_full_upgrader = creep_base_full_upgrader;
            __all__.creep_base_goader = creep_base_goader;
            __all__.creep_base_half_move_hauler = creep_base_half_move_hauler;
            __all__.creep_base_half_move_healer = creep_base_half_move_healer;
            __all__.creep_base_hauler = creep_base_hauler;
            __all__.creep_base_mammoth_miner = creep_base_mammoth_miner;
            __all__.creep_base_power_attack = creep_base_power_attack;
            __all__.creep_base_rampart_defense = creep_base_rampart_defense;
            __all__.creep_base_ranged_offense = creep_base_ranged_offense;
            __all__.creep_base_reserving = creep_base_reserving;
            __all__.creep_base_scout = creep_base_scout;
            __all__.creep_base_work_full_move_hauler = creep_base_work_full_move_hauler;
            __all__.creep_base_work_half_move_hauler = creep_base_work_half_move_hauler;
            __all__.creep_base_worker = creep_base_worker;
            __all__.deathwatch = deathwatch;
            __all__.default_roles = default_roles;
            __all__.defense = defense;
            __all__.errorlog = errorlog;
            __all__.flags = flags;
            __all__.global_cache = global_cache;
            __all__.global_cache_mining_roads_suffix = global_cache_mining_roads_suffix;
            __all__.gmem_key_last_room_state_refresh = gmem_key_last_room_state_refresh;
            __all__.gmem_key_room_mining_paths = gmem_key_room_mining_paths;
            __all__.hostile_utils = hostile_utils;
            __all__.init_memory = init_memory;
            __all__.locations = locations;
            __all__.main = main;
            __all__.max_repath_mine_roads_every = max_repath_mine_roads_every;
            __all__.max_repave_mine_roads_every = max_repave_mine_roads_every;
            __all__.memory_info = memory_info;
            __all__.min_repath_mine_roads_every = min_repath_mine_roads_every;
            __all__.min_repave_mine_roads_every = min_repave_mine_roads_every;
            __all__.mining_paths = mining_paths;
            __all__.movement = movement;
            __all__.new_map = new_map;
            __all__.new_set = new_set;
            __all__.old_role_names = old_role_names;
            __all__.records = records;
            __all__.recycle_time = recycle_time;
            __all__.report_error = report_error;
            __all__.request_priority_economy = request_priority_economy;
            __all__.request_priority_helping_party = request_priority_helping_party;
            __all__.request_priority_imminent_threat_defense = request_priority_imminent_threat_defense;
            __all__.request_priority_low = request_priority_low;
            __all__.rmem_key_building_paused = rmem_key_building_paused;
            __all__.rmem_key_building_priority_spawn = rmem_key_building_priority_spawn;
            __all__.rmem_key_building_priority_walls = rmem_key_building_priority_walls;
            __all__.rmem_key_cache = rmem_key_cache;
            __all__.rmem_key_carry_parts_by_role = rmem_key_carry_parts_by_role;
            __all__.rmem_key_creeps_by_role = rmem_key_creeps_by_role;
            __all__.rmem_key_creeps_by_role_and_replacement_time = rmem_key_creeps_by_role_and_replacement_time;
            __all__.rmem_key_currently_under_siege = rmem_key_currently_under_siege;
            __all__.rmem_key_defense_mind_storage = rmem_key_defense_mind_storage;
            __all__.rmem_key_empty_all_resources_into_room = rmem_key_empty_all_resources_into_room;
            __all__.rmem_key_flag_for_testing_spawning_in_simulation = rmem_key_flag_for_testing_spawning_in_simulation;
            __all__.rmem_key_focusing_home = rmem_key_focusing_home;
            __all__.rmem_key_linking_mind_storage = rmem_key_linking_mind_storage;
            __all__.rmem_key_metadata = rmem_key_metadata;
            __all__.rmem_key_mineral_mind_storage = rmem_key_mineral_mind_storage;
            __all__.rmem_key_now_supporting = rmem_key_now_supporting;
            __all__.rmem_key_pause_all_room_operations = rmem_key_pause_all_room_operations;
            __all__.rmem_key_planned_role_to_spawn = rmem_key_planned_role_to_spawn;
            __all__.rmem_key_prepping_defenses = rmem_key_prepping_defenses;
            __all__.rmem_key_remotes_explicitly_marked_under_attack = rmem_key_remotes_explicitly_marked_under_attack;
            __all__.rmem_key_remotes_safe_when_under_siege = rmem_key_remotes_safe_when_under_siege;
            __all__.rmem_key_room_reserved_up_until_tick = rmem_key_room_reserved_up_until_tick;
            __all__.rmem_key_spawn_requests = rmem_key_spawn_requests;
            __all__.rmem_key_sponsor = rmem_key_sponsor;
            __all__.rmem_key_storage_use_enabled = rmem_key_storage_use_enabled;
            __all__.rmem_key_stored_hostiles = rmem_key_stored_hostiles;
            __all__.rmem_key_there_might_be_energy_lying_around = rmem_key_there_might_be_energy_lying_around;
            __all__.rmem_key_total_open_source_spaces = rmem_key_total_open_source_spaces;
            __all__.rmem_key_upgrading_paused = rmem_key_upgrading_paused;
            __all__.rmem_key_work_parts_by_role = rmem_key_work_parts_by_role;
            __all__.role_bases = role_bases;
            __all__.role_builder = role_builder;
            __all__.role_cleanup = role_cleanup;
            __all__.role_colonist = role_colonist;
            __all__.role_defender = role_defender;
            __all__.role_energy_grab = role_energy_grab;
            __all__.role_hauler = role_hauler;
            __all__.role_link_manager = role_link_manager;
            __all__.role_miner = role_miner;
            __all__.role_mineral_hauler = role_mineral_hauler;
            __all__.role_mineral_miner = role_mineral_miner;
            __all__.role_mineral_steal = role_mineral_steal;
            __all__.role_power_attack = role_power_attack;
            __all__.role_power_cleanup = role_power_cleanup;
            __all__.role_ranged_offense = role_ranged_offense;
            __all__.role_recycling = role_recycling;
            __all__.role_remote_mining_reserve = role_remote_mining_reserve;
            __all__.role_room_reserve = role_room_reserve;
            __all__.role_scout = role_scout;
            __all__.role_simple_claim = role_simple_claim;
            __all__.role_simple_dismantle = role_simple_dismantle;
            __all__.role_spawn_fill = role_spawn_fill;
            __all__.role_spawn_fill_backup = role_spawn_fill_backup;
            __all__.role_td_goad = role_td_goad;
            __all__.role_td_healer = role_td_healer;
            __all__.role_temporary_replacing = role_temporary_replacing;
            __all__.role_tower_fill = role_tower_fill;
            __all__.role_tower_fill_once = role_tower_fill_once;
            __all__.role_upgrade_fill = role_upgrade_fill;
            __all__.role_upgrader = role_upgrader;
            __all__.role_wall_defender = role_wall_defender;
            __all__.run_creep = run_creep;
            __all__.run_room = run_room;
            __all__.spawning = spawning;
            __all__.target_big_big_repair = target_big_big_repair;
            __all__.target_big_repair = target_big_repair;
            __all__.target_closest_energy_site = target_closest_energy_site;
            __all__.target_construction = target_construction;
            __all__.target_destruction_site = target_destruction_site;
            __all__.target_energy_hauler_mine = target_energy_hauler_mine;
            __all__.target_energy_miner_mine = target_energy_miner_mine;
            __all__.target_home_flag = target_home_flag;
            __all__.target_rampart_defense = target_rampart_defense;
            __all__.target_refill = target_refill;
            __all__.target_repair = target_repair;
            __all__.target_reserve_now = target_reserve_now;
            __all__.target_single_flag = target_single_flag;
            __all__.target_single_flag2 = target_single_flag2;
            __all__.target_source = target_source;
            __all__.target_spawn_deposit = target_spawn_deposit;
            __all__.target_tower_fill = target_tower_fill;
            __all__.volatile_cache = volatile_cache;
            __all__.walkby_move = walkby_move;
            __all__.wrap_creep = wrap_creep;
        __pragma__ ('</all>')
    }) ();
   return __all__;
}
main ();
